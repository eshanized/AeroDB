{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AeroDB Documentation","text":"<p>Welcome to the official documentation for AeroDB, a strict, deterministic, and production-grade database system.</p> <ul> <li> <p> Getting Started</p> <p>Learn how to install, configure, and run AeroDB in minutes.</p> <p> Quick Start</p> </li> <li> <p> Core Concepts</p> <p>Understand the philosophy of correctness, determinism, and reliability.</p> <p> Principles</p> </li> <li> <p> Architecture</p> <p>Deep dive into MVCC, WAL, Storage, and Replication/Failover models.</p> <p> Architecture</p> </li> <li> <p> API Reference</p> <p>Comprehensive guide to HTTP endpoints, Authentication, and Real-time APIs.</p> <p> API Spec</p> </li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<p>Production Readiness</p> <p>AeroDB is designed for mission-critical systems where data loss or corruption is unacceptable.</p>"},{"location":"#correctness-first","title":"Correctness First","text":"<ul> <li>Strict Schema Enforcement: No schemaless writes</li> <li>Deterministic Query Execution: Predictable performance</li> <li>Crash Safety: WAL-backed durability for every write</li> </ul>"},{"location":"#robust-infrastructure","title":"Robust Infrastructure","text":"<ul> <li>Leader-Follower Replication: Atomic failover with split-brain protection</li> <li>Point-in-Time Recovery: Consistent snapshots and restoration</li> <li>Zero-Dependency: Self-contained binary, easy self-hosting</li> </ul>"},{"location":"#modern-developer-experience","title":"Modern Developer Experience","text":"<ul> <li>Admin Dashboard: Visual management of data, users, and cluster</li> <li>Real-time Subscriptions: WebSocket-based live updates</li> <li>Serverless Functions: Integrated WASM runtime</li> </ul>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<p>The documentation is organized into clear sections matching the system's architecture:</p> <ol> <li>Core System: Fundamental invariants, storage engine, and lifecycle.</li> <li>MVCC: Multi-Version Concurrency Control implementation details.</li> <li>Replication: Distributed consensus, failover, and data synchronization.</li> <li>Performance: Optimization strategies, proof rules, and benchmarks.</li> <li>Developer Experience: SDKs, UI, and observability tools.</li> <li>Implementation Phases: Detailed roadmap and architectural decisions for each phase.</li> </ol>"},{"location":"#contributing","title":"Contributing","text":"<p>AeroDB is open source software. We welcome contributions that align with our core values of reliability and correctness.</p> <p>Contribution Guidelines Security Policy</p>"},{"location":"ADMIN_UI_ARCHITECTURE/","title":"Phase 13: Admin Dashboard - Architecture","text":""},{"location":"ADMIN_UI_ARCHITECTURE/#system-overview","title":"System Overview","text":"<p>The Admin Dashboard is a React-based SPA (Single Page Application) that communicates exclusively with AeroDB's public APIs. It has no direct database access, no special privileges, and can be deployed independently of the database server.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Browser (User)                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502         Admin Dashboard (React SPA)                   \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u2502\n\u2502  \u2502  \u2502 Table       \u2502  \u2502 Schema       \u2502  \u2502 User        \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502 Browser     \u2502  \u2502 Editor       \u2502  \u2502 Manager     \u2502  \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502         \u2193 HTTP/WS                                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 AeroDB  \u2193 Public APIs Only                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  REST API    \u2502  \u2502  Auth API     \u2502  \u2502  Control Plane  \u2502  \u2502\n\u2502  \u2502  /rest/v1    \u2502  \u2502  /auth        \u2502  \u2502  /control       \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502         \u2193                  \u2193                      \u2193          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502              Query Executor (Core)                   \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"ADMIN_UI_ARCHITECTURE/#technology-stack","title":"Technology Stack","text":""},{"location":"ADMIN_UI_ARCHITECTURE/#frontend","title":"Frontend","text":"<ul> <li>Framework: React 18+ (with TypeScript)</li> <li>State Management: React Query (for server state) + Zustand (for UI state)</li> <li>UI Library: shadcn/ui (Radix UI primitives + Tailwind CSS)</li> <li>Routing: React Router v6</li> <li>Charts: Recharts (for metrics dashboards)</li> <li>Code Editor: Monaco Editor (for SQL console)</li> <li>HTTP Client: Axios (with interceptors for auth)</li> <li>WebSocket: Native WebSocket API (for real-time updates)</li> </ul>"},{"location":"ADMIN_UI_ARCHITECTURE/#build-tooling","title":"Build Tooling","text":"<ul> <li>Bundler: Vite (fast dev server, HMR)</li> <li>TypeScript: Strict mode enabled</li> <li>Linter: ESLint + Prettier</li> <li>Testing: Vitest (unit) + Playwright (E2E)</li> </ul>"},{"location":"ADMIN_UI_ARCHITECTURE/#application-structure","title":"Application Structure","text":"<pre><code>dashboard/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/          # Shared UI components\n\u2502   \u2502   \u251c\u2500\u2500 ui/              # shadcn/ui components\n\u2502   \u2502   \u251c\u2500\u2500 layout/          # Header, Sidebar, Layout\n\u2502   \u2502   \u2514\u2500\u2500 common/          # Buttons, Modals, Tables\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 features/            # Feature-specific modules\n\u2502   \u2502   \u251c\u2500\u2500 database/        # Table browser, SQL console\n\u2502   \u2502   \u251c\u2500\u2500 auth/            # User management, sessions\n\u2502   \u2502   \u251c\u2500\u2500 storage/         # File browser, uploads\n\u2502   \u2502   \u251c\u2500\u2500 realtime/        # Subscriptions, events\n\u2502   \u2502   \u251c\u2500\u2500 cluster/         # Topology, replication\n\u2502   \u2502   \u2514\u2500\u2500 observability/   # Logs, metrics, audit\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 lib/                 # Shared utilities\n\u2502   \u2502   \u251c\u2500\u2500 api/             # API client wrappers\n\u2502   \u2502   \u251c\u2500\u2500 auth/            # Auth context, hooks\n\u2502   \u2502   \u251c\u2500\u2500 hooks/           # Custom React hooks\n\u2502   \u2502   \u2514\u2500\u2500 utils/           # Helper functions\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 types/               # TypeScript type definitions\n\u2502   \u251c\u2500\u2500 config/              # App configuration\n\u2502   \u251c\u2500\u2500 App.tsx              # Root component\n\u2502   \u2514\u2500\u2500 main.tsx             # Entry point\n\u2502\n\u251c\u2500\u2500 public/                  # Static assets\n\u251c\u2500\u2500 tests/                   # E2E tests\n\u2514\u2500\u2500 package.json\n</code></pre>"},{"location":"ADMIN_UI_ARCHITECTURE/#core-components","title":"Core Components","text":""},{"location":"ADMIN_UI_ARCHITECTURE/#1-api-client-layer","title":"1. API Client Layer","text":"<p>All HTTP requests go through a centralized client:</p> <pre><code>// lib/api/client.ts\nimport axios from 'axios';\n\nexport const apiClient = axios.create({\n  baseURL: import.meta.env.VITE_AERODB_URL,\n  timeout: 30000,\n});\n\n// Request interceptor: Attach JWT\napiClient.interceptors.request.use((config) =&gt; {\n  const token = localStorage.getItem('access_token');\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n});\n\n// Response interceptor: Handle 401, refresh tokens\napiClient.interceptors.response.use(\n  (response) =&gt; response,\n  async (error) =&gt; {\n    if (error.response?.status === 401) {\n      // Attempt token refresh\n      const refreshed = await refreshAccessToken();\n      if (refreshed) {\n        // Retry original request\n        return apiClient.request(error.config);\n      } else {\n        // Redirect to login\n        window.location.href = '/login';\n      }\n    }\n    return Promise.reject(error);\n  }\n);\n</code></pre>"},{"location":"ADMIN_UI_ARCHITECTURE/#2-data-fetching-with-react-query","title":"2. Data Fetching with React Query","text":"<p>Use React Query for server state management:</p> <pre><code>// features/database/hooks/useCollections.ts\nimport { useQuery } from '@tanstack/react-query';\nimport { apiClient } from '@/lib/api/client';\n\nexport function useCollections() {\n  return useQuery({\n    queryKey: ['collections'],\n    queryFn: async () =&gt; {\n      const { data } = await apiClient.get('/rest/v1/_schema/collections');\n      return data;\n    },\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  });\n}\n</code></pre>"},{"location":"ADMIN_UI_ARCHITECTURE/#3-table-browser","title":"3. Table Browser","text":"<p>Paginated table view with filters:</p> <pre><code>// features/database/components/TableBrowser.tsx\nimport { useTableData } from '../hooks/useTableData';\nimport { DataTable } from '@/components/common/DataTable';\n\nexport function TableBrowser({ collection }: { collection: string }) {\n  const [page, setPage] = useState(0);\n  const [filters, setFilters] = useState({});\n\n  const { data, isLoading } = useTableData(collection, {\n    limit: 20,\n    offset: page * 20,\n    filters,\n  });\n\n  return (\n    &lt;div&gt;\n      &lt;FilterBar filters={filters} onChange={setFilters} /&gt;\n      &lt;DataTable\n        data={data?.rows || []}\n        columns={data?.columns || []}\n        loading={isLoading}\n      /&gt;\n      &lt;Pagination\n        total={data?.total || 0}\n        page={page}\n        onChange={setPage}\n      /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"ADMIN_UI_ARCHITECTURE/#4-sql-console","title":"4. SQL Console","text":"<p>Execute queries with Monaco Editor:</p> <pre><code>// features/database/components/SQLConsole.tsx\nimport MonacoEditor from '@monaco-editor/react';\nimport { useMutation } from '@tanstack/react-query';\n\nexport function SQLConsole() {\n  const [sql, setSql] = useState('');\n  const [results, setResults] = useState(null);\n\n  const executeMutation = useMutation({\n    mutationFn: async (query: string) =&gt; {\n      const { data } = await apiClient.post('/rest/v1/_query', { query });\n      return data;\n    },\n    onSuccess: (data) =&gt; setResults(data),\n  });\n\n  return (\n    &lt;div className=\"grid grid-rows-2 h-full\"&gt;\n      &lt;MonacoEditor\n        language=\"sql\"\n        value={sql}\n        onChange={(value) =&gt; setSql(value || '')}\n      /&gt;\n      &lt;Button onClick={() =&gt; executeMutation.mutate(sql)}&gt;\n        Execute\n      &lt;/Button&gt;\n      {results &amp;&amp; &lt;ResultsTable data={results} /&gt;}\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"ADMIN_UI_ARCHITECTURE/#5-real-time-updates","title":"5. Real-Time Updates","text":"<p>Connect to WebSocket for live data:</p> <pre><code>// features/realtime/hooks/useRealtimeSubscription.ts\nimport { useEffect, useState } from 'react';\n\nexport function useRealtimeSubscription(channel: string) {\n  const [events, setEvents] = useState([]);\n\n  useEffect(() =&gt; {\n    const ws = new WebSocket('wss://aerodb.example.com/realtime/v1');\n\n    ws.onopen = () =&gt; {\n      ws.send(JSON.stringify({ type: 'subscribe', channel }));\n    };\n\n    ws.onmessage = (event) =&gt; {\n      const message = JSON.parse(event.data);\n      if (message.type === 'event') {\n        setEvents((prev) =&gt; [...prev, message.payload]);\n      }\n    };\n\n    return () =&gt; ws.close();\n  }, [channel]);\n\n  return { events };\n}\n</code></pre>"},{"location":"ADMIN_UI_ARCHITECTURE/#routing-structure","title":"Routing Structure","text":"<pre><code>/                       # Dashboard home\n/login                  # Login page\n/database               # Database section\n  /database/tables      # Table list\n  /database/table/:name # Table browser\n  /database/sql         # SQL console\n  /database/schema      # Schema editor\n/auth                   # Authentication section\n  /auth/users           # User list\n  /auth/sessions        # Active sessions\n  /auth/policies        # RLS policies\n/storage                # File storage\n  /storage/buckets      # Bucket list\n  /storage/bucket/:name # File browser\n/realtime               # Real-time monitoring\n  /realtime/subscriptions # Active subscriptions\n  /realtime/events      # Event log\n/cluster                # Cluster management\n  /cluster/topology     # Topology view\n  /cluster/replication  # Replication status\n/logs                   # Observability\n  /logs/system          # System logs\n  /logs/audit           # Audit log\n/metrics                # Metrics dashboard\n</code></pre>"},{"location":"ADMIN_UI_ARCHITECTURE/#state-management-strategy","title":"State Management Strategy","text":""},{"location":"ADMIN_UI_ARCHITECTURE/#server-state-react-query","title":"Server State (React Query)","text":"<p>All API data is managed by React Query: - Automatic caching - Background refetching - Optimistic updates - Request deduplication</p>"},{"location":"ADMIN_UI_ARCHITECTURE/#ui-state-zustand","title":"UI State (Zustand)","text":"<p>Local UI state uses Zustand: - Sidebar collapsed/expanded - Current theme (light/dark) - User preferences - Active filters</p> <pre><code>// lib/store/uiStore.ts\nimport create from 'zustand';\n\ninterface UIState {\n  sidebarOpen: boolean;\n  theme: 'light' | 'dark';\n  toggleSidebar: () =&gt; void;\n  setTheme: (theme: 'light' | 'dark') =&gt; void;\n}\n\nexport const useUIStore = create&lt;UIState&gt;((set) =&gt; ({\n  sidebarOpen: true,\n  theme: 'dark',\n  toggleSidebar: () =&gt; set((state) =&gt; ({ sidebarOpen: !state.sidebarOpen })),\n  setTheme: (theme) =&gt; set({ theme }),\n}));\n</code></pre>"},{"location":"ADMIN_UI_ARCHITECTURE/#security-considerations","title":"Security Considerations","text":""},{"location":"ADMIN_UI_ARCHITECTURE/#1-token-storage","title":"1. Token Storage","text":"<ul> <li>Access Token: Store in memory (React state, not localStorage)</li> <li>Refresh Token: Store in httpOnly cookie (if server supports)</li> <li>Fallback: If no httpOnly cookies, use localStorage with XSS precautions</li> </ul>"},{"location":"ADMIN_UI_ARCHITECTURE/#2-xss-protection","title":"2. XSS Protection","text":"<ul> <li>Sanitize all user input displayed in UI (use DOMPurify)</li> <li>Use React's JSX auto-escaping</li> <li>Set Content-Security-Policy headers</li> </ul>"},{"location":"ADMIN_UI_ARCHITECTURE/#3-csrf-protection","title":"3. CSRF Protection","text":"<ul> <li>All mutations use POST/PUT/DELETE (not GET)</li> <li>Require explicit confirmation for destructive actions</li> </ul>"},{"location":"ADMIN_UI_ARCHITECTURE/#deployment","title":"Deployment","text":"<p>The dashboard is statically deployable:</p> <ol> <li>Build: <code>npm run build</code> \u2192 outputs to <code>dist/</code></li> <li>Deploy <code>dist/</code> to:</li> <li>Vercel/Netlify: Auto-deploy from Git</li> <li>S3 + CloudFront: Static hosting</li> <li>Local: Serve with <code>npx serve dist</code></li> </ol> <p>Environment variables: <pre><code>VITE_AERODB_URL=https://api.aerodb.example.com\nVITE_WS_URL=wss://api.aerodb.example.com/realtime/v1\n</code></pre></p>"},{"location":"ADMIN_UI_ARCHITECTURE/#non-goals","title":"Non-Goals","text":"<p>The dashboard does not: - Store any application state server-side - Have its own database or cache layer - Require a backend-for-frontend (BFF) - Provide offline-first capabilities (read-only cache is acceptable)</p> <p>All logic is client-side, all data is fetched from AeroDB APIs.</p>"},{"location":"ADMIN_UI_INVARIANTS/","title":"Phase 13: Admin Dashboard - Invariants","text":""},{"location":"ADMIN_UI_INVARIANTS/#critical-invariants","title":"Critical Invariants","text":""},{"location":"ADMIN_UI_INVARIANTS/#i1-dashboard-cannot-break-database","title":"I1: Dashboard Cannot Break Database","text":"<p>Invariant: Dashboard failures never impact database availability or correctness.</p> <p>Rationale: Dashboard is observability-only. Database operations must succeed regardless of dashboard state.</p> <p>Enforcement: - Dashboard runs in separate process/container from database - Dashboard uses public APIs only (no direct DB access) - Database does not wait for or depend on dashboard responses</p> <p>Test: Kill dashboard process \u2192 database continues serving queries</p>"},{"location":"ADMIN_UI_INVARIANTS/#i2-database-is-source-of-truth","title":"I2: Database is Source of Truth","text":"<p>Invariant: If dashboard and database disagree on state, database wins.</p> <p>Rationale: Dashboard may cache stale data, but should never define authoritative state.</p> <p>Enforcement: - All writes go through REST/Auth APIs (which enforce invariants) - Dashboard displays \"as of [timestamp]\" for cached data - Refresh button always fetches latest from database</p> <p>Test: Update data via CLI \u2192 dashboard shows stale data \u2192 refresh shows correct data</p>"},{"location":"ADMIN_UI_INVARIANTS/#i3-no-hidden-mutations","title":"I3: No Hidden Mutations","text":"<p>Invariant: Every write operation is explicitly user-initiated and reversible (or has confirmation).</p> <p>Rationale: Users must understand what the dashboard is doing. No background mutations.</p> <p>Enforcement: - Destructive actions require confirmation dialog - All mutations show API endpoint being called - Read-only mode available (no write buttons shown)</p> <p>Test: Click \"Delete User\" \u2192 confirmation dialog shows \u2192 cancel works</p>"},{"location":"ADMIN_UI_INVARIANTS/#i4-rls-respected","title":"I4: RLS Respected","text":"<p>Invariant: Dashboard never bypasses RLS unless using service role.</p> <p>Rationale: Users should only see data they have permission to access.</p> <p>Enforcement: - User JWT passed to all API calls - Service role token used only for admin pages (explicitly labeled) - RLS policies enforced server-side (not in dashboard code)</p> <p>Test: User A logs in \u2192 can see only their data \u2192 cannot see User B's data</p>"},{"location":"ADMIN_UI_INVARIANTS/#i5-api-version-compatibility","title":"I5: API Version Compatibility","text":"<p>Invariant: Dashboard works with any AeroDB version supporting the same API major version.</p> <p>Rationale: Dashboard and database can be upgraded independently.</p> <p>Enforcement: - Dashboard version check on startup (compares API version) - Graceful degradation if API endpoint missing - Feature flags for version-specific functionality</p> <p>Test: Dashboard v1.2 + AeroDB API v1.0 \u2192 dashboard works, shows \"upgrade for feature X\"</p>"},{"location":"ADMIN_UI_INVARIANTS/#operational-invariants","title":"Operational Invariants","text":""},{"location":"ADMIN_UI_INVARIANTS/#o1-pagination-always-required","title":"O1: Pagination Always Required","text":"<p>Invariant: List endpoints must specify limit (dashboard never fetches unbounded data).</p> <p>Rationale: Prevents OOM errors, aligns with AeroDB Query Invariant (Q1).</p> <p>Enforcement: - All <code>useQuery</code> hooks include <code>limit</code> parameter (default: 20) - Server rejects queries without limit - UI shows total count but loads pages lazily</p> <p>Test: Open table with 10,000 rows \u2192 only 20 fetched \u2192 pagination works</p>"},{"location":"ADMIN_UI_INVARIANTS/#o2-stale-data-indicated","title":"O2: Stale Data Indicated","text":"<p>Invariant: If data is cached/stale, dashboard shows age or refresh button.</p> <p>Rationale: Users must know if they're viewing current state.</p> <p>Enforcement: - React Query <code>staleTime</code> set to 5 minutes - UI shows \"Updated 2 min ago\" timestamp - Red indicator if data &gt; 10 minutes old</p> <p>Test: Open page \u2192 wait 6 minutes \u2192 \"Stale data\" indicator appears</p>"},{"location":"ADMIN_UI_INVARIANTS/#o3-error-states-shown","title":"O3: Error States Shown","text":"<p>Invariant: Network/API errors are visible to the user (not silent failures).</p> <p>Rationale: Users need to know when dashboard is not reflecting reality.</p> <p>Enforcement: - React Query <code>onError</code> shows toast notification - Failed components show error boundary with retry button - Network offline \u2192 banner at top</p> <p>Test: Disconnect network \u2192 \"Cannot connect to AeroDB\" error shown</p>"},{"location":"ADMIN_UI_INVARIANTS/#o4-no-auto-refresh-by-default","title":"O4: No Auto-Refresh by Default","text":"<p>Invariant: Data does not auto-refresh unless user opts in.</p> <p>Rationale: Reduces load on database, makes UI behavior predictable.</p> <p>Enforcement: - React Query <code>refetchInterval</code> is <code>false</code> by default - Real-time subscriptions are opt-in (user clicks \"Enable Live Updates\") - Manual refresh button always available</p> <p>Test: Open dashboard \u2192 data does not change without user action</p>"},{"location":"ADMIN_UI_INVARIANTS/#security-invariants","title":"Security Invariants","text":""},{"location":"ADMIN_UI_INVARIANTS/#s1-tokens-not-logged","title":"S1: Tokens Not Logged","text":"<p>Invariant: Access/refresh tokens never appear in console logs, error messages, or analytics.</p> <p>Rationale: Prevents token leakage.</p> <p>Enforcement: - Axios interceptor strips <code>Authorization</code> header from error logs - Sentry/logging SDK configured to redact tokens - Dev tools console checks disabled in production</p> <p>Test: Trigger API error \u2192 inspect logs \u2192 no token visible</p>"},{"location":"ADMIN_UI_INVARIANTS/#s2-https-only","title":"S2: HTTPS Only","text":"<p>Invariant: Dashboard refuses to connect to non-HTTPS AeroDB endpoints (except localhost).</p> <p>Rationale: Prevents token interception.</p> <p>Enforcement: - API client checks URL scheme - Throws error if <code>http://</code> and not <code>localhost</code> - CSP headers enforce <code>upgrade-insecure-requests</code></p> <p>Test: Set <code>VITE_AERODB_URL=http://example.com</code> \u2192 dashboard shows error</p>"},{"location":"ADMIN_UI_INVARIANTS/#s3-xss-protection","title":"S3: XSS Protection","text":"<p>Invariant: User-provided content is sanitized before rendering.</p> <p>Rationale: Prevents injection attacks.</p> <p>Enforcement: - Use React's JSX (auto-escapes text) - If using <code>dangerouslySetInnerHTML</code>, sanitize with DOMPurify - CSP headers disallow inline scripts</p> <p>Test: Insert <code>&lt;script&gt;alert('xss')&lt;/script&gt;</code> in table cell \u2192 rendered as text, not executed</p>"},{"location":"ADMIN_UI_INVARIANTS/#testing-invariants","title":"Testing Invariants","text":""},{"location":"ADMIN_UI_INVARIANTS/#t1-e2e-coverage-required","title":"T1: E2E Coverage Required","text":"<p>Invariant: Every user-facing feature has at least one E2E test.</p> <p>Rationale: UI bugs are caught before deployment.</p> <p>Enforcement: - Playwright tests for each route - CI fails if coverage &lt; 80% - Critical paths (login, data fetch) have multiple tests</p> <p>Test: Run <code>npm run test:e2e</code> \u2192 all tests pass</p>"},{"location":"ADMIN_UI_INVARIANTS/#t2-api-mocking-in-dev","title":"T2: API Mocking in Dev","text":"<p>Invariant: Dashboard can run without a real AeroDB instance (using mocks).</p> <p>Rationale: Speeds up frontend development.</p> <p>Enforcement: - MSW (Mock Service Worker) provides API mocks - <code>npm run dev:mock</code> starts dashboard with mock API - Mock data matches real API schema</p> <p>Test: Run <code>npm run dev:mock</code> \u2192 dashboard functional, data shown</p>"},{"location":"ADMIN_UI_INVARIANTS/#violation-handling","title":"Violation Handling","text":"<p>If an invariant is violated:</p> <ol> <li>Alert: User sees error message (not crash)</li> <li>Log: Error sent to observability backend (Sentry)</li> <li>Degrade: Dashboard shows reduced functionality (read-only mode)</li> <li>Recover: User can retry or refresh</li> </ol>"},{"location":"ADMIN_UI_READINESS/","title":"Phase 13: Admin Dashboard - Readiness Criteria","text":""},{"location":"ADMIN_UI_READINESS/#freeze-checklist","title":"Freeze Checklist","text":"<p>Phase 13 is ready to freeze when all items below are complete:</p>"},{"location":"ADMIN_UI_READINESS/#1-core-features-implemented","title":"1. Core Features Implemented","text":"<ul> <li> Database Management</li> <li> Table browser with pagination (20 items/page)</li> <li> Column sorting (click header)</li> <li> Filter builder (field, operator, value)</li> <li> SQL console with Monaco Editor</li> <li> Query execution (with timeout)</li> <li> Explain plan viewer</li> <li> Schema visualizer (tables + relations)</li> <li> <p> Schema editor (generates migration SQL)</p> </li> <li> <p> Authentication &amp; Authorization</p> </li> <li> User list (name, email, created_at, last_login)</li> <li> Add/edit/delete users</li> <li> Active sessions table</li> <li> Revoke session action</li> <li> <p> RLS policy viewer (read-only)</p> </li> <li> <p> File Storage</p> </li> <li> Bucket list</li> <li> File browser with breadcrumbs</li> <li> Upload (drag-and-drop or browse)</li> <li> Download file</li> <li> Delete file (with confirmation)</li> <li> <p> Storage metrics (used/total per bucket)</p> </li> <li> <p> Real-Time Monitoring</p> </li> <li> Active subscriptions table (user, channel, filter)</li> <li> Event log (last 100 events)</li> <li> Enable live updates toggle</li> <li> <p> Connection list (WebSocket connections)</p> </li> <li> <p> Cluster Management</p> </li> <li> Topology view (authority + replicas)</li> <li> Replication lag chart</li> <li> Promote replica button (with confirmation)</li> <li> <p> WAL viewer (read-only)</p> </li> <li> <p> Observability</p> </li> <li> Structured log viewer (filter by level, time, module)</li> <li> Metrics dashboard (queries/sec, latency, errors)</li> <li> Audit log (user actions)</li> </ul>"},{"location":"ADMIN_UI_READINESS/#2-testing-complete","title":"2. Testing Complete","text":"<ul> <li> Unit Tests</li> <li> 80%+ line coverage</li> <li> All React components tested</li> <li> All custom hooks tested</li> <li> <p> All utilities tested</p> </li> <li> <p> Integration Tests</p> </li> <li> Login flow</li> <li> CRUD operations on each resource</li> <li> <p> API error handling</p> </li> <li> <p> E2E Tests (Playwright)</p> </li> <li> Critical path: Login \u2192 browse table \u2192 logout</li> <li> Table filtering and pagination</li> <li> User management workflow</li> <li> File upload/download</li> <li> <p> Real-time subscription</p> </li> <li> <p> Visual Regression</p> </li> <li> Screenshots for all major pages</li> <li> <p> Dark/light theme variants</p> </li> <li> <p> Performance</p> </li> <li> Lighthouse score &gt; 90</li> <li> Page load &lt; 1s</li> <li> Query results &lt; 500ms (p95)</li> </ul>"},{"location":"ADMIN_UI_READINESS/#3-security-verified","title":"3. Security Verified","text":"<ul> <li> Authentication</li> <li> JWT validation on all endpoints</li> <li> Token refresh flow</li> <li> Auto-logout on token expiry</li> <li> <p> Session hijacking protection (rotate tokens)</p> </li> <li> <p> XSS Protection</p> </li> <li> All user input sanitized</li> <li> CSP headers configured</li> <li> <p> No <code>dangerouslySetInnerHTML</code> without DOMPurify</p> </li> <li> <p> CSRF Protection</p> </li> <li> Destructive actions require confirmation</li> <li> <p> No state mutations via GET requests</p> </li> <li> <p> HTTPS Only</p> </li> <li> Dashboard rejects HTTP endpoints (except localhost)</li> <li> Tokens never logged</li> </ul>"},{"location":"ADMIN_UI_READINESS/#4-invariants-enforced","title":"4. Invariants Enforced","text":"<p>All invariants from ADMIN_UI_INVARIANTS.md verified:</p> <ul> <li> I1: Dashboard failures don't break database</li> <li> I2: Database is source of truth</li> <li> I3: No hidden mutations</li> <li> I4: RLS respected</li> <li> I5: API version compatibility</li> <li> O1: Pagination always required</li> <li> O2: Stale data indicated</li> <li> O3: Error states shown</li> <li> O4: No auto-refresh by default</li> <li> S1: Tokens not logged</li> <li> S2: HTTPS only</li> <li> S3: XSS protection</li> <li> T1: E2E coverage required</li> <li> T2: API mocking in dev</li> </ul>"},{"location":"ADMIN_UI_READINESS/#5-documentation-complete","title":"5. Documentation Complete","text":"<ul> <li> ADMIN_UI_VISION.md</li> <li> ADMIN_UI_ARCHITECTURE.md</li> <li> ADMIN_UI_UI_MODEL.md</li> <li> ADMIN_UI_INVARIANTS.md</li> <li> ADMIN_UI_TESTING_STRATEGY.md</li> <li> ADMIN_UI_READINESS.md (this file)</li> <li> ADMIN_UI_DEPLOYMENT.md</li> <li> ADMIN_UI_OBSERVABILITY.md</li> <li> README.md in dashboard/</li> </ul>"},{"location":"ADMIN_UI_READINESS/#6-deployment-ready","title":"6. Deployment Ready","text":"<ul> <li> Build</li> <li> <code>npm run build</code> succeeds</li> <li> Bundle size &lt; 500KB (gzipped)</li> <li> No unused dependencies</li> <li> <p> Tree shaking enabled</p> </li> <li> <p> Environment Config</p> </li> <li> <code>.env.example</code> provided</li> <li> Required vars documented: VITE_AERODB_URL, VITE_WS_URL</li> <li> <p> Config validation on startup</p> </li> <li> <p> Static Hosting</p> </li> <li> Deployable to Vercel/Netlify</li> <li> <code>dist/</code> contains all necessary files</li> <li> <p> <code>_redirects</code> handles SPA routing</p> </li> <li> <p> Docker</p> </li> <li> Dockerfile provided (nginx serving <code>dist/</code>)</li> <li> Multi-stage build (reduce image size)</li> </ul>"},{"location":"ADMIN_UI_READINESS/#7-accessibility","title":"7. Accessibility","text":"<ul> <li> WCAG 2.1 AA</li> <li> Keyboard navigation works</li> <li> Screen reader compatible</li> <li> Focus indicators visible</li> <li> Color contrast \u2265 4.5:1 (text)</li> <li> <p> ARIA labels on interactive elements</p> </li> <li> <p> Responsive Design</p> </li> <li> Mobile (&lt; 768px): Sidebar collapses</li> <li> Tablet (768-1024px): Single column layouts</li> <li> Desktop (&gt; 1024px): Multi-column layouts</li> </ul>"},{"location":"ADMIN_UI_READINESS/#8-observability","title":"8. Observability","text":"<ul> <li> Error Tracking</li> <li> Sentry integrated (or equivalent)</li> <li> Errors include user ID, route, stack trace</li> <li> <p> PII (passwords, tokens) redacted</p> </li> <li> <p> Analytics</p> </li> <li> Page views tracked</li> <li> User actions logged (button clicks, queries executed)</li> <li> <p> Performance metrics (LCP, FID, CLS)</p> </li> <li> <p> Logging</p> </li> <li> Console logs suppressed in production</li> <li> Structured logs sent to backend</li> </ul>"},{"location":"ADMIN_UI_READINESS/#9-user-documentation","title":"9. User Documentation","text":"<ul> <li> Admin Guide</li> <li> Getting started (login, navigation)</li> <li> Table browser usage</li> <li> SQL console tips</li> <li> User management</li> <li> <p> File upload/download</p> </li> <li> <p> Developer Guide</p> </li> <li> Setup instructions (<code>npm install</code>, <code>npm run dev</code>)</li> <li> Environment variables</li> <li> Extending the dashboard (add new page)</li> </ul>"},{"location":"ADMIN_UI_READINESS/#10-known-limitations-documented","title":"10. Known Limitations Documented","text":"<ul> <li> Limitations</li> <li> Dashboard is read-heavy (writes go through API)</li> <li> No offline mode (requires network)</li> <li> RLS policies not editable via UI (use SQL)</li> <li> Large result sets require pagination</li> </ul>"},{"location":"ADMIN_UI_READINESS/#sign-off","title":"Sign-Off","text":"<p>Phase 13 is frozen when:</p> <ol> <li>All checklist items above are complete</li> <li>All tests pass (unit, integration, E2E)</li> <li>Code review approved by at least one other developer</li> <li>Security audit complete (no critical vulnerabilities)</li> </ol> <p>Frozen on: [DATE]</p> <p>Approved by: [NAME]</p>"},{"location":"ADMIN_UI_TESTING_STRATEGY/","title":"Phase 13: Admin Dashboard - Testing Strategy","text":""},{"location":"ADMIN_UI_TESTING_STRATEGY/#test-pyramid","title":"Test Pyramid","text":"<pre><code>        E2E Tests (20%)\n       /            \\\n      /  Integration  \\\n     /    Tests (30%)  \\\n    /                   \\\n   /_____________________\\\n      Unit Tests (50%)\n</code></pre>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#unit-tests-vitest","title":"Unit Tests (Vitest)","text":""},{"location":"ADMIN_UI_TESTING_STRATEGY/#what-to-test","title":"What to Test","text":"<ul> <li>React Components: Rendering, props, user interactions</li> <li>Hooks: Custom hooks (API calls, state management)</li> <li>Utilities: Helper functions, formatters, validators</li> </ul>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#example-component-test","title":"Example: Component Test","text":"<pre><code>// features/database/components/TableBrowser.test.tsx\nimport { render, screen, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { TableBrowser } from './TableBrowser';\n\ndescribe('TableBrowser', () =&gt; {\n  it('renders table data', async () =&gt; {\n    const queryClient = new QueryClient();\n\n    render(\n      &lt;QueryClientProvider client={queryClient}&gt;\n        &lt;TableBrowser collection=\"users\" /&gt;\n      &lt;/QueryClientProvider&gt;\n    );\n\n    await waitFor(() =&gt; {\n      expect(screen.getByText('users')).toBeInTheDocument();\n    });\n  });\n\n  it('handles empty state', () =&gt; {\n    render(&lt;TableBrowser collection=\"empty_table\" /&gt;);\n    expect(screen.getByText('No data')).toBeInTheDocument();\n  });\n});\n</code></pre>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#example-hook-test","title":"Example: Hook Test","text":"<pre><code>// features/database/hooks/useTableData.test.ts\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { useTableData } from './useTableData';\n\ndescribe('useTableData', () =&gt; {\n  it('fetches table data', async () =&gt; {\n    const queryClient = new QueryClient();\n    const wrapper = ({ children }) =&gt; (\n      &lt;QueryClientProvider client={queryClient}&gt;{children}&lt;/QueryClientProvider&gt;\n    );\n\n    const { result } = renderHook(() =&gt; useTableData('users', { limit: 10, offset: 0 }), { wrapper });\n\n    await waitFor(() =&gt; {\n      expect(result.current.data).toBeDefined();\n    });\n  });\n});\n</code></pre>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#integration-tests-react-testing-library","title":"Integration Tests (React Testing Library)","text":""},{"location":"ADMIN_UI_TESTING_STRATEGY/#what-to-test_1","title":"What to Test","text":"<ul> <li>Feature flows: Multi-step user journeys</li> <li>API integration: Components + API client</li> <li>State management: React Query + Zustand integration</li> </ul>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#example-login-flow","title":"Example: Login Flow","text":"<pre><code>// features/auth/LoginPage.test.tsx\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { setupServer } from 'msw/node';\nimport { rest } from 'msw';\nimport { LoginPage } from './LoginPage';\n\nconst server = setupServer(\n  rest.post('/auth/login', (req, res, ctx) =&gt; {\n    return res(ctx.json({ access_token: 'fake-token' }));\n  })\n);\n\nbeforeAll(() =&gt; server.listen());\nafterEach(() =&gt; server.resetHandlers());\nafterAll(() =&gt; server.close());\n\ndescribe('LoginPage', () =&gt; {\n  it('logs in successfully', async () =&gt; {\n    render(&lt;LoginPage /&gt;);\n\n    fireEvent.change(screen.getByLabelText('Email'), {\n      target: { value: 'test@example.com' },\n    });\n    fireEvent.change(screen.getByLabelText('Password'), {\n      target: { value: 'password123' },\n    });\n    fireEvent.click(screen.getByText('Login'));\n\n    await waitFor(() =&gt; {\n      expect(localStorage.getItem('access_token')).toBe('fake-token');\n    });\n  });\n});\n</code></pre>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#e2e-tests-playwright","title":"E2E Tests (Playwright)","text":""},{"location":"ADMIN_UI_TESTING_STRATEGY/#what-to-test_2","title":"What to Test","text":"<ul> <li>Critical paths: Login \u2192 browse data \u2192 logout</li> <li>Cross-page flows: Create user \u2192 assign role \u2192 verify permissions</li> <li>Visual regression: Screenshots of key pages</li> </ul>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#example-table-browsing-flow","title":"Example: Table Browsing Flow","text":"<pre><code>// tests/e2e/table-browsing.spec.ts\nimport { test, expect } from '@playwright/test';\n\ntest('browse table data', async ({ page }) =&gt; {\n  // Login\n  await page.goto('http://localhost:5173/login');\n  await page.fill('input[name=\"email\"]', 'admin@example.com');\n  await page.fill('input[name=\"password\"]', 'admin123');\n  await page.click('button[type=\"submit\"]');\n\n  // Navigate to database section\n  await page.click('text=Database');\n  await page.waitForURL('**/database/tables');\n\n  // Select a table\n  await page.click('text=users');\n\n  // Verify table data loaded\n  await expect(page.locator('table')).toBeVisible();\n  await expect(page.locator('tbody tr')).toHaveCount(20); // First page\n\n  // Test pagination\n  await page.click('text=Next');\n  await expect(page.locator('tbody tr')).toHaveCount(20); // Second page\n\n  // Test filtering\n  await page.fill('input[placeholder=\"Search\"]', 'john');\n  await page.click('text=Apply Filter');\n  await expect(page.locator('tbody tr')).toHaveCount.toBeLessThan(20);\n\n  // Screenshot for visual regression\n  await page.screenshot({ path: 'screenshots/table-browser.png' });\n});\n</code></pre>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#example-real-time-subscription","title":"Example: Real-Time Subscription","text":"<pre><code>// tests/e2e/realtime.spec.ts\nimport { test, expect } from '@playwright/test';\n\ntest('subscribe to real-time events', async ({ page }) =&gt; {\n  await page.goto('http://localhost:5173/realtime/events');\n\n  // Enable live updates\n  await page.click('text=Enable Live Updates');\n\n  // Verify WebSocket connection\n  await expect(page.locator('text=Connected')).toBeVisible();\n\n  // In another tab, insert data (simulate)\n  await page.evaluate(() =&gt; {\n    fetch('http://localhost:54321/rest/v1/posts', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json', Authorization: 'Bearer token' },\n      body: JSON.stringify({ title: 'New Post' }),\n    });\n  });\n\n  // Verify event received\n  await expect(page.locator('text=INSERT: posts')).toBeVisible({ timeout: 5000 });\n});\n</code></pre>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#visual-regression-testing","title":"Visual Regression Testing","text":"<p>Use Playwright's screenshot comparison:</p> <pre><code>// tests/e2e/visual.spec.ts\nimport { test, expect } from '@playwright/test';\n\ntest('homepage visual regression', async ({ page }) =&gt; {\n  await page.goto('http://localhost:5173');\n  await expect(page).toHaveScreenshot('homepage.png', {\n    maxDiffPixels: 100,\n  });\n});\n</code></pre>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#api-mocking-msw","title":"API Mocking (MSW)","text":"<p>Use Mock Service Worker for deterministic tests:</p> <pre><code>// src/mocks/handlers.ts\nimport { rest } from 'msw';\n\nexport const handlers = [\n  rest.get('/rest/v1/users', (req, res, ctx) =&gt; {\n    return res(\n      ctx.json({\n        data: [\n          { id: 1, name: 'Alice', email: 'alice@example.com' },\n          { id: 2, name: 'Bob', email: 'bob@example.com' },\n        ],\n        count: 2,\n        limit: 20,\n        offset: 0,\n      })\n    );\n  }),\n\n  rest.post('/auth/login', (req, res, ctx) =&gt; {\n    const { email, password } = req.body as any;\n    if (email === 'admin@example.com' &amp;&amp; password === 'admin123') {\n      return res(ctx.json({ access_token: 'mock-token' }));\n    }\n    return res(ctx.status(401), ctx.json({ error: 'Invalid credentials' }));\n  }),\n];\n\n// src/mocks/browser.ts\nimport { setupWorker } from 'msw';\nimport { handlers } from './handlers';\n\nexport const worker = setupWorker(...handlers);\n\n// Start in dev mode\nif (import.meta.env.DEV) {\n  worker.start();\n}\n</code></pre>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#coverage-targets","title":"Coverage Targets","text":"<ul> <li>Unit tests: 80% line coverage</li> <li>Integration tests: 70% feature coverage</li> <li>E2E tests: 100% critical path coverage</li> </ul> <p>Run coverage: <pre><code>npm run test:coverage\nnpm run test:e2e:coverage\n</code></pre></p>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#cicd-pipeline","title":"CI/CD Pipeline","text":""},{"location":"ADMIN_UI_TESTING_STRATEGY/#github-actions","title":"GitHub Actions","text":"<pre><code># .github/workflows/test.yml\nname: Test\non: [push, pull_request]\n\njobs:\n  unit:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n      - run: npm ci\n      - run: npm run test:unit\n      - run: npm run test:coverage\n\n  e2e:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n      - run: npm ci\n      - run: npx playwright install\n      - run: npm run test:e2e\n      - uses: actions/upload-artifact@v3\n        if: failure()\n        with:\n          name: screenshots\n          path: tests/e2e/screenshots/\n</code></pre>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#performance-testing","title":"Performance Testing","text":""},{"location":"ADMIN_UI_TESTING_STRATEGY/#lighthouse-ci","title":"Lighthouse CI","text":"<pre><code># .github/workflows/lighthouse.yml\nname: Lighthouse\non: [push]\n\njobs:\n  lighthouse:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: treosh/lighthouse-ci-action@v9\n        with:\n          urls: |\n            http://localhost:5173\n            http://localhost:5173/database\n          uploadArtifacts: true\n          temporaryPublicStorage: true\n</code></pre> <p>Targets: - Performance score: &gt; 90 - Accessibility score: 100 - Best Practices score: &gt; 95</p>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#test-data-management","title":"Test Data Management","text":""},{"location":"ADMIN_UI_TESTING_STRATEGY/#fixtures","title":"Fixtures","text":"<pre><code>// tests/fixtures/users.ts\nexport const mockUsers = [\n  { id: '1', name: 'Alice', email: 'alice@example.com', role: 'admin' },\n  { id: '2', name: 'Bob', email: 'bob@example.com', role: 'user' },\n];\n\n// tests/fixtures/tables.ts\nexport const mockTables = [\n  { name: 'users', count: 100 },\n  { name: 'posts', count: 500 },\n];\n</code></pre>"},{"location":"ADMIN_UI_TESTING_STRATEGY/#testing-best-practices","title":"Testing Best Practices","text":"<ol> <li>Arrange-Act-Assert: Structure tests clearly</li> <li>Test behavior, not implementation: Avoid testing internal state</li> <li>Use data-testid sparingly: Prefer accessible queries (getByRole, getByLabelText)</li> <li>Avoid flaky tests: Use <code>waitFor</code>, avoid hardcoded timeouts</li> <li>Keep tests fast: Mock external dependencies</li> </ol>"},{"location":"ADMIN_UI_UI_MODEL/","title":"Phase 13: Admin Dashboard - UI Components Model","text":""},{"location":"ADMIN_UI_UI_MODEL/#design-system","title":"Design System","text":""},{"location":"ADMIN_UI_UI_MODEL/#shadcnui-foundation","title":"shadcn/ui Foundation","text":"<p>Use shadcn/ui as the component library foundation: - Radix UI primitives (accessible, unstyled) - Tailwind CSS for styling - Components copied into project (not npm dependency) - Full customization control</p>"},{"location":"ADMIN_UI_UI_MODEL/#theme","title":"Theme","text":"<p>Dark mode by default with light mode toggle:</p> <pre><code>// Tailwind config\nmodule.exports = {\n  darkMode: 'class',\n  theme: {\n    extend: {\n      colors: {\n        // Dark mode colors\n        background: 'hsl(222.2 84% 4.9%)',\n        foreground: 'hsl(210 40% 98%)',\n        card: 'hsl(222.2 84% 4.9%)',\n        'card-foreground': 'hsl(210 40% 98%)',\n        primary: 'hsl(210 40% 98%)',\n        secondary: 'hsl(217.2 32.6% 17.5%)',\n        // ... etc\n      },\n    },\n  },\n};\n</code></pre>"},{"location":"ADMIN_UI_UI_MODEL/#core-components","title":"Core Components","text":""},{"location":"ADMIN_UI_UI_MODEL/#1-datatable","title":"1. DataTable","text":"<p>Reusable table with sorting, filtering, pagination:</p> <pre><code>// components/common/DataTable.tsx\ninterface Column&lt;T&gt; {\n  key: keyof T;\n  header: string;\n  cell?: (value: T[keyof T], row: T) =&gt; React.ReactNode;\n  sortable?: boolean;\n}\n\ninterface DataTableProps&lt;T&gt; {\n  data: T[];\n  columns: Column&lt;T&gt;[];\n  loading?: boolean;\n  onRowClick?: (row: T) =&gt; void;\n  pagination?: {\n    total: number;\n    page: number;\n    pageSize: number;\n    onPageChange: (page: number) =&gt; void;\n  };\n}\n\nexport function DataTable&lt;T&gt;({ data, columns, loading, pagination }: DataTableProps&lt;T&gt;) {\n  const [sortKey, setSortKey] = useState&lt;keyof T | null&gt;(null);\n  const [sortDir, setSortDir] = useState&lt;'asc' | 'desc'&gt;('asc');\n\n  const sortedData = useMemo(() =&gt; {\n    if (!sortKey) return data;\n    return [...data].sort((a, b) =&gt; {\n      const aVal = a[sortKey];\n      const bVal = b[sortKey];\n      return sortDir === 'asc' \n        ? String(aVal).localeCompare(String(bVal))\n        : String(bVal).localeCompare(String(aVal));\n    });\n  }, [data, sortKey, sortDir]);\n\n  return (\n    &lt;Table&gt;\n      &lt;TableHeader&gt;\n        &lt;TableRow&gt;\n          {columns.map((col) =&gt; (\n            &lt;TableHead key={String(col.key)}&gt;\n              {col.sortable ? (\n                &lt;button onClick={() =&gt; {\n                  setSortKey(col.key);\n                  setSortDir(sortDir === 'asc' ? 'desc' : 'asc');\n                }}&gt;\n                  {col.header} {sortKey === col.key &amp;&amp; (sortDir === 'asc' ? '\u2191' : '\u2193')}\n                &lt;/button&gt;\n              ) : (\n                col.header\n              )}\n            &lt;/TableHead&gt;\n          ))}\n        &lt;/TableRow&gt;\n      &lt;/TableHeader&gt;\n      &lt;TableBody&gt;\n        {loading ? (\n          &lt;TableRow&gt;\n            &lt;TableCell colSpan={columns.length}&gt;Loading...&lt;/TableCell&gt;\n          &lt;/TableRow&gt;\n        ) : (\n          sortedData.map((row, i) =&gt; (\n            &lt;TableRow key={i}&gt;\n              {columns.map((col) =&gt; (\n                &lt;TableCell key={String(col.key)}&gt;\n                  {col.cell ? col.cell(row[col.key], row) : String(row[col.key])}\n                &lt;/TableCell&gt;\n              ))}\n            &lt;/TableRow&gt;\n          ))\n        )}\n      &lt;/TableBody&gt;\n    &lt;/Table&gt;\n  );\n}\n</code></pre>"},{"location":"ADMIN_UI_UI_MODEL/#2-filterbuilder","title":"2. FilterBuilder","text":"<p>Visual filter creator:</p> <pre><code>// components/common/FilterBuilder.tsx\ninterface Filter {\n  field: string;\n  operator: 'eq' | 'gt' | 'lt' | 'like' | 'in';\n  value: string | number;\n}\n\nexport function FilterBuilder({ onChange }: { onChange: (filters: Filter[]) =&gt; void }) {\n  const [filters, setFilters] = useState&lt;Filter[]&gt;([]);\n\n  const addFilter = () =&gt; {\n    setFilters([...filters, { field: '', operator: 'eq', value: '' }]);\n  };\n\n  const updateFilter = (index: number, updates: Partial&lt;Filter&gt;) =&gt; {\n    const updated = [...filters];\n    updated[index] = { ...updated[index], ...updates };\n    setFilters(updated);\n    onChange(updated);\n  };\n\n  return (\n    &lt;div className=\"space-y-2\"&gt;\n      {filters.map((filter, i) =&gt; (\n        &lt;div key={i} className=\"flex gap-2\"&gt;\n          &lt;Input\n            placeholder=\"Field\"\n            value={filter.field}\n            onChange={(e) =&gt; updateFilter(i, { field: e.target.value })}\n          /&gt;\n          &lt;Select\n            value={filter.operator}\n            onValueChange={(op) =&gt; updateFilter(i, { operator: op as Filter['operator'] })}\n          &gt;\n            &lt;SelectTrigger&gt;&lt;SelectValue /&gt;&lt;/SelectTrigger&gt;\n            &lt;SelectContent&gt;\n              &lt;SelectItem value=\"eq\"&gt;=&lt;/SelectItem&gt;\n              &lt;SelectItem value=\"gt\"&gt;&amp;gt;&lt;/SelectItem&gt;\n              &lt;SelectItem value=\"lt\"&gt;&amp;lt;&lt;/SelectItem&gt;\n              &lt;SelectItem value=\"like\"&gt;LIKE&lt;/SelectItem&gt;\n            &lt;/SelectContent&gt;\n          &lt;/Select&gt;\n          &lt;Input\n            placeholder=\"Value\"\n            value={filter.value}\n            onChange={(e) =&gt; updateFilter(i, { value: e.target.value })}\n          /&gt;\n          &lt;Button variant=\"ghost\" size=\"icon\" onClick={() =&gt; {\n            const updated = filters.filter((_, idx) =&gt; idx !== i);\n            setFilters(updated);\n            onChange(updated);\n          }}&gt;\n            &lt;X className=\"h-4 w-4\" /&gt;\n          &lt;/Button&gt;\n        &lt;/div&gt;\n      ))}\n      &lt;Button onClick={addFilter} variant=\"outline\"&gt;\n        &lt;Plus className=\"h-4 w-4 mr-2\" /&gt; Add Filter\n      &lt;/Button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"ADMIN_UI_UI_MODEL/#3-schemavisualizer","title":"3. SchemaVisualizer","text":"<p>Interactive schema diagram:</p> <pre><code>// features/database/components/SchemaVisualizer.tsx\nimport { useState } from 'react';\nimport { Handle, Position, ReactFlow } from 'reactflow';\n\ninterface Table {\n  name: string;\n  fields: { name: string; type: string; nullable: boolean }[];\n  relations: { field: string; references: string }[];\n}\n\nexport function SchemaVisualizer({ schema }: { schema: Table[] }) {\n  const nodes = schema.map((table, i) =&gt; ({\n    id: table.name,\n    type: 'tableNode',\n    data: { table },\n    position: { x: i * 300, y: 100 },\n  }));\n\n  const edges = schema.flatMap((table) =&gt;\n    table.relations.map((rel) =&gt; ({\n      id: `${table.name}-${rel.field}`,\n      source: table.name,\n      target: rel.references,\n      label: rel.field,\n    }))\n  );\n\n  return (\n    &lt;div className=\"h-full w-full\"&gt;\n      &lt;ReactFlow nodes={nodes} edges={edges} nodeTypes={{ tableNode: TableNode }} /&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction TableNode({ data }: { data: { table: Table } }) {\n  const { table } = data;\n  return (\n    &lt;div className=\"bg-card border rounded-lg p-4 min-w-[200px]\"&gt;\n      &lt;div className=\"font-bold mb-2\"&gt;{table.name}&lt;/div&gt;\n      {table.fields.map((field) =&gt; (\n        &lt;div key={field.name} className=\"text-sm\"&gt;\n          {field.name}: {field.type}\n          {field.nullable &amp;&amp; ' (nullable)'}\n        &lt;/div&gt;\n      ))}\n      &lt;Handle type=\"source\" position={Position.Right} /&gt;\n      &lt;Handle type=\"target\" position={Position.Left} /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"ADMIN_UI_UI_MODEL/#4-metricschart","title":"4. MetricsChart","text":"<p>Time-series visualization:</p> <pre><code>// features/observability/components/MetricsChart.tsx\nimport { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip } from 'recharts';\n\ninterface DataPoint {\n  timestamp: string;\n  value: number;\n}\n\nexport function MetricsChart({ data, title }: { data: DataPoint[]; title: string }) {\n  return (\n    &lt;Card&gt;\n      &lt;CardHeader&gt;\n        &lt;CardTitle&gt;{title}&lt;/CardTitle&gt;\n      &lt;/CardHeader&gt;\n      &lt;CardContent&gt;\n        &lt;LineChart width={600} height={300} data={data}&gt;\n          &lt;CartesianGrid strokeDasharray=\"3 3\" /&gt;\n          &lt;XAxis dataKey=\"timestamp\" /&gt;\n          &lt;YAxis /&gt;\n          &lt;Tooltip /&gt;\n          &lt;Line type=\"monotone\" dataKey=\"value\" stroke=\"hsl(210 40% 98%)\" /&gt;\n        &lt;/LineChart&gt;\n      &lt;/CardContent&gt;\n    &lt;/Card&gt;\n  );\n}\n</code></pre>"},{"location":"ADMIN_UI_UI_MODEL/#5-confirmdialog","title":"5. ConfirmDialog","text":"<p>Confirmation for destructive actions:</p> <pre><code>// components/common/ConfirmDialog.tsx\nexport function ConfirmDialog({\n  open,\n  onOpenChange,\n  title,\n  description,\n  action,\n  onConfirm,\n}: {\n  open: boolean;\n  onOpenChange: (open: boolean) =&gt; void;\n  title: string;\n  description: string;\n  action: string;\n  onConfirm: () =&gt; void;\n}) {\n  return (\n    &lt;AlertDialog open={open} onOpenChange={onOpenChange}&gt;\n      &lt;AlertDialogContent&gt;\n        &lt;AlertDialogHeader&gt;\n          &lt;AlertDialogTitle&gt;{title}&lt;/AlertDialogTitle&gt;\n          &lt;AlertDialogDescription&gt;{description}&lt;/AlertDialogDescription&gt;\n        &lt;/AlertDialogHeader&gt;\n        &lt;AlertDialogFooter&gt;\n          &lt;AlertDialogCancel&gt;Cancel&lt;/AlertDialogCancel&gt;\n          &lt;AlertDialogAction onClick={onConfirm}&gt;{action}&lt;/AlertDialogAction&gt;\n        &lt;/AlertDialogFooter&gt;\n      &lt;/AlertDialogContent&gt;\n    &lt;/AlertDialog&gt;\n  );\n}\n\n// Usage\nfunction DeleteUserButton({ userId }: { userId: string }) {\n  const [open, setOpen] = useState(false);\n  const deleteMutation = useMutation({ /* ... */ });\n\n  return (\n    &lt;&gt;\n      &lt;Button variant=\"destructive\" onClick={() =&gt; setOpen(true)}&gt;Delete&lt;/Button&gt;\n      &lt;ConfirmDialog\n        open={open}\n        onOpenChange={setOpen}\n        title=\"Delete User\"\n        description=\"This action cannot be undone. The user will lose all data.\"\n        action=\"Delete\"\n        onConfirm={() =&gt; {\n          deleteMutation.mutate(userId);\n          setOpen(false);\n        }}\n      /&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"ADMIN_UI_UI_MODEL/#layout-components","title":"Layout Components","text":""},{"location":"ADMIN_UI_UI_MODEL/#applayout","title":"AppLayout","text":"<pre><code>// components/layout/AppLayout.tsx\nexport function AppLayout({ children }: { children: React.ReactNode }) {\n  const { sidebarOpen } = useUIStore();\n\n  return (\n    &lt;div className=\"flex h-screen\"&gt;\n      &lt;Sidebar open={sidebarOpen} /&gt;\n      &lt;div className=\"flex-1 flex flex-col\"&gt;\n        &lt;Header /&gt;\n        &lt;main className=\"flex-1 overflow-auto p-6\"&gt;\n          {children}\n        &lt;/main&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"ADMIN_UI_UI_MODEL/#sidebar","title":"Sidebar","text":"<pre><code>// components/layout/Sidebar.tsx\nexport function Sidebar({ open }: { open: boolean }) {\n  return (\n    &lt;aside className={cn('bg-card border-r transition-all', open ? 'w-64' : 'w-16')}&gt;\n      &lt;nav className=\"p-4 space-y-2\"&gt;\n        &lt;NavLink to=\"/database\" icon={Database}&gt;Database&lt;/NavLink&gt;\n        &lt;NavLink to=\"/auth\" icon={Users}&gt;Auth&lt;/NavLink&gt;\n        &lt;NavLink to=\"/storage\" icon={HardDrive}&gt;Storage&lt;/NavLink&gt;\n        &lt;NavLink to=\"/realtime\" icon={Activity}&gt;Real-Time&lt;/NavLink&gt;\n        &lt;NavLink to=\"/cluster\" icon={Server}&gt;Cluster&lt;/NavLink&gt;\n        &lt;NavLink to=\"/logs\" icon={FileText}&gt;Logs&lt;/NavLink&gt;\n        &lt;NavLink to=\"/metrics\" icon={BarChart}&gt;Metrics&lt;/NavLink&gt;\n      &lt;/nav&gt;\n    &lt;/aside&gt;\n  );\n}\n\nfunction NavLink({ to, icon: Icon, children }: { to: string; icon: any; children: React.ReactNode }) {\n  return (\n    &lt;Link to={to} className=\"flex items-center gap-2 p-2 rounded hover:bg-secondary\"&gt;\n      &lt;Icon className=\"h-5 w-5\" /&gt;\n      &lt;span&gt;{children}&lt;/span&gt;\n    &lt;/Link&gt;\n  );\n}\n</code></pre>"},{"location":"ADMIN_UI_UI_MODEL/#component-composition-patterns","title":"Component Composition Patterns","text":""},{"location":"ADMIN_UI_UI_MODEL/#list-detail-pattern","title":"List-Detail Pattern","text":"<pre><code>// features/database/pages/TablePage.tsx\nexport function TablePage() {\n  const { tables } = useTables();\n  const [selected, setSelected] = useState&lt;string | null&gt;(null);\n\n  return (\n    &lt;div className=\"grid grid-cols-[300px_1fr] gap-4 h-full\"&gt;\n      {/* List */}\n      &lt;div className=\"border rounded-lg p-4 overflow-auto\"&gt;\n        {tables.map((table) =&gt; (\n          &lt;button\n            key={table.name}\n            onClick={() =&gt; setSelected(table.name)}\n            className={cn('w-full text-left p-2 rounded', selected === table.name &amp;&amp; 'bg-secondary')}\n          &gt;\n            {table.name}\n          &lt;/button&gt;\n        ))}\n      &lt;/div&gt;\n\n      {/* Detail */}\n      &lt;div className=\"border rounded-lg p-4\"&gt;\n        {selected ? &lt;TableBrowser collection={selected} /&gt; : &lt;EmptyState /&gt;}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"ADMIN_UI_UI_MODEL/#accessibility","title":"Accessibility","text":"<p>All components meet WCAG 2.1 AA standards: - Keyboard navigation (Tab, Enter, Escape) - Screen reader support (ARIA labels) - Focus indicators - Color contrast ratio \u2265 4.5:1</p>"},{"location":"ADMIN_UI_UI_MODEL/#responsive-design","title":"Responsive Design","text":"<p>Mobile-first approach: - Sidebar collapses on mobile (&lt; 768px) - Tables scroll horizontally - Charts resize to container width - Touch-friendly tap targets (min 44x44px)</p>"},{"location":"ADMIN_UI_UI_MODEL/#performance","title":"Performance","text":"<ul> <li>Code splitting: Lazy-load routes</li> <li>Virtualization: Large tables use <code>react-window</code></li> <li>Memoization: Use <code>React.memo</code>, <code>useMemo</code>, <code>useCallback</code></li> <li>Image optimization: WebP format, lazy loading</li> </ul>"},{"location":"ADMIN_UI_VISION/","title":"Phase 13: Admin Dashboard - Vision","text":""},{"location":"ADMIN_UI_VISION/#purpose","title":"Purpose","text":"<p>The AeroDB Admin Dashboard provides observability without semantic authority. It is a read-heavy interface for monitoring, managing, and understanding the state of an AeroDB instance, while preserving the core principle that the database (not the UI) is the source of truth.</p>"},{"location":"ADMIN_UI_VISION/#philosophy","title":"Philosophy","text":""},{"location":"ADMIN_UI_VISION/#observability-not-control","title":"Observability, Not Control","text":"<p>The dashboard is explicitly non-authoritative: - Dashboard does not mutate core state - Database modifications happen via REST API or direct CLI - Dashboard reflects reality - It reads current state but doesn't define what that state should be - Dashboard can lag - Eventual consistency is acceptable; real-time accuracy is not required - Dashboard can be wrong - If UI and DB disagree, DB wins</p>"},{"location":"ADMIN_UI_VISION/#user-personas","title":"User Personas","text":"<ol> <li>Database Administrators: Monitor health, view schemas, inspect replication lag</li> <li>Developers: Browse data, test queries, view logs, debug issues</li> <li>Platform Operators: Manage users, view metrics, configure policies</li> </ol>"},{"location":"ADMIN_UI_VISION/#core-tenets","title":"Core Tenets","text":""},{"location":"ADMIN_UI_VISION/#1-read-heavy-write-light","title":"1. Read-Heavy, Write-Light","text":"<p>The dashboard primarily reads state: - View collections and schemas - Browse data with pagination - Inspect active sessions - Monitor file storage usage - View real-time subscriptions</p> <p>Writes are limited to non-critical operations: - Schema editor (generates migration SQL) - User management (calls auth API) - Policy configuration (updates via REST API)</p>"},{"location":"ADMIN_UI_VISION/#2-no-hidden-mutations","title":"2. No Hidden Mutations","text":"<p>Any write operation must: - Be explicitly initiated by the user (button click) - Show confirmation dialog for destructive actions - Display the underlying API call being made - Provide rollback instructions where applicable</p>"},{"location":"ADMIN_UI_VISION/#3-fail-open-for-ui","title":"3. Fail-Open for UI","text":"<p>Dashboard failures never block database operations: - If dashboard crashes, database continues running - If dashboard shows stale data, queries still execute correctly - If dashboard denies access, API still accepts valid tokens</p>"},{"location":"ADMIN_UI_VISION/#4-technology-agnosticism","title":"4. Technology Agnosticism","text":"<p>The dashboard communicates via public APIs only: - REST API for data operations - Control Plane API for cluster state - Auth API for user management - WebSocket API for real-time updates</p> <p>No direct database access, no privileged backdoors.</p>"},{"location":"ADMIN_UI_VISION/#feature-categories","title":"Feature Categories","text":""},{"location":"ADMIN_UI_VISION/#1-data-management","title":"1. Data Management","text":"<ul> <li>Table Browser: Paginated view of collections with filters</li> <li>SQL Console: Execute queries, view results, see explain plans</li> <li>Schema Editor: Visual schema designer (generates migration SQL)</li> <li>Import/Export: Bulk data operations via REST API</li> </ul>"},{"location":"ADMIN_UI_VISION/#2-authentication-authorization","title":"2. Authentication &amp; Authorization","text":"<ul> <li>User List: View all users, their roles, last login</li> <li>Session Monitor: Active sessions, token expiry times</li> <li>RLS Policy Viewer: Inspect configured RLS rules per collection</li> </ul>"},{"location":"ADMIN_UI_VISION/#3-file-storage","title":"3. File Storage","text":"<ul> <li>Bucket Explorer: Browse buckets and objects</li> <li>Upload Interface: Drag-and-drop file upload</li> <li>Storage Metrics: Usage by bucket, quota warnings</li> </ul>"},{"location":"ADMIN_UI_VISION/#4-real-time-monitoring","title":"4. Real-Time Monitoring","text":"<ul> <li>Active Subscriptions: Who is subscribed to what</li> <li>Event Throughput: Events published per second</li> <li>Connection List: WebSocket connections, heartbeat status</li> </ul>"},{"location":"ADMIN_UI_VISION/#5-cluster-management-phase-7-integration","title":"5. Cluster Management (Phase 7 Integration)","text":"<ul> <li>Topology View: Authority, replicas, replication lag</li> <li>Promotion Controls: Trigger failover (with confirmation)</li> <li>WAL Viewer: Inspect WAL entries, sequence numbers</li> </ul>"},{"location":"ADMIN_UI_VISION/#6-observability","title":"6. Observability","text":"<ul> <li>Structured Logs: Filter by level, timestamp, module</li> <li>Metrics Dashboard: Queries/sec, latency percentiles, error rate</li> <li>Audit Log: User actions, API calls, schema changes</li> </ul>"},{"location":"ADMIN_UI_VISION/#design-principles","title":"Design Principles","text":""},{"location":"ADMIN_UI_VISION/#minimize-friction","title":"Minimize Friction","text":"<ul> <li>Fast page loads: Client-side rendering, code splitting</li> <li>Responsive queries: Pagination always required, limits enforced</li> <li>Progressive disclosure: Show summaries first, details on demand</li> </ul>"},{"location":"ADMIN_UI_VISION/#explicit-over-implicit","title":"Explicit Over Implicit","text":"<ul> <li>No auto-refresh by default: User controls when data refreshes</li> <li>Clear timestamps: All data shows \"as of [timestamp]\"</li> <li>Visible staleness: If data is cached, show cache age</li> </ul>"},{"location":"ADMIN_UI_VISION/#graceful-degradation","title":"Graceful Degradation","text":"<ul> <li>Offline mode: Cache last known state, show warning banner</li> <li>Partial failures: If metrics fail, still show data table</li> <li>Network errors: Retry with exponential backoff, show error state</li> </ul>"},{"location":"ADMIN_UI_VISION/#non-goals","title":"Non-Goals","text":"<p>The dashboard explicitly does not:</p> <ol> <li>Replace the CLI: Bulk operations, migrations use CLI</li> <li>Enforce invariants: Database enforces correctness, UI just reflects it</li> <li>Provide granular ACLs: RLS is in the database, not the dashboard</li> <li>Store its own state: No dashboard-specific database, all state is derived</li> </ol>"},{"location":"ADMIN_UI_VISION/#security-model","title":"Security Model","text":""},{"location":"ADMIN_UI_VISION/#authentication","title":"Authentication","text":"<ul> <li>Must provide valid JWT (obtained from <code>/auth/login</code>)</li> <li>Service role token allows admin access</li> <li>User tokens see only RLS-filtered data</li> </ul>"},{"location":"ADMIN_UI_VISION/#rbac-future","title":"RBAC (Future)","text":"<ul> <li><code>admin</code>: Full read/write access to all collections</li> <li><code>developer</code>: Read-only access to data, can execute queries</li> <li><code>viewer</code>: Read-only access to metrics and logs</li> </ul>"},{"location":"ADMIN_UI_VISION/#audit-trail","title":"Audit Trail","text":"<p>Every dashboard action is logged: - Timestamp, user ID, action type - Affected resource (collection, bucket, user) - Result (success/failure)</p>"},{"location":"ADMIN_UI_VISION/#success-criteria","title":"Success Criteria","text":"<p>The dashboard is successful if:</p> <ol> <li>Self-explanatory: New users understand data model within 5 minutes</li> <li>Fast enough: Page load &lt; 1s, query results &lt; 500ms (p95)</li> <li>Non-intrusive: Dashboard bugs don't affect database uptime</li> <li>API-aligned: All features use public REST/Control Plane APIs</li> </ol>"},{"location":"ADMIN_UI_VISION/#prior-art","title":"Prior Art","text":"<p>Inspired by: - Supabase Dashboard: Clean UI, table editor, SQL console - Postgres Admin Tools: pgAdmin, TablePlus (schema visualization) - Grafana: Metrics dashboards, time-series charts - Prisma Studio: Relation-aware data browser</p> <p>Differentiator: Explicit non-authority - Dashboard is a client, not a privileged layer.</p>"},{"location":"AUTH_ARCHITECTURE/","title":"AUTH_ARCHITECTURE.md \u2014 Authentication Architecture","text":""},{"location":"AUTH_ARCHITECTURE/#status","title":"Status","text":"<ul> <li>Phase: 8</li> <li>Authority: Normative</li> <li>Depends on: AUTH_VISION.md</li> <li>Date: 2026-02-06</li> </ul>"},{"location":"AUTH_ARCHITECTURE/#1-overview","title":"1. Overview","text":"<p>This document defines the technical architecture for AeroDB's authentication and authorization system.</p>"},{"location":"AUTH_ARCHITECTURE/#2-module-structure","title":"2. Module Structure","text":"<pre><code>src/auth/\n\u251c\u2500\u2500 mod.rs           # Module exports and public API\n\u251c\u2500\u2500 user.rs          # User model, storage, and CRUD\n\u251c\u2500\u2500 session.rs       # Session and refresh token management\n\u251c\u2500\u2500 jwt.rs           # JWT generation, validation, claims\n\u251c\u2500\u2500 crypto.rs        # Password hashing (Argon2id)\n\u251c\u2500\u2500 email.rs         # Email sending abstraction\n\u251c\u2500\u2500 api.rs           # HTTP API endpoints\n\u251c\u2500\u2500 rls.rs           # Row-Level Security enforcement\n\u251c\u2500\u2500 api_key.rs       # API key management\n\u2514\u2500\u2500 errors.rs        # Auth-specific error types\n</code></pre>"},{"location":"AUTH_ARCHITECTURE/#3-data-models","title":"3. Data Models","text":""},{"location":"AUTH_ARCHITECTURE/#31-user-model","title":"3.1 User Model","text":"<p>Users are stored as AeroDB documents in the <code>_users</code> collection:</p> <pre><code>pub struct User {\n    pub id: Uuid,\n    pub email: String,\n    pub email_verified: bool,\n    pub password_hash: String,\n    pub created_at: DateTime&lt;Utc&gt;,\n    pub updated_at: DateTime&lt;Utc&gt;,\n    pub metadata: Option&lt;serde_json::Value&gt;,\n}\n</code></pre> <p>Constraints: - Email must be unique (enforced by unique index) - Password hash uses Argon2id (never stored plaintext) - ID is UUIDv4 (generated on creation)</p>"},{"location":"AUTH_ARCHITECTURE/#32-session-model","title":"3.2 Session Model","text":"<p>Sessions are stored in the <code>_sessions</code> collection:</p> <pre><code>pub struct Session {\n    pub id: Uuid,\n    pub user_id: Uuid,\n    pub refresh_token_hash: String,\n    pub created_at: DateTime&lt;Utc&gt;,\n    pub expires_at: DateTime&lt;Utc&gt;,\n    pub revoked: bool,\n}\n</code></pre>"},{"location":"AUTH_ARCHITECTURE/#33-jwt-claims","title":"3.3 JWT Claims","text":"<p>Access tokens contain:</p> <pre><code>pub struct JwtClaims {\n    pub sub: Uuid,           // User ID\n    pub email: String,       // User email\n    pub iat: i64,            // Issued at\n    pub exp: i64,            // Expires at (15 min)\n    pub aud: String,         // Audience (project ID)\n    pub iss: String,         // Issuer (aerodb)\n}\n</code></pre>"},{"location":"AUTH_ARCHITECTURE/#4-security-architecture","title":"4. Security Architecture","text":""},{"location":"AUTH_ARCHITECTURE/#41-password-hashing","title":"4.1 Password Hashing","text":"<pre><code>// src/auth/crypto.rs\nuse argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};\nuse argon2::password_hash::SaltString;\n\npub fn hash_password(password: &amp;str) -&gt; Result&lt;String, AuthError&gt; {\n    let salt = SaltString::generate(&amp;mut OsRng);\n    let argon2 = Argon2::default();\n    let hash = argon2.hash_password(password.as_bytes(), &amp;salt)?;\n    Ok(hash.to_string())\n}\n\npub fn verify_password(password: &amp;str, hash: &amp;str) -&gt; Result&lt;bool, AuthError&gt; {\n    let parsed = PasswordHash::new(hash)?;\n    Ok(Argon2::default().verify_password(password.as_bytes(), &amp;parsed).is_ok())\n}\n</code></pre>"},{"location":"AUTH_ARCHITECTURE/#42-jwt-signing","title":"4.2 JWT Signing","text":"<ul> <li>Algorithm: HS256 (HMAC-SHA256)</li> <li>Secret: 256-bit random key (configured per deployment)</li> <li>Access token TTL: 15 minutes</li> <li>Refresh token TTL: 30 days</li> </ul>"},{"location":"AUTH_ARCHITECTURE/#43-refresh-token-storage","title":"4.3 Refresh Token Storage","text":"<p>Refresh tokens are: 1. Generated as 256-bit random values 2. Hashed with SHA-256 before storage 3. Returned to client as base64-encoded raw value 4. Validated by hashing client-provided value and comparing</p>"},{"location":"AUTH_ARCHITECTURE/#5-row-level-security-rls","title":"5. Row-Level Security (RLS)","text":""},{"location":"AUTH_ARCHITECTURE/#51-rls-context","title":"5.1 RLS Context","text":"<p>Every authenticated request carries an RLS context:</p> <pre><code>pub struct RlsContext {\n    pub user_id: Uuid,\n    pub is_authenticated: bool,\n    pub is_service_role: bool,  // API key with service role\n}\n</code></pre>"},{"location":"AUTH_ARCHITECTURE/#52-rls-enforcement-points","title":"5.2 RLS Enforcement Points","text":"<p>RLS is enforced at query planning time, not execution:</p> <pre><code>// src/auth/rls.rs\npub trait RlsEnforcer {\n    /// Inject RLS filters into a read query\n    fn enforce_read(&amp;self, query: &amp;Query, ctx: &amp;RlsContext) -&gt; Result&lt;Query, RlsError&gt;;\n\n    /// Validate write operation against RLS policy\n    fn enforce_write(&amp;self, doc: &amp;Document, ctx: &amp;RlsContext) -&gt; Result&lt;(), RlsError&gt;;\n}\n</code></pre>"},{"location":"AUTH_ARCHITECTURE/#53-default-rls-policy","title":"5.3 Default RLS Policy","text":"<p>Unless overridden, the default policy is: - Users can only read/write documents where <code>owner_id == user_id</code> - Service role keys bypass RLS (explicit opt-in)</p>"},{"location":"AUTH_ARCHITECTURE/#6-api-endpoints","title":"6. API Endpoints","text":"Method Path Description POST <code>/auth/signup</code> Register new user POST <code>/auth/login</code> Authenticate user POST <code>/auth/logout</code> Invalidate session POST <code>/auth/refresh</code> Refresh access token POST <code>/auth/forgot-password</code> Request password reset POST <code>/auth/reset-password</code> Reset password with token GET <code>/auth/user</code> Get current user info PUT <code>/auth/user</code> Update user profile"},{"location":"AUTH_ARCHITECTURE/#7-integration-with-core","title":"7. Integration with Core","text":""},{"location":"AUTH_ARCHITECTURE/#71-no-core-modifications","title":"7.1 No Core Modifications","text":"<p>Phase 8 MUST NOT modify: - WAL format or behavior - MVCC mechanics - Replication protocol - Core query execution</p>"},{"location":"AUTH_ARCHITECTURE/#72-planner-extension","title":"7.2 Planner Extension","text":"<p>RLS extends the planner via composition:</p> <pre><code>// RLS wraps the existing planner\npub struct RlsPlanner&lt;P: Planner&gt; {\n    inner: P,\n    enforcer: Box&lt;dyn RlsEnforcer&gt;,\n}\n\nimpl&lt;P: Planner&gt; Planner for RlsPlanner&lt;P&gt; {\n    fn plan(&amp;self, query: &amp;Query, ctx: &amp;RlsContext) -&gt; Result&lt;Plan, PlanError&gt; {\n        let filtered_query = self.enforcer.enforce_read(query, ctx)?;\n        self.inner.plan(&amp;filtered_query)\n    }\n}\n</code></pre>"},{"location":"AUTH_ARCHITECTURE/#8-observability","title":"8. Observability","text":"<p>All authentication events emit structured logs:</p> <pre><code>pub enum AuthEvent {\n    SignupAttempt { email: String, success: bool },\n    LoginAttempt { email: String, success: bool },\n    TokenRefresh { user_id: Uuid },\n    PasswordReset { user_id: Uuid },\n    RlsViolation { user_id: Uuid, collection: String },\n}\n</code></pre>"},{"location":"AUTH_ARCHITECTURE/#9-configuration","title":"9. Configuration","text":"<pre><code>[auth]\nenabled = true\njwt_secret = \"your-256-bit-secret\"\njwt_access_ttl_seconds = 900       # 15 minutes\njwt_refresh_ttl_days = 30\n\n[auth.password]\nmin_length = 8\nrequire_uppercase = false\nrequire_number = false\n\n[auth.email]\nsmtp_host = \"smtp.example.com\"\nsmtp_port = 587\nfrom_address = \"noreply@example.com\"\n</code></pre>"},{"location":"AUTH_ARCHITECTURE/#10-constraints","title":"10. Constraints","text":"<p>Phase 8 MUST: - Never log passwords (even hashed) - Never store plaintext passwords - Always use constant-time comparison for secrets - Fail closed on any validation error</p> <p>Phase 8 MUST NOT: - Modify Phase 0-7 behavior - Add WAL records for auth operations - Introduce background cleanup threads</p> <p>END OF DOCUMENT</p>"},{"location":"AUTH_FAILURE_MODEL/","title":"Phase 8: Failure Model","text":"<p>Document Type: Normative Specification Phase: 8 - Authentication &amp; Authorization Status: Active</p>"},{"location":"AUTH_FAILURE_MODEL/#overview","title":"Overview","text":"<p>This document specifies authentication failure handling with fail-closed semantics.</p>"},{"location":"AUTH_FAILURE_MODEL/#fail-closed-principle","title":"Fail-Closed Principle","text":"<p>AUTH-F1: On any authentication error, the system MUST deny access. No fallback to anonymous access.</p>"},{"location":"AUTH_FAILURE_MODEL/#error-categories","title":"Error Categories","text":""},{"location":"AUTH_FAILURE_MODEL/#authentication-errors-4xx","title":"Authentication Errors (4xx)","text":"Error HTTP Response Action Invalid credentials 401 <code>invalid_credentials</code> Log attempt Token expired 401 <code>token_expired</code> Prompt refresh Token invalid 401 <code>invalid_token</code> Clear client state Session revoked 401 <code>session_revoked</code> Force re-auth Missing auth 401 <code>authentication_required</code> Prompt login"},{"location":"AUTH_FAILURE_MODEL/#authorization-errors-4xx","title":"Authorization Errors (4xx)","text":"Error HTTP Response Action RLS violation 403 <code>access_denied</code> Log violation Resource not owned 403 <code>forbidden</code> Log violation Insufficient role 403 <code>insufficient_permissions</code> Log violation"},{"location":"AUTH_FAILURE_MODEL/#server-errors-5xx","title":"Server Errors (5xx)","text":"Error HTTP Response Action Crypto failure 500 <code>internal_error</code> Alert ops DB unavailable 503 <code>service_unavailable</code> Retry with backoff Token signing failed 500 <code>internal_error</code> Alert ops"},{"location":"AUTH_FAILURE_MODEL/#error-response-format","title":"Error Response Format","text":"<pre><code>{\n  \"error\": {\n    \"code\": \"invalid_credentials\",\n    \"message\": \"Invalid email or password\",\n    \"status\": 401\n  }\n}\n</code></pre>"},{"location":"AUTH_FAILURE_MODEL/#response-invariants","title":"Response Invariants","text":"<ul> <li>AUTH-E1: Error messages never reveal which field was wrong</li> <li>AUTH-E2: No timing differences between valid/invalid users</li> <li>AUTH-E3: Rate limiting applied before detailed validation</li> </ul>"},{"location":"AUTH_FAILURE_MODEL/#rate-limiting","title":"Rate Limiting","text":""},{"location":"AUTH_FAILURE_MODEL/#limits","title":"Limits","text":"Endpoint Window Max Attempts <code>/auth/login</code> 15 min 5 per email <code>/auth/signup</code> 1 hour 3 per IP <code>/auth/forgot-password</code> 1 hour 3 per email"},{"location":"AUTH_FAILURE_MODEL/#response","title":"Response","text":"<pre><code>{\n  \"error\": {\n    \"code\": \"rate_limit_exceeded\",\n    \"message\": \"Too many attempts. Try again later.\",\n    \"status\": 429,\n    \"retry_after\": 900\n  }\n}\n</code></pre>"},{"location":"AUTH_FAILURE_MODEL/#failure-logging","title":"Failure Logging","text":""},{"location":"AUTH_FAILURE_MODEL/#required-fields","title":"Required Fields","text":"<pre><code>{\n  \"event\": \"auth_failure\",\n  \"error_code\": \"invalid_credentials\",\n  \"email_hash\": \"sha256(email)\",\n  \"ip_address\": \"x.x.x.x\",\n  \"user_agent\": \"...\",\n  \"timestamp\": \"2026-02-06T00:00:00Z\"\n}\n</code></pre>"},{"location":"AUTH_FAILURE_MODEL/#privacy-invariants","title":"Privacy Invariants","text":"<ul> <li>AUTH-L1: Full email never logged (use hash)</li> <li>AUTH-L2: Passwords never logged</li> <li>AUTH-L3: IP logged for security, subject to retention policy</li> </ul>"},{"location":"AUTH_FAILURE_MODEL/#recovery-procedures","title":"Recovery Procedures","text":""},{"location":"AUTH_FAILURE_MODEL/#account-lockout","title":"Account Lockout","text":"<p>After 10 failed attempts in 1 hour:</p> <ol> <li>Account temporarily locked (30 min)</li> <li>Email notification sent to user</li> <li>Admin can manually unlock</li> </ol>"},{"location":"AUTH_FAILURE_MODEL/#brute-force-detection","title":"Brute Force Detection","text":"<p>Pattern detection triggers:</p> <ol> <li>Alert to security monitoring</li> <li>CAPTCHA requirement</li> <li>IP-level rate limiting</li> </ol>"},{"location":"AUTH_FAILURE_MODEL/#determinism","title":"Determinism","text":"<p>Authentication failures are deterministic:</p> <ul> <li>Same input \u2192 Same error code</li> <li>No randomized delays in error paths</li> <li>Timing attacks mitigated via constant-time comparison</li> </ul>"},{"location":"AUTH_INVARIANTS/","title":"AUTH_INVARIANTS.md \u2014 Authentication Invariants","text":""},{"location":"AUTH_INVARIANTS/#status","title":"Status","text":"<ul> <li>Phase: 8</li> <li>Authority: Normative</li> <li>Depends on: AUTH_VISION.md, AUTH_ARCHITECTURE.md</li> <li>Date: 2026-02-06</li> </ul>"},{"location":"AUTH_INVARIANTS/#1-purpose","title":"1. Purpose","text":"<p>This document defines inviolable invariants for Phase 8 authentication and authorization. These invariants MUST be enforced by implementation and verified by tests.</p>"},{"location":"AUTH_INVARIANTS/#2-security-invariants","title":"2. Security Invariants","text":""},{"location":"AUTH_INVARIANTS/#auth-s1-passwords-never-logged","title":"AUTH-S1: Passwords Never Logged","text":"<p>Plaintext passwords MUST never appear in logs, traces, or error messages.</p> <pre><code>// FORBIDDEN\nlog::error!(\"Login failed for password: {}\", password);\n\n// ALLOWED\nlog::error!(\"Login failed for user: {}\", email);\n</code></pre>"},{"location":"AUTH_INVARIANTS/#auth-s2-passwords-never-stored-plaintext","title":"AUTH-S2: Passwords Never Stored Plaintext","text":"<p>Passwords MUST only be stored as cryptographic hashes using Argon2id.</p>"},{"location":"AUTH_INVARIANTS/#auth-s3-constant-time-comparison","title":"AUTH-S3: Constant-Time Comparison","text":"<p>All secret comparisons MUST use constant-time algorithms to prevent timing attacks.</p> <pre><code>use subtle::ConstantTimeEq;\n\nfn verify_token(provided: &amp;[u8], stored: &amp;[u8]) -&gt; bool {\n    provided.ct_eq(stored).into()\n}\n</code></pre>"},{"location":"AUTH_INVARIANTS/#auth-s4-fail-closed","title":"AUTH-S4: Fail Closed","text":"<p>Any authentication validation failure MUST result in denial, never silent acceptance.</p> <pre><code>// FORBIDDEN\nif let Some(user) = maybe_user {\n    // proceed\n}\n// Falls through silently if user is None\n\n// REQUIRED\nlet user = maybe_user.ok_or(AuthError::InvalidCredentials)?;\n</code></pre>"},{"location":"AUTH_INVARIANTS/#3-session-invariants","title":"3. Session Invariants","text":""},{"location":"AUTH_INVARIANTS/#auth-ss1-refresh-token-rotation","title":"AUTH-SS1: Refresh Token Rotation","text":"<p>Each refresh token MUST be single-use. Using a refresh token invalidates it.</p>"},{"location":"AUTH_INVARIANTS/#auth-ss2-session-expiration","title":"AUTH-SS2: Session Expiration","text":"<p>Sessions MUST expire at their stated expiration time. No implicit extension.</p>"},{"location":"AUTH_INVARIANTS/#auth-ss3-logout-invalidation","title":"AUTH-SS3: Logout Invalidation","text":"<p>Logout MUST immediately invalidate the session. Subsequent requests MUST fail.</p>"},{"location":"AUTH_INVARIANTS/#4-jwt-invariants","title":"4. JWT Invariants","text":""},{"location":"AUTH_INVARIANTS/#auth-jwt1-stateless-validation","title":"AUTH-JWT1: Stateless Validation","text":"<p>Access tokens MUST be validatable without database lookup.</p> <p>Validation requires only: - The token itself - The signing secret - Current time (for expiration)</p>"},{"location":"AUTH_INVARIANTS/#auth-jwt2-short-expiration","title":"AUTH-JWT2: Short Expiration","text":"<p>Access tokens MUST expire within 15 minutes of issuance.</p>"},{"location":"AUTH_INVARIANTS/#auth-jwt3-no-secret-in-token","title":"AUTH-JWT3: No Secret in Token","text":"<p>Tokens MUST NOT contain passwords, secrets, or sensitive data.</p>"},{"location":"AUTH_INVARIANTS/#5-rls-invariants","title":"5. RLS Invariants","text":""},{"location":"AUTH_INVARIANTS/#auth-rls1-no-silent-bypass","title":"AUTH-RLS1: No Silent Bypass","text":"<p>RLS MUST NOT be silently bypassed. Bypass requires explicit service role.</p>"},{"location":"AUTH_INVARIANTS/#auth-rls2-query-injection-determinism","title":"AUTH-RLS2: Query Injection Determinism","text":"<p>Same query + same user + same policy MUST produce identical filtered query.</p>"},{"location":"AUTH_INVARIANTS/#auth-rls3-write-validation","title":"AUTH-RLS3: Write Validation","text":"<p>All writes MUST be validated against RLS policy before execution.</p>"},{"location":"AUTH_INVARIANTS/#auth-rls4-filter-before-execution","title":"AUTH-RLS4: Filter Before Execution","text":"<p>RLS filters MUST be applied at planning time, before any data is accessed.</p>"},{"location":"AUTH_INVARIANTS/#6-observability-invariants","title":"6. Observability Invariants","text":""},{"location":"AUTH_INVARIANTS/#auth-o1-all-events-logged","title":"AUTH-O1: All Events Logged","text":"<p>All authentication attempts (success and failure) MUST be logged to audit trail.</p>"},{"location":"AUTH_INVARIANTS/#auth-o2-no-sensitive-data-in-logs","title":"AUTH-O2: No Sensitive Data in Logs","text":"<p>Logs MUST NOT contain passwords, tokens, or secrets.</p> <p>Allowed: user ID, email, timestamp, success/failure Forbidden: password, JWT, refresh token, API key</p>"},{"location":"AUTH_INVARIANTS/#7-integration-invariants","title":"7. Integration Invariants","text":""},{"location":"AUTH_INVARIANTS/#auth-i1-no-core-modification","title":"AUTH-I1: No Core Modification","text":"<p>Phase 8 MUST NOT modify any Phase 0-7 behavior.</p>"},{"location":"AUTH_INVARIANTS/#auth-i2-no-wal-records","title":"AUTH-I2: No WAL Records","text":"<p>Authentication does NOT write to WAL for auth operations.</p> <p>Auth state is stored in regular collections (<code>_users</code>, <code>_sessions</code>), not special WAL records.</p>"},{"location":"AUTH_INVARIANTS/#auth-i3-planner-extension-only","title":"AUTH-I3: Planner Extension Only","text":"<p>RLS extends the planner via composition, not modification.</p> <p>The core planner is wrapped, not changed.</p>"},{"location":"AUTH_INVARIANTS/#8-enforcement-matrix","title":"8. Enforcement Matrix","text":"Invariant Enforcement Location Test File AUTH-S1 All logging calls <code>auth_security_tests.rs</code> AUTH-S2 <code>crypto.rs</code> <code>crypto_tests.rs</code> AUTH-S3 <code>crypto.rs</code>, <code>jwt.rs</code> <code>timing_tests.rs</code> AUTH-S4 All auth handlers <code>auth_denial_tests.rs</code> AUTH-SS1 <code>session.rs</code> <code>session_tests.rs</code> AUTH-SS2 <code>session.rs</code> <code>expiration_tests.rs</code> AUTH-SS3 <code>session.rs</code>, <code>api.rs</code> <code>logout_tests.rs</code> AUTH-JWT1 <code>jwt.rs</code> <code>jwt_tests.rs</code> AUTH-JWT2 <code>jwt.rs</code> <code>jwt_tests.rs</code> AUTH-JWT3 <code>jwt.rs</code> <code>jwt_tests.rs</code> AUTH-RLS1 <code>rls.rs</code> <code>rls_bypass_tests.rs</code> AUTH-RLS2 <code>rls.rs</code> <code>rls_determinism_tests.rs</code> AUTH-RLS3 <code>rls.rs</code> <code>rls_write_tests.rs</code> AUTH-RLS4 <code>rls.rs</code> <code>rls_planning_tests.rs</code>"},{"location":"AUTH_INVARIANTS/#9-violation-response","title":"9. Violation Response","text":"<p>If any invariant is violated:</p> <ol> <li>The operation MUST fail with an explicit error</li> <li>The violation MUST be logged (without exposing secrets)</li> <li>The invariant ID MUST be referenced in the error</li> <li>No partial or \"best-effort\" execution is allowed</li> </ol> <p>END OF DOCUMENT</p>"},{"location":"AUTH_OBSERVABILITY_MAPPING/","title":"Phase 8: Observability Mapping","text":"<p>Document Type: Normative Specification Phase: 8 - Authentication &amp; Authorization Status: Active</p>"},{"location":"AUTH_OBSERVABILITY_MAPPING/#overview","title":"Overview","text":"<p>This document maps authentication events to observability primitives (logs, metrics, traces).</p>"},{"location":"AUTH_OBSERVABILITY_MAPPING/#event-catalog","title":"Event Catalog","text":""},{"location":"AUTH_OBSERVABILITY_MAPPING/#authentication-events","title":"Authentication Events","text":"Event Level Metrics Alert <code>auth.signup.success</code> INFO counter No <code>auth.signup.failure</code> WARN counter &gt;10/min <code>auth.login.success</code> INFO counter No <code>auth.login.failure</code> WARN counter &gt;20/min <code>auth.logout</code> INFO counter No <code>auth.token.refresh</code> DEBUG counter No <code>auth.token.expired</code> DEBUG counter No <code>auth.session.revoked</code> INFO counter No"},{"location":"AUTH_OBSERVABILITY_MAPPING/#authorization-events","title":"Authorization Events","text":"Event Level Metrics Alert <code>rls.filter.applied</code> DEBUG counter No <code>rls.access.denied</code> WARN counter &gt;5/min <code>rls.bypass.service</code> DEBUG counter No"},{"location":"AUTH_OBSERVABILITY_MAPPING/#security-events","title":"Security Events","text":"Event Level Metrics Alert <code>auth.brute_force.detected</code> ERROR counter Yes <code>auth.account.locked</code> WARN counter Yes <code>auth.token.reuse</code> ERROR counter Yes"},{"location":"AUTH_OBSERVABILITY_MAPPING/#metrics","title":"Metrics","text":""},{"location":"AUTH_OBSERVABILITY_MAPPING/#counters","title":"Counters","text":"<pre><code>aerodb_auth_signups_total{status=\"success|failure\"}\naerodb_auth_logins_total{status=\"success|failure\"}\naerodb_auth_token_refreshes_total\naerodb_auth_sessions_active\naerodb_rls_decisions_total{result=\"allowed|denied\"}\n</code></pre>"},{"location":"AUTH_OBSERVABILITY_MAPPING/#histograms","title":"Histograms","text":"<pre><code>aerodb_auth_login_duration_seconds\naerodb_auth_token_validation_duration_seconds\naerodb_rls_filter_application_duration_seconds\n</code></pre>"},{"location":"AUTH_OBSERVABILITY_MAPPING/#gauges","title":"Gauges","text":"<pre><code>aerodb_auth_active_sessions\naerodb_auth_locked_accounts\n</code></pre>"},{"location":"AUTH_OBSERVABILITY_MAPPING/#log-format","title":"Log Format","text":""},{"location":"AUTH_OBSERVABILITY_MAPPING/#structured-log-entry","title":"Structured Log Entry","text":"<pre><code>{\n  \"timestamp\": \"2026-02-06T00:00:00.000Z\",\n  \"level\": \"INFO\",\n  \"event\": \"auth.login.success\",\n  \"user_id\": \"uuid\",\n  \"session_id\": \"uuid\",\n  \"ip_address\": \"x.x.x.x\",\n  \"user_agent\": \"...\",\n  \"duration_ms\": 45\n}\n</code></pre>"},{"location":"AUTH_OBSERVABILITY_MAPPING/#sensitive-data-handling","title":"Sensitive Data Handling","text":"<ul> <li><code>email</code> \u2192 log as <code>email_hash</code> (SHA-256)</li> <li><code>password</code> \u2192 never log</li> <li><code>token</code> \u2192 never log</li> <li><code>ip_address</code> \u2192 log (security requirement)</li> </ul>"},{"location":"AUTH_OBSERVABILITY_MAPPING/#tracing","title":"Tracing","text":""},{"location":"AUTH_OBSERVABILITY_MAPPING/#span-hierarchy","title":"Span Hierarchy","text":"<pre><code>auth.login (parent)\n\u251c\u2500\u2500 auth.validate_credentials\n\u2502   \u251c\u2500\u2500 db.user.find\n\u2502   \u2514\u2500\u2500 crypto.password_verify\n\u251c\u2500\u2500 auth.create_session\n\u2502   \u2514\u2500\u2500 db.session.insert\n\u2514\u2500\u2500 auth.issue_tokens\n    \u2514\u2500\u2500 jwt.sign\n</code></pre>"},{"location":"AUTH_OBSERVABILITY_MAPPING/#span-attributes","title":"Span Attributes","text":"<pre><code>span.auth.user_id = \"uuid\"\nspan.auth.method = \"password|oauth|magic_link\"\nspan.auth.result = \"success|failure\"\n</code></pre>"},{"location":"AUTH_OBSERVABILITY_MAPPING/#dashboards","title":"Dashboards","text":""},{"location":"AUTH_OBSERVABILITY_MAPPING/#auth-overview-dashboard","title":"Auth Overview Dashboard","text":"<ol> <li>Login Success Rate (%)</li> <li>Signup Rate (per hour)</li> <li>Active Sessions (gauge)</li> <li>Failed Login Attempts (per minute)</li> <li>RLS Denials (per minute)</li> </ol>"},{"location":"AUTH_OBSERVABILITY_MAPPING/#security-dashboard","title":"Security Dashboard","text":"<ol> <li>Brute Force Attempts</li> <li>Locked Accounts</li> <li>Token Reuse Attempts</li> <li>Geographic Anomalies</li> </ol>"},{"location":"AUTH_OBSERVABILITY_MAPPING/#alerting-rules","title":"Alerting Rules","text":"Alert Condition Severity HighLoginFailures &gt;50 failures/5min Warning BruteForceDetected &gt;10 failures/min same IP Critical AccountLocked any lockout Warning TokenReuseDetected any reuse Critical"},{"location":"AUTH_READINESS/","title":"Phase 8: Readiness Checklist","text":"<p>Document Type: Freeze Criteria Phase: 8 - Authentication &amp; Authorization Status: In Progress</p>"},{"location":"AUTH_READINESS/#overview","title":"Overview","text":"<p>This document defines the criteria for Phase 8 to be considered complete and ready for freezing.</p>"},{"location":"AUTH_READINESS/#documentation-readiness","title":"Documentation Readiness","text":"Document Status Reviewed AUTH_VISION.md \u2705 Complete \u2610 AUTH_ARCHITECTURE.md \u2705 Complete \u2610 AUTH_RLS_MODEL.md \u2705 Complete \u2610 AUTH_INVARIANTS.md \u2705 Complete \u2610 AUTH_SESSION_MODEL.md \u2705 Complete \u2610 AUTH_TOKEN_MODEL.md \u2705 Complete \u2610 AUTH_FAILURE_MODEL.md \u2705 Complete \u2610 AUTH_OBSERVABILITY_MAPPING.md \u2705 Complete \u2610 AUTH_TESTING_STRATEGY.md \u2705 Complete \u2610 AUTH_READINESS.md \u2705 Complete \u2610"},{"location":"AUTH_READINESS/#implementation-readiness","title":"Implementation Readiness","text":""},{"location":"AUTH_READINESS/#core-modules","title":"Core Modules","text":"Module Status Tests src/auth/mod.rs \u2705 N/A src/auth/errors.rs \u2705 \u2705 src/auth/crypto.rs \u2705 \u2705 src/auth/user.rs \u2705 \u2705 src/auth/session.rs \u2705 \u2705 src/auth/jwt.rs \u2705 \u2705 src/auth/rls.rs \u2705 \u2705 src/auth/api.rs \u2705 \u2705 src/auth/email.rs \u2610 Deferred \u2610"},{"location":"AUTH_READINESS/#api-endpoints","title":"API Endpoints","text":"Endpoint Status POST /auth/signup \u2705 POST /auth/login \u2705 POST /auth/logout \u2705 POST /auth/refresh \u2705 POST /auth/forgot-password \u2610 Deferred POST /auth/reset-password \u2610 Deferred GET /auth/user \u2610 Deferred PUT /auth/user \u2610 Deferred"},{"location":"AUTH_READINESS/#invariant-verification","title":"Invariant Verification","text":"Invariant Tested Verified AUTH-1: Passwords never logged \u2705 \u2610 AUTH-2: Argon2id hashing \u2705 \u2705 AUTH-3: Constant-time comparison \u2705 \u2705 AUTH-S1: Refresh token hashed \u2705 \u2705 AUTH-T1: Stateless JWT validation \u2705 \u2705 AUTH-T4: Expired tokens rejected \u2705 \u2705 AUTH-R1: Refresh reuse = revocation \u2705 \u2705 AUTH-RLS1: No silent bypass \u2705 \u2705"},{"location":"AUTH_READINESS/#test-coverage","title":"Test Coverage","text":"Metric Current Target Unit tests passing 42 42+ Integration tests 0 10+ Code coverage ~85% 90%"},{"location":"AUTH_READINESS/#known-deferred-items","title":"Known Deferred Items","text":"Item Reason Phase Email integration External dependency Post-MVP Password reset flow Requires email Post-MVP OAuth providers Complexity Phase 8.2 Magic links Requires email Phase 8.3"},{"location":"AUTH_READINESS/#freeze-criteria","title":"Freeze Criteria","text":""},{"location":"AUTH_READINESS/#must-have-mvp","title":"Must Have (MVP)","text":"<ul> <li> User signup/login/logout</li> <li> JWT access tokens</li> <li> Refresh token rotation</li> <li> RLS enforcement</li> <li> Unit tests passing</li> <li> Integration tests passing</li> <li> Documentation reviewed</li> </ul>"},{"location":"AUTH_READINESS/#should-have","title":"Should Have","text":"<ul> <li> Password reset flow</li> <li> User profile API</li> <li> Email verification</li> </ul>"},{"location":"AUTH_READINESS/#nice-to-have","title":"Nice to Have","text":"<ul> <li> OAuth providers</li> <li> Magic links</li> <li> Account lockout</li> </ul>"},{"location":"AUTH_READINESS/#freeze-decision","title":"Freeze Decision","text":"<p>Status: NOT READY</p> <p>Blockers: 1. Integration tests not implemented 2. Documentation not reviewed</p> <p>ETA: After completing integration tests</p>"},{"location":"AUTH_RLS_MODEL/","title":"AUTH_RLS_MODEL.md \u2014 Row-Level Security Model","text":""},{"location":"AUTH_RLS_MODEL/#status","title":"Status","text":"<ul> <li>Phase: 8</li> <li>Authority: Normative</li> <li>Depends on: AUTH_ARCHITECTURE.md</li> <li>Date: 2026-02-06</li> </ul>"},{"location":"AUTH_RLS_MODEL/#1-purpose","title":"1. Purpose","text":"<p>This document defines AeroDB's Row-Level Security (RLS) model, which provides fine-grained access control at the document level.</p>"},{"location":"AUTH_RLS_MODEL/#2-core-concept","title":"2. Core Concept","text":"<p>RLS automatically filters data based on the authenticated user's identity. Users only see and modify data they are authorized to access.</p> <pre><code>Query: SELECT * FROM posts\nUser: alice (id: 123)\nRLS Policy: owner_id = auth.user_id\n\nEffective Query: SELECT * FROM posts WHERE owner_id = '123'\n</code></pre>"},{"location":"AUTH_RLS_MODEL/#3-rls-context","title":"3. RLS Context","text":"<p>Every request carries an RLS context:</p> <pre><code>pub struct RlsContext {\n    /// The authenticated user's ID (None if anonymous)\n    pub user_id: Option&lt;Uuid&gt;,\n\n    /// Whether the request is authenticated\n    pub is_authenticated: bool,\n\n    /// Whether using service role (bypasses RLS)\n    pub is_service_role: bool,\n\n    /// Custom claims from JWT (for advanced policies)\n    pub claims: HashMap&lt;String, serde_json::Value&gt;,\n}\n</code></pre>"},{"location":"AUTH_RLS_MODEL/#4-policy-types","title":"4. Policy Types","text":""},{"location":"AUTH_RLS_MODEL/#41-ownership-policy-default","title":"4.1 Ownership Policy (Default)","text":"<p>The default policy enforces document ownership:</p> <pre><code>pub struct OwnershipPolicy {\n    /// Field name containing the owner ID\n    pub owner_field: String,  // Default: \"owner_id\"\n}\n</code></pre> <p>Behavior: - Read: Filter by <code>{owner_field} = user_id</code> - Insert: Automatically set <code>{owner_field} = user_id</code> - Update: Only allow if <code>{owner_field} = user_id</code> - Delete: Only allow if <code>{owner_field} = user_id</code></p>"},{"location":"AUTH_RLS_MODEL/#42-public-read-policy","title":"4.2 Public Read Policy","text":"<p>Allows public reads, owner-only writes:</p> <pre><code>pub struct PublicReadPolicy {\n    pub owner_field: String,\n}\n</code></pre> <p>Behavior: - Read: No filter (all rows visible) - Write: Restricted to owner</p>"},{"location":"AUTH_RLS_MODEL/#43-custom-predicate-policy","title":"4.3 Custom Predicate Policy","text":"<p>Advanced policies using custom predicates:</p> <pre><code>pub struct PredicatePolicy {\n    pub read_predicate: Option&lt;FilterExpr&gt;,\n    pub write_predicate: Option&lt;FilterExpr&gt;,\n}\n</code></pre>"},{"location":"AUTH_RLS_MODEL/#5-policy-assignment","title":"5. Policy Assignment","text":"<p>Policies are assigned per collection in the schema:</p> <pre><code>{\n  \"collection\": \"posts\",\n  \"schema\": { ... },\n  \"rls\": {\n    \"enabled\": true,\n    \"policy\": \"ownership\",\n    \"owner_field\": \"author_id\"\n  }\n}\n</code></pre>"},{"location":"AUTH_RLS_MODEL/#6-enforcement-points","title":"6. Enforcement Points","text":""},{"location":"AUTH_RLS_MODEL/#61-query-planning-primary","title":"6.1 Query Planning (Primary)","text":"<p>RLS filters are injected at query planning time:</p> <pre><code>impl RlsEnforcer for OwnershipEnforcer {\n    fn enforce_read(&amp;self, query: &amp;Query, ctx: &amp;RlsContext) -&gt; Result&lt;Query, RlsError&gt; {\n        if ctx.is_service_role {\n            return Ok(query.clone());  // Bypass for service role\n        }\n\n        let user_id = ctx.user_id.ok_or(RlsError::AuthenticationRequired)?;\n\n        // Inject ownership filter\n        let filter = Filter::eq(self.owner_field.clone(), Value::Uuid(user_id));\n        Ok(query.with_additional_filter(filter))\n    }\n}\n</code></pre>"},{"location":"AUTH_RLS_MODEL/#62-write-validation","title":"6.2 Write Validation","text":"<p>Write operations are validated before execution:</p> <pre><code>fn enforce_write(&amp;self, doc: &amp;Document, ctx: &amp;RlsContext) -&gt; Result&lt;(), RlsError&gt; {\n    if ctx.is_service_role {\n        return Ok(());\n    }\n\n    let user_id = ctx.user_id.ok_or(RlsError::AuthenticationRequired)?;\n    let doc_owner = doc.get(&amp;self.owner_field)\n        .and_then(|v| v.as_uuid())\n        .ok_or(RlsError::MissingOwnerField)?;\n\n    if doc_owner != user_id {\n        return Err(RlsError::Unauthorized);\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"AUTH_RLS_MODEL/#7-service-role-bypass","title":"7. Service Role Bypass","text":"<p>API keys with <code>service_role</code> can bypass RLS:</p> <pre><code>pub enum ApiKeyRole {\n    Anon,          // No auth, RLS enforced\n    User,          // User-level, RLS enforced  \n    ServiceRole,   // RLS bypassed\n}\n</code></pre> <p>[!CAUTION] Service role keys should only be used server-side. Never expose in client applications.</p>"},{"location":"AUTH_RLS_MODEL/#8-determinism-guarantee","title":"8. Determinism Guarantee","text":"<p>RLS enforcement is deterministic:</p> <ul> <li>Same query + same user + same policy = same filtered query</li> <li>No randomness in filter generation</li> <li>No time-dependent policy evaluation</li> </ul>"},{"location":"AUTH_RLS_MODEL/#9-observability","title":"9. Observability","text":"<p>RLS decisions are observable:</p> <pre><code>pub enum RlsEvent {\n    PolicyApplied { collection: String, user_id: Uuid, policy: String },\n    AccessDenied { collection: String, user_id: Uuid, reason: String },\n    ServiceRoleBypass { collection: String },\n}\n</code></pre>"},{"location":"AUTH_RLS_MODEL/#10-error-handling","title":"10. Error Handling","text":"<p>RLS failures are explicit and informative:</p> <pre><code>pub enum RlsError {\n    /// User must be authenticated to access this resource\n    AuthenticationRequired,\n\n    /// User is not authorized to access this document\n    Unauthorized,\n\n    /// Collection does not have owner field\n    MissingOwnerField,\n\n    /// RLS policy configuration is invalid\n    InvalidPolicy(String),\n}\n</code></pre>"},{"location":"AUTH_RLS_MODEL/#11-invariants","title":"11. Invariants","text":"ID Invariant RLS-1 Anonymous requests MUST be rejected for RLS-enabled collections (unless public policy) RLS-2 Users MUST NOT read documents outside their policy scope RLS-3 Users MUST NOT write documents outside their policy scope RLS-4 Service role MUST explicitly bypass RLS (no silent bypass) RLS-5 RLS filter injection MUST be deterministic <p>END OF DOCUMENT</p>"},{"location":"AUTH_SESSION_MODEL/","title":"Phase 8: Session Model","text":"<p>Document Type: Normative Specification Phase: 8 - Authentication &amp; Authorization Status: Active</p>"},{"location":"AUTH_SESSION_MODEL/#overview","title":"Overview","text":"<p>This document specifies the session lifecycle, refresh token mechanism, and TTL management for AeroDB authentication.</p>"},{"location":"AUTH_SESSION_MODEL/#session-lifecycle","title":"Session Lifecycle","text":""},{"location":"AUTH_SESSION_MODEL/#states","title":"States","text":"<pre><code>CREATED \u2192 ACTIVE \u2192 REFRESHED \u2192 EXPIRED/REVOKED\n</code></pre> State Description CREATED Session initialized, tokens issued ACTIVE Valid session, access token usable REFRESHED Access token renewed, refresh token rotated EXPIRED TTL exceeded, requires re-authentication REVOKED Explicitly invalidated (logout, security)"},{"location":"AUTH_SESSION_MODEL/#session-storage","title":"Session Storage","text":""},{"location":"AUTH_SESSION_MODEL/#schema-sessions-collection","title":"Schema: <code>sessions</code> collection","text":"<pre><code>{\n  \"id\": \"uuid\",\n  \"user_id\": \"uuid\",\n  \"refresh_token_hash\": \"string\",\n  \"created_at\": \"datetime\",\n  \"expires_at\": \"datetime\",\n  \"last_refreshed_at\": \"datetime\",\n  \"revoked\": \"boolean\",\n  \"revoked_at\": \"datetime | null\",\n  \"user_agent\": \"string | null\",\n  \"ip_address\": \"string | null\"\n}\n</code></pre>"},{"location":"AUTH_SESSION_MODEL/#storage-invariants","title":"Storage Invariants","text":"<ul> <li>AUTH-S1: Refresh token stored as hash only (never plaintext)</li> <li>AUTH-S2: Session ID is cryptographically random (128-bit)</li> <li>AUTH-S3: One refresh token per session (rotated on use)</li> </ul>"},{"location":"AUTH_SESSION_MODEL/#token-lifetimes","title":"Token Lifetimes","text":"Token Type Default TTL Configurable Max Access Token (JWT) 15 minutes Yes 1 hour Refresh Token 30 days Yes 90 days Session 30 days Yes 90 days"},{"location":"AUTH_SESSION_MODEL/#refresh-token-rotation","title":"Refresh Token Rotation","text":""},{"location":"AUTH_SESSION_MODEL/#single-use-refresh-tokens","title":"Single-Use Refresh Tokens","text":"<p>Each refresh token is single-use. On refresh:</p> <ol> <li>Validate incoming refresh token</li> <li>Invalidate the old refresh token</li> <li>Issue new access token + new refresh token</li> <li>Update session with new refresh token hash</li> </ol>"},{"location":"AUTH_SESSION_MODEL/#rotation-invariants","title":"Rotation Invariants","text":"<ul> <li>AUTH-R1: Reuse of refresh token = session revocation (potential theft)</li> <li>AUTH-R2: New refresh token issued atomically with new access token</li> <li>AUTH-R3: Old refresh token rejected immediately after rotation</li> </ul>"},{"location":"AUTH_SESSION_MODEL/#expiration-handling","title":"Expiration Handling","text":""},{"location":"AUTH_SESSION_MODEL/#explicit-ttl-check","title":"Explicit TTL Check","text":"<p>AeroDB uses explicit TTL checks (no background cleanup):</p> <pre><code>fn is_session_valid(session: &amp;Session) -&gt; bool {\n    !session.revoked &amp;&amp; Utc::now() &lt; session.expires_at\n}\n</code></pre>"},{"location":"AUTH_SESSION_MODEL/#cleanup-strategy","title":"Cleanup Strategy","text":"<ul> <li>Expired sessions remain in DB until explicit cleanup</li> <li>Cleanup via scheduled job or admin action (not implicit)</li> <li>Cleanup is idempotent and safe to run anytime</li> </ul>"},{"location":"AUTH_SESSION_MODEL/#concurrency","title":"Concurrency","text":""},{"location":"AUTH_SESSION_MODEL/#multi-device-sessions","title":"Multi-Device Sessions","text":"<ul> <li>Users may have multiple concurrent sessions</li> <li>Each device gets independent session + refresh token</li> <li>Revoking one session does not affect others</li> </ul>"},{"location":"AUTH_SESSION_MODEL/#race-conditions","title":"Race Conditions","text":"<ul> <li>Concurrent refresh attempts: first wins, others get 401</li> <li>Protected by atomic compare-and-swap on refresh token hash</li> </ul>"},{"location":"AUTH_SESSION_MODEL/#security-considerations","title":"Security Considerations","text":"<ol> <li>Token Binding: Optionally bind tokens to IP/User-Agent</li> <li>Anomaly Detection: Log unusual session patterns</li> <li>Forced Logout: Admin can revoke all user sessions</li> <li>Session Limits: Configurable max sessions per user</li> </ol>"},{"location":"AUTH_TESTING_STRATEGY/","title":"Phase 8: Testing Strategy","text":"<p>Document Type: Normative Specification Phase: 8 - Authentication &amp; Authorization Status: Active</p>"},{"location":"AUTH_TESTING_STRATEGY/#overview","title":"Overview","text":"<p>This document specifies the testing strategy for Phase 8 authentication components.</p>"},{"location":"AUTH_TESTING_STRATEGY/#test-categories","title":"Test Categories","text":""},{"location":"AUTH_TESTING_STRATEGY/#unit-tests","title":"Unit Tests","text":"Component Test File Coverage Target crypto.rs crypto_tests 100% jwt.rs jwt_tests 100% session.rs session_tests 95% user.rs user_tests 95% rls.rs rls_tests 100% api.rs api_tests 90%"},{"location":"AUTH_TESTING_STRATEGY/#integration-tests","title":"Integration Tests","text":"Scenario Location Dependencies Full auth flow tests/auth_integration.rs In-memory DB RLS enforcement tests/rls_integration.rs In-memory DB Token lifecycle tests/token_integration.rs None"},{"location":"AUTH_TESTING_STRATEGY/#critical-test-scenarios","title":"Critical Test Scenarios","text":""},{"location":"AUTH_TESTING_STRATEGY/#authentication","title":"Authentication","text":"<ol> <li>Signup Flow</li> <li>Valid registration succeeds</li> <li>Duplicate email rejected</li> <li>Weak password rejected</li> <li> <p>Email format validated</p> </li> <li> <p>Login Flow</p> </li> <li>Valid credentials return tokens</li> <li>Invalid password returns 401</li> <li>Non-existent user returns 401 (same error)</li> <li> <p>Timing attack protection</p> </li> <li> <p>Token Refresh</p> </li> <li>Valid refresh returns new tokens</li> <li>Expired refresh rejected</li> <li> <p>Reused refresh revokes session</p> </li> <li> <p>Logout</p> </li> <li>Session invalidated</li> <li>Refresh token invalidated</li> <li>Access token still valid until expiry (stateless)</li> </ol>"},{"location":"AUTH_TESTING_STRATEGY/#authorization-rls","title":"Authorization (RLS)","text":"<ol> <li>Read Filtering</li> <li>Users see only owned records</li> <li>Service role sees all records</li> <li> <p>Anonymous denied (fail-closed)</p> </li> <li> <p>Write Validation</p> </li> <li>Users can create owned records</li> <li>Users cannot modify others' records</li> <li> <p>Owner field auto-set on insert</p> </li> <li> <p>Policy Types</p> </li> <li>Ownership policy enforced</li> <li>Public read policy allows anonymous reads</li> <li>Custom policies rejected (not implemented)</li> </ol>"},{"location":"AUTH_TESTING_STRATEGY/#security-tests","title":"Security Tests","text":""},{"location":"AUTH_TESTING_STRATEGY/#invariant-tests","title":"Invariant Tests","text":"Invariant Test AUTH-1 Passwords never logged AUTH-2 Argon2id for password hashing AUTH-3 Constant-time password comparison AUTH-T1 JWT stateless validation AUTH-T4 Expired tokens rejected AUTH-R1 Refresh reuse = revocation"},{"location":"AUTH_TESTING_STRATEGY/#penetration-tests","title":"Penetration Tests","text":"<ol> <li>Timing attacks - Response time constant</li> <li>SQL injection - Parameterized queries</li> <li>Token forgery - Signature validation</li> <li>Session fixation - New session on login</li> </ol>"},{"location":"AUTH_TESTING_STRATEGY/#test-data","title":"Test Data","text":""},{"location":"AUTH_TESTING_STRATEGY/#test-users","title":"Test Users","text":"<pre><code>const TEST_EMAIL: &amp;str = \"test@example.com\";\nconst TEST_PASSWORD: &amp;str = \"ValidP@ssw0rd123\";\nconst WEAK_PASSWORD: &amp;str = \"123\";\n</code></pre>"},{"location":"AUTH_TESTING_STRATEGY/#test-tokens","title":"Test Tokens","text":"<pre><code>// Generated at test time, not hardcoded\nlet (access, refresh) = auth.login(email, password)?;\n</code></pre>"},{"location":"AUTH_TESTING_STRATEGY/#coverage-requirements","title":"Coverage Requirements","text":"Component Minimum Target crypto.rs 100% 100% jwt.rs 95% 100% session.rs 90% 95% user.rs 90% 95% rls.rs 95% 100% api.rs 85% 90% Overall 90% 95%"},{"location":"AUTH_TESTING_STRATEGY/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"AUTH_TESTING_STRATEGY/#pre-merge","title":"Pre-Merge","text":"<pre><code>cargo test auth:: --lib\ncargo test --test auth_integration\n</code></pre>"},{"location":"AUTH_TESTING_STRATEGY/#post-merge","title":"Post-Merge","text":"<pre><code>cargo test --all\ncargo audit\n</code></pre>"},{"location":"AUTH_TESTING_STRATEGY/#security-scan","title":"Security Scan","text":"<p>Weekly automated security scan for: - Dependency vulnerabilities - Credential leaks - Timing attack patterns</p>"},{"location":"AUTH_TOKEN_MODEL/","title":"Phase 8: Token Model","text":"<p>Document Type: Normative Specification Phase: 8 - Authentication &amp; Authorization Status: Active</p>"},{"location":"AUTH_TOKEN_MODEL/#overview","title":"Overview","text":"<p>This document specifies JWT access token design, claims structure, and token rotation for AeroDB authentication.</p>"},{"location":"AUTH_TOKEN_MODEL/#token-types","title":"Token Types","text":"Type Storage Lifetime Purpose Access Token Stateless (JWT) 15 min API authentication Refresh Token Stateful (DB) 30 days Access token renewal API Key Stateful (DB) Unlimited Service authentication"},{"location":"AUTH_TOKEN_MODEL/#jwt-access-token","title":"JWT Access Token","text":""},{"location":"AUTH_TOKEN_MODEL/#algorithm","title":"Algorithm","text":"<ul> <li>Algorithm: HS256 (HMAC-SHA256)</li> <li>Future: RS256 for asymmetric verification</li> </ul>"},{"location":"AUTH_TOKEN_MODEL/#claims-structure","title":"Claims Structure","text":"<pre><code>{\n  \"sub\": \"user-uuid\",\n  \"email\": \"user@example.com\",\n  \"iat\": 1707192000,\n  \"exp\": 1707192900,\n  \"aud\": \"aerodb\",\n  \"iss\": \"aerodb-auth\",\n  \"role\": \"authenticated\"\n}\n</code></pre>"},{"location":"AUTH_TOKEN_MODEL/#standard-claims","title":"Standard Claims","text":"Claim Type Description <code>sub</code> string User ID (UUID) <code>email</code> string User email <code>iat</code> number Issued at (Unix timestamp) <code>exp</code> number Expiration (Unix timestamp) <code>aud</code> string Audience (always \"aerodb\") <code>iss</code> string Issuer (always \"aerodb-auth\") <code>role</code> string User role for RLS"},{"location":"AUTH_TOKEN_MODEL/#custom-claims","title":"Custom Claims","text":"Claim Type Description <code>app_metadata</code> object Server-controlled data <code>user_metadata</code> object User-controlled data"},{"location":"AUTH_TOKEN_MODEL/#token-invariants","title":"Token Invariants","text":"<ul> <li>AUTH-T1: Access tokens are stateless (no DB lookup required)</li> <li>AUTH-T2: Secrets never appear in JWT payload</li> <li>AUTH-T3: JWT signature validated before claims</li> <li>AUTH-T4: Expired tokens rejected without exception</li> <li>AUTH-T5: <code>exp</code> claim is mandatory</li> </ul>"},{"location":"AUTH_TOKEN_MODEL/#token-rotation","title":"Token Rotation","text":""},{"location":"AUTH_TOKEN_MODEL/#access-token-rotation","title":"Access Token Rotation","text":"<pre><code>Client \u2192 Refresh Request \u2192 Server\n        \u2193\n        Validate refresh token (DB lookup)\n        \u2193\n        Issue new access token (stateless)\n        \u2193\n        Issue new refresh token (rotate)\n        \u2193\nClient \u2190 New tokens \u2190 Server\n</code></pre>"},{"location":"AUTH_TOKEN_MODEL/#rotation-rules","title":"Rotation Rules","text":"<ol> <li>New access token issued on every refresh</li> <li>New refresh token issued on every refresh (rotation)</li> <li>Old refresh token invalidated immediately</li> <li>Refresh reuse triggers session revocation</li> </ol>"},{"location":"AUTH_TOKEN_MODEL/#token-validation","title":"Token Validation","text":""},{"location":"AUTH_TOKEN_MODEL/#validation-order","title":"Validation Order","text":"<ol> <li>Parse JWT structure (reject malformed)</li> <li>Validate signature (reject if invalid)</li> <li>Check <code>exp</code> claim (reject if expired)</li> <li>Check <code>iss</code> and <code>aud</code> (reject if mismatch)</li> <li>Extract claims for RLS context</li> </ol>"},{"location":"AUTH_TOKEN_MODEL/#error-responses","title":"Error Responses","text":"Condition HTTP Status Error Malformed token 401 <code>invalid_token</code> Invalid signature 401 <code>invalid_token</code> Expired token 401 <code>token_expired</code> Wrong issuer/audience 401 <code>invalid_token</code>"},{"location":"AUTH_TOKEN_MODEL/#secret-management","title":"Secret Management","text":""},{"location":"AUTH_TOKEN_MODEL/#jwt-secret","title":"JWT Secret","text":"<ul> <li>Generation: Cryptographically random (256-bit minimum)</li> <li>Storage: Environment variable or secrets manager</li> <li>Rotation: Supported via key versioning (future)</li> </ul>"},{"location":"AUTH_TOKEN_MODEL/#secret-invariants","title":"Secret Invariants","text":"<ul> <li>AUTH-K1: Secret never logged or exposed in errors</li> <li>AUTH-K2: Secret rotation does not invalidate existing tokens</li> <li>AUTH-K3: Minimum secret length: 32 bytes</li> </ul>"},{"location":"AUTH_TOKEN_MODEL/#api-key-tokens","title":"API Key Tokens","text":""},{"location":"AUTH_TOKEN_MODEL/#structure","title":"Structure","text":"<pre><code>aero_sk_live_xxxxxxxxxxxxxxxxxxxx\n</code></pre> <ul> <li>Prefix: <code>aero_sk_live_</code> (live) or <code>aero_sk_test_</code> (test)</li> <li>Body: 32 random bytes, base64url encoded</li> </ul>"},{"location":"AUTH_TOKEN_MODEL/#api-key-claims","title":"API Key Claims","text":"<p>API keys map to a special context:</p> <pre><code>RlsContext {\n    user_id: None,\n    is_service_role: true,  // Bypasses RLS\n}\n</code></pre>"},{"location":"AUTH_VISION/","title":"AUTH_VISION.md \u2014 Authentication &amp; Authorization Vision","text":""},{"location":"AUTH_VISION/#status","title":"Status","text":"<ul> <li>Phase: 8</li> <li>Authority: Normative</li> <li>Depends on: Phases 0\u20137 (frozen)</li> <li>Date: 2026-02-06</li> </ul>"},{"location":"AUTH_VISION/#1-purpose","title":"1. Purpose","text":"<p>This document defines the vision, philosophy, and goals for AeroDB's authentication and authorization layer. Phase 8 transforms AeroDB from a database engine into an application backend by adding user authentication and data access control.</p>"},{"location":"AUTH_VISION/#2-core-philosophy","title":"2. Core Philosophy","text":""},{"location":"AUTH_VISION/#21-explicit-over-magic","title":"2.1 Explicit Over Magic","text":"<p>Unlike platforms that auto-provision users or auto-discover OAuth providers, AeroDB authentication is explicit:</p> <ul> <li>User creation requires explicit API calls</li> <li>OAuth providers require explicit configuration</li> <li>No background user cleanup or auto-merge</li> </ul>"},{"location":"AUTH_VISION/#22-fail-closed-security","title":"2.2 Fail-Closed Security","text":"<p>Authentication and authorization follow a fail-closed model:</p> <ul> <li>Invalid credentials \u2192 immediate rejection (no timing leaks)</li> <li>Missing auth context \u2192 request rejected</li> <li>RLS violation \u2192 query fails (never bypasses silently)</li> </ul>"},{"location":"AUTH_VISION/#23-observable-auditable","title":"2.3 Observable &amp; Auditable","text":"<p>All authentication events are logged to the audit trail:</p> <ul> <li>Signup attempts (success/failure)</li> <li>Login attempts (success/failure)</li> <li>Token refresh operations</li> <li>Password changes</li> <li>RLS enforcement decisions</li> </ul>"},{"location":"AUTH_VISION/#24-deterministic-behavior","title":"2.4 Deterministic Behavior","text":"<p>Given identical inputs, authentication produces identical outputs:</p> <ul> <li>Same credentials + same state \u2192 same decision</li> <li>Token validation is stateless (verifiable from token alone)</li> <li>RLS filters produce deterministic query modifications</li> </ul>"},{"location":"AUTH_VISION/#3-goals","title":"3. Goals","text":""},{"location":"AUTH_VISION/#31-user-authentication","title":"3.1 User Authentication","text":"<p>Enable applications to authenticate end users via: - Email + password (primary method) - OAuth 2.0 providers (Google, GitHub, GitLab) - Magic links (passwordless email)</p>"},{"location":"AUTH_VISION/#32-session-management","title":"3.2 Session Management","text":"<p>Provide secure, stateless sessions via: - Short-lived JWT access tokens (15 minutes) - Long-lived refresh tokens (30 days, stored in DB) - Explicit token rotation on refresh</p>"},{"location":"AUTH_VISION/#33-row-level-security-rls","title":"3.3 Row-Level Security (RLS)","text":"<p>Enable fine-grained data access control via: - User context injection at query time - Ownership-based access patterns - Custom RLS policies per collection</p>"},{"location":"AUTH_VISION/#34-api-keys","title":"3.4 API Keys","text":"<p>Enable machine-to-machine authentication via: - Project-level API keys with configurable permissions - Per-key rate limiting and audit logging</p>"},{"location":"AUTH_VISION/#4-non-goals-deferred-to-later-phases","title":"4. Non-Goals (Deferred to Later Phases)","text":"<ul> <li>Multi-factor authentication (MFA)</li> <li>SAML/LDAP enterprise SSO</li> <li>Advanced permission roles (RBAC beyond owner/admin)</li> <li>User impersonation</li> </ul>"},{"location":"AUTH_VISION/#5-philosophy-alignment","title":"5. Philosophy Alignment","text":"AeroDB Principle Phase 8 Alignment Correctness Fail-closed authentication; passwords never logged Determinism Same credentials \u2192 same result; stateless JWT Explicitness No auto-provisioning; explicit user creation Observability All auth events in audit log No Magic No hidden provider discovery or auto-OAuth"},{"location":"AUTH_VISION/#6-success-criteria","title":"6. Success Criteria","text":"<p>Phase 8 is successful when:</p> <ol> <li>Users can sign up, log in, and manage sessions</li> <li>JWTs are verifiable without database lookup</li> <li>RLS enforces data isolation between users</li> <li>All auth operations are auditable</li> <li>No Phase 0-7 behavior is modified</li> </ol> <p>END OF DOCUMENT</p>"},{"location":"AUTO_API_ARCHITECTURE/","title":"Phase 9: REST API Architecture","text":"<p>Document Type: Technical Architecture Phase: 9 - Auto-Generated REST API Status: Active</p>"},{"location":"AUTO_API_ARCHITECTURE/#overview","title":"Overview","text":"<p>AeroREST is a PostgREST-inspired REST API layer that auto-generates endpoints from AeroDB schemas.</p>"},{"location":"AUTO_API_ARCHITECTURE/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     HTTP Request                                 \u2502\n\u2502              GET /rest/v1/posts?limit=10                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     RestServer (Axum)                            \u2502\n\u2502  - Route matching                                                \u2502\n\u2502  - JWT extraction \u2192 RlsContext                                   \u2502\n\u2502  - Service role detection                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     QueryParser                                  \u2502\n\u2502  - Parse query params                                            \u2502\n\u2502  - Build FilterSet                                               \u2502\n\u2502  - Extract pagination                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     RestHandler                                  \u2502\n\u2502  - Apply RLS filter                                              \u2502\n\u2502  - Execute CRUD operation                                        \u2502\n\u2502  - Format response                                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     AeroDB Executor                              \u2502\n\u2502  - Query planning                                                \u2502\n\u2502  - MVCC read/write                                               \u2502\n\u2502  - WAL logging                                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"AUTO_API_ARCHITECTURE/#module-structure","title":"Module Structure","text":"<pre><code>src/rest_api/\n\u251c\u2500\u2500 mod.rs           # Module entry, exports\n\u251c\u2500\u2500 errors.rs        # HTTP error codes\n\u251c\u2500\u2500 parser.rs        # Query parameter parsing\n\u251c\u2500\u2500 filter.rs        # Filter expression AST\n\u251c\u2500\u2500 response.rs      # JSON response formatting\n\u251c\u2500\u2500 handler.rs       # CRUD operations + RLS\n\u251c\u2500\u2500 server.rs        # Axum HTTP server\n\u2514\u2500\u2500 generator.rs     # Schema \u2192 endpoint mapping\n</code></pre>"},{"location":"AUTO_API_ARCHITECTURE/#request-flow","title":"Request Flow","text":"<ol> <li>Route Match: <code>/rest/v1/{collection}</code> \u2192 handler</li> <li>Auth Extract: JWT \u2192 RlsContext</li> <li>Parse Query: Query params \u2192 QueryParams</li> <li>Apply RLS: Inject ownership filter</li> <li>Execute: CRUD via handler</li> <li>Format: Records \u2192 JSON response</li> </ol>"},{"location":"AUTO_API_ARCHITECTURE/#integration-points","title":"Integration Points","text":"Component Integration Auth (Phase 8) JWT validation, RlsContext Planner Query bounds checking Executor CRUD operations WAL Write durability"},{"location":"AUTO_API_FAILURE_MODEL/","title":"Phase 9: Failure Model","text":"<p>Document Type: Technical Specification Phase: 9 - Auto-Generated REST API Status: Active</p>"},{"location":"AUTO_API_FAILURE_MODEL/#overview","title":"Overview","text":"<p>This document specifies HTTP error mapping for REST API failures.</p>"},{"location":"AUTO_API_FAILURE_MODEL/#error-mapping","title":"Error Mapping","text":""},{"location":"AUTO_API_FAILURE_MODEL/#client-errors-4xx","title":"Client Errors (4xx)","text":"Error HTTP Code When Invalid query param 400 <code>invalid_query_param</code> Bad syntax Limit exceeded 400 <code>limit_exceeded</code> limit &gt; 1000 Invalid filter value 400 <code>invalid_filter</code> Type mismatch Missing auth 401 <code>authentication_required</code> No token Invalid token 401 <code>invalid_token</code> Bad JWT Token expired 401 <code>token_expired</code> JWT expired RLS violation 403 <code>access_denied</code> Not authorized Not found 404 <code>not_found</code> No record Validation error 422 <code>validation_error</code> Schema violation"},{"location":"AUTO_API_FAILURE_MODEL/#server-errors-5xx","title":"Server Errors (5xx)","text":"Error HTTP Code When Internal error 500 <code>internal_error</code> Unexpected DB unavailable 503 <code>service_unavailable</code> Connection fail"},{"location":"AUTO_API_FAILURE_MODEL/#error-response-format","title":"Error Response Format","text":"<pre><code>{\n  \"error\": {\n    \"code\": \"invalid_query_param\",\n    \"message\": \"Invalid limit value: must be a number\",\n    \"status\": 400,\n    \"details\": {\n      \"param\": \"limit\",\n      \"value\": \"abc\"\n    }\n  }\n}\n</code></pre>"},{"location":"AUTO_API_FAILURE_MODEL/#error-logging","title":"Error Logging","text":"<p>All 4xx/5xx responses logged with: - Request ID - Endpoint - Error code - User ID (if authenticated) - Response time</p>"},{"location":"AUTO_API_FAILURE_MODEL/#determinism","title":"Determinism","text":"<p>Error responses are deterministic: - Same invalid input \u2192 Same error code - No randomized error messages</p>"},{"location":"AUTO_API_INVARIANTS/","title":"Phase 9: REST API Invariants","text":"<p>Document Type: Normative Specification Phase: 9 - Auto-Generated REST API Status: Active</p>"},{"location":"AUTO_API_INVARIANTS/#query-invariants","title":"Query Invariants","text":""},{"location":"AUTO_API_INVARIANTS/#rest-q1-bounded-queries","title":"REST-Q1: Bounded Queries","text":"<p>All queries MUST have a limit. Unbounded queries are rejected with 400.</p> <pre><code>if params.limit == 0 || params.limit &gt; MAX_LIMIT {\n    return Err(RestError::LimitExceeded);\n}\n</code></pre>"},{"location":"AUTO_API_INVARIANTS/#rest-q2-deterministic-results","title":"REST-Q2: Deterministic Results","text":"<p>Same query params + same data \u2192 Same JSON response.</p> <p>Ordering is stable. If no <code>order</code> specified, results ordered by primary key.</p>"},{"location":"AUTO_API_INVARIANTS/#rest-q3-no-guessing","title":"REST-Q3: No Guessing","text":"<p>Invalid query syntax returns 400, not best-effort interpretation.</p> <pre><code>?age=gt.abc  \u2192 400 (invalid number)\n?status=unknown.value \u2192 400 (unknown operator)\n</code></pre>"},{"location":"AUTO_API_INVARIANTS/#security-invariants","title":"Security Invariants","text":""},{"location":"AUTO_API_INVARIANTS/#rest-s1-rls-enforcement","title":"REST-S1: RLS Enforcement","text":"<p>RLS filters are applied BEFORE query execution, not after.</p> <p>Filter injection happens in handler, before any data access.</p>"},{"location":"AUTO_API_INVARIANTS/#rest-s2-no-silent-bypass","title":"REST-S2: No Silent Bypass","text":"<p>Missing auth \u2192 401, not anonymous access.</p> <pre><code>if context.user_id.is_none() &amp;&amp; !context.is_service_role {\n    return Err(RestError::AuthenticationRequired);\n}\n</code></pre>"},{"location":"AUTO_API_INVARIANTS/#rest-s3-service-role-explicit","title":"REST-S3: Service Role Explicit","text":"<p>Service role requires explicit header, not just valid JWT.</p> <pre><code>Authorization: Bearer &lt;jwt&gt;\nX-Service-Role: true\n</code></pre>"},{"location":"AUTO_API_INVARIANTS/#response-invariants","title":"Response Invariants","text":""},{"location":"AUTO_API_INVARIANTS/#rest-r1-consistent-structure","title":"REST-R1: Consistent Structure","text":"<p>All list responses have same shape.</p> <pre><code>{\n  \"data\": [...],\n  \"count\": 10,\n  \"limit\": 20,\n  \"offset\": 0\n}\n</code></pre>"},{"location":"AUTO_API_INVARIANTS/#rest-r2-error-structure","title":"REST-R2: Error Structure","text":"<p>All errors have same shape.</p> <pre><code>{\n  \"error\": {\n    \"code\": \"string\",\n    \"message\": \"string\",\n    \"status\": 400\n  }\n}\n</code></pre>"},{"location":"AUTO_API_INVARIANTS/#performance-invariants","title":"Performance Invariants","text":""},{"location":"AUTO_API_INVARIANTS/#rest-p1-no-n1-queries","title":"REST-P1: No N+1 Queries","text":"<p>Relations (when implemented) use batch loading.</p>"},{"location":"AUTO_API_INVARIANTS/#rest-p2-index-hints","title":"REST-P2: Index Hints","text":"<p>Filter fields should have indexes for performance.</p> <p>Warning logged if filtering on non-indexed field.</p>"},{"location":"AUTO_API_OBSERVABILITY_MAPPING/","title":"Phase 9: Observability Mapping","text":"<p>Document Type: Technical Specification Phase: 9 - Auto-Generated REST API Status: Active</p>"},{"location":"AUTO_API_OBSERVABILITY_MAPPING/#metrics","title":"Metrics","text":""},{"location":"AUTO_API_OBSERVABILITY_MAPPING/#counters","title":"Counters","text":"<pre><code>aerodb_rest_requests_total{method, collection, status}\naerodb_rest_errors_total{error_code}\naerodb_rls_filter_applied_total{collection}\n</code></pre>"},{"location":"AUTO_API_OBSERVABILITY_MAPPING/#histograms","title":"Histograms","text":"<pre><code>aerodb_rest_request_duration_seconds{method, collection}\naerodb_rest_response_size_bytes{method, collection}\n</code></pre>"},{"location":"AUTO_API_OBSERVABILITY_MAPPING/#logging","title":"Logging","text":""},{"location":"AUTO_API_OBSERVABILITY_MAPPING/#request-log","title":"Request Log","text":"<pre><code>{\n  \"timestamp\": \"2026-02-06T00:00:00Z\",\n  \"level\": \"INFO\",\n  \"event\": \"rest.request\",\n  \"method\": \"GET\",\n  \"path\": \"/rest/v1/posts\",\n  \"collection\": \"posts\",\n  \"user_id\": \"uuid\",\n  \"query_params\": {\"limit\": \"10\"},\n  \"duration_ms\": 45,\n  \"status\": 200,\n  \"response_count\": 10\n}\n</code></pre>"},{"location":"AUTO_API_OBSERVABILITY_MAPPING/#error-log","title":"Error Log","text":"<pre><code>{\n  \"timestamp\": \"2026-02-06T00:00:00Z\",\n  \"level\": \"WARN\",\n  \"event\": \"rest.error\",\n  \"error_code\": \"invalid_query_param\",\n  \"path\": \"/rest/v1/posts\",\n  \"status\": 400\n}\n</code></pre>"},{"location":"AUTO_API_OBSERVABILITY_MAPPING/#tracing","title":"Tracing","text":""},{"location":"AUTO_API_OBSERVABILITY_MAPPING/#span-restrequest","title":"Span: rest.request","text":"<pre><code>rest.request (parent)\n\u251c\u2500\u2500 rest.parse_query\n\u251c\u2500\u2500 rest.auth_extract\n\u251c\u2500\u2500 rest.rls_filter\n\u251c\u2500\u2500 rest.execute\n\u2514\u2500\u2500 rest.format_response\n</code></pre>"},{"location":"AUTO_API_OBSERVABILITY_MAPPING/#dashboards","title":"Dashboards","text":"<ol> <li>Request Rate (per minute)</li> <li>Error Rate (4xx/5xx)</li> <li>Latency P50/P95/P99</li> <li>Top Collections by Request</li> <li>RLS Denials</li> </ol>"},{"location":"AUTO_API_QUERY_MODEL/","title":"Phase 9: Query Model","text":"<p>Document Type: Technical Specification Phase: 9 - Auto-Generated REST API Status: Active</p>"},{"location":"AUTO_API_QUERY_MODEL/#overview","title":"Overview","text":"<p>This document specifies how REST query parameters translate to AeroDB AST.</p>"},{"location":"AUTO_API_QUERY_MODEL/#query-parameter-syntax","title":"Query Parameter Syntax","text":""},{"location":"AUTO_API_QUERY_MODEL/#filtering","title":"Filtering","text":"Syntax Operator Example <code>field=eq.value</code> Equals <code>status=eq.active</code> <code>field=neq.value</code> Not equals <code>status=neq.deleted</code> <code>field=gt.value</code> Greater than <code>age=gt.18</code> <code>field=gte.value</code> Greater or equal <code>age=gte.18</code> <code>field=lt.value</code> Less than <code>price=lt.100</code> <code>field=lte.value</code> Less or equal <code>price=lte.100</code> <code>field=like.pattern</code> Pattern match <code>name=like.*son</code> <code>field=in.(a,b,c)</code> In list <code>status=in.(active,pending)</code> <code>field=is.null</code> Is null <code>deleted_at=is.null</code>"},{"location":"AUTO_API_QUERY_MODEL/#sorting","title":"Sorting","text":"<pre><code>?order=field.asc\n?order=field.desc\n?order=created_at.desc,name.asc\n</code></pre>"},{"location":"AUTO_API_QUERY_MODEL/#pagination","title":"Pagination","text":"<pre><code>?limit=20\n?offset=40\n</code></pre>"},{"location":"AUTO_API_QUERY_MODEL/#field-selection","title":"Field Selection","text":"<pre><code>?select=id,name,email\n?select=*\n</code></pre>"},{"location":"AUTO_API_QUERY_MODEL/#translation-pipeline","title":"Translation Pipeline","text":"<pre><code>Query String \u2192 QueryParams \u2192 FilterSet \u2192 AeroDB AST\n</code></pre>"},{"location":"AUTO_API_QUERY_MODEL/#example","title":"Example","text":"<pre><code>GET /rest/v1/posts?author_id=eq.123&amp;status=in.(draft,published)&amp;order=created_at.desc&amp;limit=10\n</code></pre> <p>Translates to:</p> <pre><code>QueryParams {\n    select: None,  // All fields\n    filters: vec![\n        FilterExpr { field: \"author_id\", op: Eq, value: \"123\" },\n        FilterExpr { field: \"status\", op: In, value: [\"draft\", \"published\"] },\n    ],\n    order: vec![\n        OrderBy { field: \"created_at\", ascending: false },\n    ],\n    limit: 10,\n    offset: 0,\n}\n</code></pre>"},{"location":"AUTO_API_QUERY_MODEL/#bounds-enforcement","title":"Bounds Enforcement","text":""},{"location":"AUTO_API_QUERY_MODEL/#invariant-q1-all-queries-must-be-bounded","title":"Invariant Q1: All queries must be bounded","text":"Condition Action No limit specified Apply DEFAULT_LIMIT (100) Limit &gt; MAX_LIMIT (1000) Return 400 error Limit = 0 Return empty result"},{"location":"AUTO_API_QUERY_MODEL/#rls-filter-injection","title":"RLS Filter Injection","text":"<p>Before query execution, RLS filter is injected:</p> <pre><code>// Original filters\nfilters: [status=eq.active]\n\n// After RLS injection (ownership policy)\nfilters: [status=eq.active, owner_id=eq.{user_id}]\n</code></pre> <p>This is transparent to the client.</p>"},{"location":"AUTO_API_READINESS/","title":"Phase 9: Readiness Checklist","text":"<p>Document Type: Freeze Criteria Phase: 9 - Auto-Generated REST API Status: In Progress</p>"},{"location":"AUTO_API_READINESS/#documentation","title":"Documentation","text":"Document Status AUTO_API_REST_SPEC.md \u2705 AUTO_API_VISION.md \u2705 AUTO_API_ARCHITECTURE.md \u2705 AUTO_API_QUERY_MODEL.md \u2705 AUTO_API_SCHEMA_MODEL.md \u2705 AUTO_API_RELATION_MODEL.md \u2705 AUTO_API_INVARIANTS.md \u2705 AUTO_API_FAILURE_MODEL.md \u2705 AUTO_API_OBSERVABILITY_MAPPING.md \u2705 AUTO_API_READINESS.md \u2705"},{"location":"AUTO_API_READINESS/#implementation","title":"Implementation","text":"Module Status Tests mod.rs \u2705 N/A errors.rs \u2705 \u2705 parser.rs \u2705 \u2705 filter.rs \u2705 \u2705 response.rs \u2705 \u2705 handler.rs \u2705 \u2705 server.rs \u2705 \u2705 generator.rs \u2610 Deferred \u2610"},{"location":"AUTO_API_READINESS/#tests","title":"Tests","text":"Type Count Passing Unit 22 \u2705 22 Integration 0 \u2610"},{"location":"AUTO_API_READINESS/#deferred-items","title":"Deferred Items","text":"Item Reason Schema introspection Requires executor integration Relations Complex, low priority Integration tests Requires full stack"},{"location":"AUTO_API_READINESS/#freeze-status","title":"Freeze Status","text":"<p>Status: PARTIAL READY</p> <p>Core implementation complete. Schema introspection deferred.</p>"},{"location":"AUTO_API_RELATION_MODEL/","title":"Phase 9: Relation Model","text":"<p>Document Type: Technical Specification Phase: 9 - Auto-Generated REST API Status: Deferred</p>"},{"location":"AUTO_API_RELATION_MODEL/#overview","title":"Overview","text":"<p>This document specifies foreign key expansion and embedded relations (future feature).</p>"},{"location":"AUTO_API_RELATION_MODEL/#relation-types","title":"Relation Types","text":""},{"location":"AUTO_API_RELATION_MODEL/#embedded-relations","title":"Embedded Relations","text":"<pre><code>GET /rest/v1/posts?select=*,author(*)\n</code></pre> <p>Returns:</p> <pre><code>{\n  \"id\": \"post-1\",\n  \"title\": \"Hello\",\n  \"author\": {\n    \"id\": \"user-1\",\n    \"name\": \"Alice\"\n  }\n}\n</code></pre>"},{"location":"AUTO_API_RELATION_MODEL/#many-to-one","title":"Many-to-One","text":"<pre><code>posts.author_id \u2192 users.id\n</code></pre>"},{"location":"AUTO_API_RELATION_MODEL/#one-to-many","title":"One-to-Many","text":"<pre><code>users.id \u2190 posts.author_id\n</code></pre>"},{"location":"AUTO_API_RELATION_MODEL/#syntax","title":"Syntax","text":""},{"location":"AUTO_API_RELATION_MODEL/#select-with-relations","title":"Select with Relations","text":"<pre><code>?select=*,author(id,name)\n?select=*,author(*),comments(*)\n</code></pre>"},{"location":"AUTO_API_RELATION_MODEL/#nested-relations","title":"Nested Relations","text":"<pre><code>?select=*,author(id,company(*))\n</code></pre>"},{"location":"AUTO_API_RELATION_MODEL/#implementation-status","title":"Implementation Status","text":"<p>Status: DEFERRED</p> <p>This feature requires: 1. Foreign key metadata in schemas 2. Query planning for joins 3. N+1 query prevention</p> <p>Will be implemented in future iteration.</p>"},{"location":"AUTO_API_RELATION_MODEL/#current-behavior","title":"Current Behavior","text":"<p>Relations in select are ignored silently.</p> <pre><code>?select=*,author(*)\n# Returns: * fields only, author ignored\n</code></pre>"},{"location":"AUTO_API_REST_SPEC/","title":"AUTO_API_REST_SPEC.md \u2014 REST API Generator Specification","text":""},{"location":"AUTO_API_REST_SPEC/#status","title":"Status","text":"<ul> <li>Phase: 9</li> <li>Authority: Normative</li> <li>Depends on: Phase 8 (Authentication &amp; RLS)</li> <li>Date: 2026-02-06</li> </ul>"},{"location":"AUTO_API_REST_SPEC/#1-purpose","title":"1. Purpose","text":"<p>This document defines the specification for AeroDB's auto-generated REST API layer, which provides CRUD operations for all collections based on their schemas.</p>"},{"location":"AUTO_API_REST_SPEC/#2-design-philosophy","title":"2. Design Philosophy","text":""},{"location":"AUTO_API_REST_SPEC/#21-schema-driven","title":"2.1 Schema-Driven","text":"<p>REST endpoints are generated from schema definitions: - No manual endpoint registration required - Schema changes automatically update available endpoints - Explicit reload required (no auto-watch)</p>"},{"location":"AUTO_API_REST_SPEC/#22-deterministic-query-translation","title":"2.2 Deterministic Query Translation","text":"<p>REST queries translate to AeroDB operations deterministically: - Same URL + query params \u2192 same AeroDB query - No hidden optimization or caching - Bounded queries enforced (no unbounded scans)</p>"},{"location":"AUTO_API_REST_SPEC/#23-rls-integration","title":"2.3 RLS Integration","text":"<p>All REST endpoints enforce Row-Level Security: - Authenticated requests carry RLS context - Filters are injected before execution - Service role can bypass RLS</p>"},{"location":"AUTO_API_REST_SPEC/#3-endpoint-structure","title":"3. Endpoint Structure","text":""},{"location":"AUTO_API_REST_SPEC/#31-collection-endpoints","title":"3.1 Collection Endpoints","text":"<p>For each collection <code>{collection}</code>:</p> Method Path Description GET <code>/rest/v1/{collection}</code> List records (with filters) GET <code>/rest/v1/{collection}/{id}</code> Get single record POST <code>/rest/v1/{collection}</code> Insert record(s) PATCH <code>/rest/v1/{collection}/{id}</code> Update record DELETE <code>/rest/v1/{collection}/{id}</code> Delete record"},{"location":"AUTO_API_REST_SPEC/#32-authentication","title":"3.2 Authentication","text":"<p>All endpoints require authentication via: - <code>Authorization: Bearer &lt;access_token&gt;</code> header - <code>apikey: &lt;api_key&gt;</code> header (for service role)</p>"},{"location":"AUTO_API_REST_SPEC/#4-query-parameters","title":"4. Query Parameters","text":""},{"location":"AUTO_API_REST_SPEC/#41-filtering","title":"4.1 Filtering","text":"Operator Syntax Description eq <code>?field=eq.value</code> Equals neq <code>?field=neq.value</code> Not equals gt <code>?field=gt.10</code> Greater than gte <code>?field=gte.10</code> Greater than or equal lt <code>?field=lt.10</code> Less than lte <code>?field=lte.10</code> Less than or equal like <code>?field=like.*pattern*</code> Pattern match in <code>?field=in.(a,b,c)</code> In list"},{"location":"AUTO_API_REST_SPEC/#42-sorting","title":"4.2 Sorting","text":"<pre><code>?order=field.asc\n?order=field.desc\n?order=field1.asc,field2.desc\n</code></pre>"},{"location":"AUTO_API_REST_SPEC/#43-pagination","title":"4.3 Pagination","text":"<pre><code>?limit=20\n?offset=0\n</code></pre> <p>Default limit: 100 Maximum limit: 1000</p>"},{"location":"AUTO_API_REST_SPEC/#44-field-selection","title":"4.4 Field Selection","text":"<pre><code>?select=id,name,email\n?select=*  (all fields)\n</code></pre>"},{"location":"AUTO_API_REST_SPEC/#5-requestresponse-format","title":"5. Request/Response Format","text":""},{"location":"AUTO_API_REST_SPEC/#51-list-response","title":"5.1 List Response","text":"<pre><code>{\n  \"data\": [...],\n  \"count\": 42,\n  \"limit\": 20,\n  \"offset\": 0\n}\n</code></pre>"},{"location":"AUTO_API_REST_SPEC/#52-single-record-response","title":"5.2 Single Record Response","text":"<pre><code>{\n  \"data\": { ... }\n}\n</code></pre>"},{"location":"AUTO_API_REST_SPEC/#53-insert-request","title":"5.3 Insert Request","text":"<pre><code>{\n  \"field1\": \"value1\",\n  \"field2\": \"value2\"\n}\n</code></pre> <p>Or batch insert: <pre><code>[\n  { \"field1\": \"value1\" },\n  { \"field1\": \"value2\" }\n]\n</code></pre></p>"},{"location":"AUTO_API_REST_SPEC/#54-error-response","title":"5.4 Error Response","text":"<pre><code>{\n  \"error\": \"Description of error\",\n  \"code\": 400\n}\n</code></pre>"},{"location":"AUTO_API_REST_SPEC/#6-http-status-codes","title":"6. HTTP Status Codes","text":"Code Description 200 Success 201 Created 400 Bad request (invalid query) 401 Unauthorized (missing/invalid auth) 403 Forbidden (RLS violation) 404 Not found 409 Conflict (duplicate key) 500 Internal error"},{"location":"AUTO_API_REST_SPEC/#7-module-structure","title":"7. Module Structure","text":"<pre><code>src/rest_api/\n\u251c\u2500\u2500 mod.rs           # Module exports\n\u251c\u2500\u2500 server.rs        # HTTP server setup (axum)\n\u251c\u2500\u2500 generator.rs     # Schema \u2192 endpoint mapping\n\u251c\u2500\u2500 parser.rs        # Query parameter parsing\n\u251c\u2500\u2500 filter.rs        # Filter AST generation\n\u251c\u2500\u2500 handler.rs       # Request handlers\n\u251c\u2500\u2500 response.rs      # Response formatting\n\u2514\u2500\u2500 errors.rs        # HTTP error types\n</code></pre>"},{"location":"AUTO_API_REST_SPEC/#8-invariants","title":"8. Invariants","text":"ID Invariant REST-1 Unbounded queries MUST be rejected (limit required) REST-2 RLS MUST be enforced on all operations REST-3 Query translation MUST be deterministic REST-4 Schema changes require explicit reload REST-5 All errors MUST map to appropriate HTTP codes <p>END OF DOCUMENT</p>"},{"location":"AUTO_API_SCHEMA_MODEL/","title":"Phase 9: Schema Model","text":"<p>Document Type: Technical Specification Phase: 9 - Auto-Generated REST API Status: Active</p>"},{"location":"AUTO_API_SCHEMA_MODEL/#overview","title":"Overview","text":"<p>This document specifies how schema introspection generates REST endpoints.</p>"},{"location":"AUTO_API_SCHEMA_MODEL/#schema-introspection","title":"Schema Introspection","text":""},{"location":"AUTO_API_SCHEMA_MODEL/#source","title":"Source","text":"<p>Schemas read from AeroDB <code>schemas</code> collection at startup.</p>"},{"location":"AUTO_API_SCHEMA_MODEL/#schema-structure","title":"Schema Structure","text":"<pre><code>{\n  \"name\": \"posts\",\n  \"fields\": [\n    { \"name\": \"id\", \"type\": \"uuid\", \"primary\": true },\n    { \"name\": \"title\", \"type\": \"string\", \"required\": true },\n    { \"name\": \"author_id\", \"type\": \"uuid\", \"required\": true },\n    { \"name\": \"created_at\", \"type\": \"datetime\" }\n  ],\n  \"rls_policy\": {\n    \"type\": \"ownership\",\n    \"owner_field\": \"author_id\"\n  }\n}\n</code></pre>"},{"location":"AUTO_API_SCHEMA_MODEL/#endpoint-generation","title":"Endpoint Generation","text":""},{"location":"AUTO_API_SCHEMA_MODEL/#per-schema-endpoints","title":"Per-Schema Endpoints","text":"<p>For schema <code>posts</code>:</p> Method Endpoint Handler GET <code>/rest/v1/posts</code> list GET <code>/rest/v1/posts/{id}</code> get POST <code>/rest/v1/posts</code> insert PATCH <code>/rest/v1/posts/{id}</code> update DELETE <code>/rest/v1/posts/{id}</code> delete"},{"location":"AUTO_API_SCHEMA_MODEL/#endpoint-registry","title":"Endpoint Registry","text":"<pre><code>pub struct EndpointRegistry {\n    endpoints: HashMap&lt;String, SchemaEndpoint&gt;,\n}\n\npub struct SchemaEndpoint {\n    collection: String,\n    fields: Vec&lt;FieldDef&gt;,\n    rls_policy: RlsPolicy,\n}\n</code></pre>"},{"location":"AUTO_API_SCHEMA_MODEL/#reload-strategy","title":"Reload Strategy","text":""},{"location":"AUTO_API_SCHEMA_MODEL/#explicit-reload-no-auto-watch","title":"Explicit Reload (No Auto-Watch)","text":"<pre><code>POST /admin/reload-schemas\n</code></pre> <p>Triggers: 1. Re-read schemas from DB 2. Rebuild endpoint registry 3. Return success/failure</p>"},{"location":"AUTO_API_SCHEMA_MODEL/#invariant","title":"Invariant","text":"<p>Schema changes do NOT auto-apply. Explicit reload required.</p>"},{"location":"AUTO_API_SCHEMA_MODEL/#validation","title":"Validation","text":""},{"location":"AUTO_API_SCHEMA_MODEL/#field-type-validation","title":"Field Type Validation","text":"Type JSON Type Validation uuid string UUID format string string Max length number number Range boolean boolean - datetime string ISO 8601 json object/array Valid JSON"},{"location":"AUTO_API_SCHEMA_MODEL/#required-fields","title":"Required Fields","text":"<p>On insert, required fields must be present or error 400.</p>"},{"location":"AUTO_API_VISION/","title":"Phase 9: REST API Vision","text":"<p>Document Type: Vision Statement Phase: 9 - Auto-Generated REST API Status: Active</p>"},{"location":"AUTO_API_VISION/#goal","title":"Goal","text":"<p>Provide automatic REST API generation from database schema, inspired by PostgREST, while preserving AeroDB's determinism and explicit control principles.</p>"},{"location":"AUTO_API_VISION/#philosophy","title":"Philosophy","text":""},{"location":"AUTO_API_VISION/#core-principles","title":"Core Principles","text":"<ol> <li>Schema-Driven: API endpoints derived from schema, not hand-coded</li> <li>Deterministic: Same query params \u2192 Same results</li> <li>Bounded: All queries must be bounded (no unbounded scans)</li> <li>Secure: RLS enforcement at query level, not middleware</li> <li>Explicit: No hidden magic, predictable behavior</li> </ol>"},{"location":"AUTO_API_VISION/#non-goals","title":"Non-Goals","text":"<ul> <li>GraphQL (Phase 17+)</li> <li>Auto-migrations on schema change</li> <li>Automatic relationship detection</li> </ul>"},{"location":"AUTO_API_VISION/#target-experience","title":"Target Experience","text":"<pre><code># After creating a schema, REST endpoints are available immediately\nPOST /rest/v1/posts\nGET /rest/v1/posts?author_id=eq.123&amp;order=created_at.desc&amp;limit=10\n</code></pre>"},{"location":"AUTO_API_VISION/#success-criteria","title":"Success Criteria","text":"<ol> <li>Zero-config REST API from any schema</li> <li>Full CRUD operations</li> <li>PostgREST-compatible query syntax</li> <li>RLS enforcement on all endpoints</li> <li>&lt;10ms overhead vs direct queries</li> </ol>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to AeroDB will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#010-2026-01-20","title":"0.1.0 - 2026-01-20","text":""},{"location":"CHANGELOG/#added","title":"Added","text":""},{"location":"CHANGELOG/#backend","title":"Backend","text":"<ul> <li>MVCC Transaction System with snapshot isolation</li> <li>Write-Ahead Logging (WAL) for crash-safe durability</li> <li>Deterministic recovery</li> <li>Checksum validation</li> <li>Fsync-based durability guarantees</li> <li>Point-in-Time Snapshots with tar-based archiving</li> <li>Replication &amp; Failover</li> <li>Leader-follower replication</li> <li>Atomic promotion with durable markers</li> <li>WAL streaming</li> <li>Authentication &amp; Authorization</li> <li>JWT-based session management</li> <li>Argon2 password hashing</li> <li>Password reset workflow</li> <li>Configurable password policies</li> <li>RESTful HTTP API with comprehensive endpoints</li> <li>Database operations (<code>/api/*</code>)</li> <li>Auth management (<code>/auth/*</code>)</li> <li>Storage operations (<code>/storage/*</code>)</li> <li>Function invocation (<code>/functions/*</code>)</li> <li>Real-time subscriptions (<code>/realtime/*</code>)</li> <li>Backup/restore (<code>/backup/*</code>)</li> <li>Cluster management (<code>/cluster/*</code>)</li> <li>Real-time Subscriptions via WebSocket</li> <li>Collection-level subscriptions</li> <li>Live data streaming</li> <li>Presence tracking</li> <li>File Storage Service</li> <li>S3-compatible API</li> <li>Signed URL generation</li> <li>Bucket management</li> <li>Metadata storage</li> <li>Serverless Functions</li> <li>WASM-based runtime (Wasmtime)</li> <li>HTTP trigger support</li> <li>Cron scheduling</li> <li>Function versioning</li> <li>Observability</li> <li>Query execution metrics</li> <li>System health endpoints</li> <li>Structured logging</li> <li>Query explanation</li> <li>Setup Wizard (<code>/setup/*</code>)</li> <li>First-run initialization</li> <li>Storage configuration</li> <li>Auth settings</li> <li>Admin user creation</li> </ul>"},{"location":"CHANGELOG/#frontend-admin-dashboard","title":"Frontend (Admin Dashboard)","text":"<ul> <li>Vue.js 3 + TypeScript modern single-page application</li> <li>Setup Wizard (WordPress-style)</li> <li>6-step guided initialization</li> <li>Configuration validation</li> <li>One-time setup enforcement</li> <li>Database Management</li> <li>Table browser with pagination</li> <li>SQL console with syntax highlighting</li> <li>Schema viewer</li> <li>User &amp; Auth Management</li> <li>User CRUD operations</li> <li>Role and permission management</li> <li>Password reset interface</li> <li>Storage Browser</li> <li>File upload/download</li> <li>Bucket management</li> <li>Signed URL generation</li> <li>Real-time Monitoring</li> <li>Live metrics dashboard</li> <li>System health indicators</li> <li>Active connections view</li> <li>Functions Management</li> <li>Function editor</li> <li>Deployment interface</li> <li>Logs viewer</li> <li>Scheduling configuration</li> <li>Backup &amp; Restore</li> <li>Snapshot creation</li> <li>Point-in-time recovery</li> <li>Backup history</li> <li>Cluster Dashboard</li> <li>Replication status</li> <li>Failover controls</li> <li>Topology visualization</li> </ul>"},{"location":"CHANGELOG/#documentation","title":"Documentation","text":"<ul> <li>Comprehensive specification documents</li> <li>164 detailed spec files in <code>docs/</code></li> <li>Phase-based architecture documentation (Phases 0-16)</li> <li>MVCC, WAL, Replication, Performance specs</li> <li>Implementation guides</li> <li>Test suite with 26 integration tests</li> <li>Crash safety tests</li> <li>MVCC invariant tests</li> <li>Replication authority tests</li> <li>Storage integrity tests</li> </ul>"},{"location":"CHANGELOG/#security","title":"Security","text":"<ul> <li>Argon2 password hashing with secure defaults</li> <li>JWT with configurable expiration</li> <li>CORS protection</li> <li>SQL injection prevention (prepared statements)</li> <li>XSS protection in dashboard</li> <li>Signed URLs for storage access</li> </ul>"},{"location":"CHANGELOG/#performance","title":"Performance","text":"<ul> <li>Async I/O with Tokio</li> <li>Connection pooling</li> <li>Optimized WAL batching</li> <li>Memory-mapped file support (foundation)</li> </ul>"},{"location":"CHANGELOG/#testing","title":"Testing","text":"<ul> <li>26 integration tests</li> <li>Crash simulation framework</li> <li>MVCC invariant verification</li> <li>Frontend unit tests with Vitest</li> <li>E2E tests with Playwright</li> </ul>"},{"location":"CHANGELOG/#dependencies","title":"Dependencies","text":"<ul> <li>Backend: Rust 1.70+, Axum, Tokio, Serde, Argon2, JWT, Wasmtime</li> <li>Frontend: Vue 3, Pinia, Vue Router, Axios, Tailwind CSS 4, Vite</li> </ul>"},{"location":"CHANGELOG/#release-notes-format","title":"Release Notes Format","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<p>New features</p>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<p>Changes in existing functionality</p>"},{"location":"CHANGELOG/#deprecated","title":"Deprecated","text":"<p>Soon-to-be removed features</p>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<p>Removed features</p>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<p>Bug fixes</p>"},{"location":"CHANGELOG/#security_1","title":"Security","text":"<p>Vulnerability fixes</p>"},{"location":"CLAUDE/","title":"Claude Guidelines","text":""},{"location":"CLAUDE/#purpose","title":"Purpose","text":"<p>This document defines how Claude must behave when working on aerodb.</p> <p>Claude is treated as a senior but constrained engineer. Autonomy is allowed only within explicitly defined boundaries.</p> <p>Claude is not allowed to: - Invent requirements - Expand scope - Weaken guarantees - Optimize at the cost of correctness - Fill gaps with assumptions</p> <p>If uncertainty exists, Claude must stop and ask.</p>"},{"location":"CLAUDE/#authority-hierarchy","title":"Authority Hierarchy","text":"<p>When making decisions, Claude must follow this strict order of authority:</p> <ol> <li>VISION.md  </li> <li>INVARIANTS.md  </li> <li>RELIABILITY.md  </li> <li>SCOPE.md  </li> <li>ARCHITECTURE.md  </li> <li>All other documents  </li> <li>Code  </li> </ol> <p>If any request conflicts with a higher-priority document: - Claude must stop - Claude must explain the conflict - Claude must not proceed until resolved</p> <p>Claude must never override or reinterpret higher-priority documents.</p>"},{"location":"CLAUDE/#non-negotiable-behavioral-rules","title":"Non-Negotiable Behavioral Rules","text":""},{"location":"CLAUDE/#rule-1-no-assumptions","title":"Rule 1: No Assumptions","text":"<p>Claude must not assume: - Distributed systems - Clustering - Sharding - Cloud-managed environments - Serverless execution - Eventual consistency - Schemaless data</p> <p>If something is not explicitly stated, it is not allowed.</p>"},{"location":"CLAUDE/#rule-2-design-before-code","title":"Rule 2: Design Before Code","text":"<p>Before writing any non-trivial code, Claude must: 1. Explain the design 2. State trade-offs 3. Identify relevant invariants 4. Confirm no scope violations</p> <p>Code without prior design explanation is forbidden.</p>"},{"location":"CLAUDE/#rule-3-no-scope-expansion","title":"Rule 3: No Scope Expansion","text":"<p>Claude must not: - Add features \u201cfor later\u201d - Add abstractions \u201cfor future use\u201d - Prepare hooks for out-of-scope functionality</p> <p>If a feature is not explicitly in SCOPE.md, it is forbidden.</p>"},{"location":"CLAUDE/#rule-4-correctness-over-cleverness","title":"Rule 4: Correctness Over Cleverness","text":"<p>Claude must prefer: - Simple, explicit designs - Deterministic behavior - Boring, well-understood techniques</p> <p>Claude must avoid: - Heuristics - Adaptive behavior - Implicit optimization - Magic defaults</p> <p>If a solution is clever but harder to reason about, it is rejected.</p>"},{"location":"CLAUDE/#rule-5-reliability-is-sacred","title":"Rule 5: Reliability Is Sacred","text":"<p>Claude must never: - Suggest weakening durability guarantees - Bypass WAL - Add \u201cunsafe but faster\u201d modes - Trade correctness for performance</p> <p>If a choice exists between speed and reliability, Claude must always choose reliability.</p>"},{"location":"CLAUDE/#rule-6-determinism-is-mandatory","title":"Rule 6: Determinism Is Mandatory","text":"<p>Claude must ensure: - Deterministic query planning - Deterministic execution - Deterministic recovery</p> <p>Any non-deterministic behavior must be treated as a bug, not an acceptable implementation detail.</p>"},{"location":"CLAUDE/#rule-7-fail-loudly","title":"Rule 7: Fail Loudly","text":"<p>Claude must not introduce: - Silent retries - Silent fallbacks - Partial success masking - Implicit coercions</p> <p>All failures must be explicit, observable, and explainable.</p>"},{"location":"CLAUDE/#rule-8-no-hidden-behavior","title":"Rule 8: No Hidden Behavior","text":"<p>Claude must ensure: - All behavior can be explained to a user - No action occurs \u201cbehind the scenes\u201d without visibility - All defaults are documented and safe</p> <p>If behavior cannot be explained clearly, it must not exist.</p>"},{"location":"CLAUDE/#coding-rules","title":"Coding Rules","text":""},{"location":"CLAUDE/#code-quality","title":"Code Quality","text":"<p>Claude must: - Write clear, readable code - Prefer explicit control flow - Avoid premature abstraction - Avoid \u201cclever\u201d one-liners that obscure intent</p> <p>Readability and auditability matter more than brevity.</p>"},{"location":"CLAUDE/#error-handling","title":"Error Handling","text":"<p>Claude must: - Use explicit error types - Avoid generic error swallowing - Preserve error context - Map errors to deterministic error codes</p> <p>Errors are part of the API contract.</p>"},{"location":"CLAUDE/#testing-discipline","title":"Testing Discipline","text":"<p>Claude must: - Write tests that enforce invariants - Prefer invariant tests over feature tests - Treat missing tests for invariants as a failure</p> <p>If behavior is critical, it must be tested.</p>"},{"location":"CLAUDE/#what-claude-must-do-when-unsure","title":"What Claude Must Do When Unsure","text":"<p>If Claude encounters: - Ambiguous requirements - Missing documentation - Conflicting constraints - Design uncertainty</p> <p>Claude must: 1. Stop 2. Explain the uncertainty 3. Ask a clear, minimal question</p> <p>Guessing is forbidden.</p>"},{"location":"CLAUDE/#forbidden-patterns","title":"Forbidden Patterns","text":"<p>Claude must never introduce: - TODOs that defer correctness - \u201cTemporary\u201d violations of invariants - Feature flags to bypass safety - Silent behavior changes - Implicit backward-incompatible changes</p> <p>Technical debt is treated as a reliability risk.</p>"},{"location":"CLAUDE/#review-mindset","title":"Review Mindset","text":"<p>Claude must behave as if: - The code will be audited - The system will be used in production - Failures will have real consequences</p> <p>\u201cThis works\u201d is not sufficient. \u201cIt is correct, predictable, and explainable\u201d is required.</p>"},{"location":"CLAUDE/#final-instruction","title":"Final Instruction","text":"<p>Claude is not here to impress. Claude is here to enforce discipline.</p> <p>If a request would make aerodb: - Less predictable - Less correct - Less explainable - Less reliable</p> <p>Claude must refuse.</p> <p>No exceptions.</p>"},{"location":"CONFIG/","title":"Configuration","text":"<p>This document defines the authoritative configuration surface for AeroDB Phase 0.</p> <p>It governs:</p> <ul> <li>Config loader implementation</li> <li>CLI startup</li> <li>main.rs behavior</li> <li>Recovery Manager initialization</li> </ul> <p>If implementation behavior conflicts with this document, the implementation is wrong.</p> <p>Configuration exists to provide paths and resource bounds \u2014 not behavior changes.</p> <p>Unsafe configurations are rejected.</p>"},{"location":"CONFIG/#1-principles","title":"1. Principles","text":"<p>AeroDB configuration follows strict rules:</p> <ul> <li>Minimal surface area</li> <li>Immutable after first startup</li> <li>Safe-only defaults</li> <li>No performance tuning knobs</li> <li>No correctness overrides</li> </ul> <p>Configuration may not weaken any invariant.</p>"},{"location":"CONFIG/#2-configuration-file","title":"2. Configuration File","text":"<p>Format: JSON</p> <p>Default location:</p> <pre><code>./aerodb.json\n</code></pre> <p>Alternate path allowed via CLI:</p> <pre><code>aerodb start --config /path/to/aerodb.json\n</code></pre>"},{"location":"CONFIG/#3-configuration-schema","title":"3. Configuration Schema","text":""},{"location":"CONFIG/#required-fields","title":"Required Fields","text":"<pre><code>{\n\"data_dir\": \"/absolute/or/relative/path\"\n}\n</code></pre> <p><code>data_dir</code> must:</p> <ul> <li>exist or be creatable</li> <li>be writable</li> <li>remain immutable after first startup</li> </ul> <p>Changing <code>data_dir</code> after initialization is forbidden.</p>"},{"location":"CONFIG/#optional-fields-phase-0","title":"Optional Fields (Phase 0)","text":"<pre><code>{\n\"data_dir\": \"./data\",\n\"max_wal_size_bytes\": 1073741824,\n\"max_memory_bytes\": 536870912,\n\"wal_sync_mode\": \"fsync\"\n}\n</code></pre>"},{"location":"CONFIG/#4-field-definitions","title":"4. Field Definitions","text":""},{"location":"CONFIG/#data_dir-string-required","title":"data_dir (string, REQUIRED)","text":"<p>Root directory for all AeroDB data.</p> <p>Subdirectories:</p> <pre><code>&lt;data_dir&gt;/\n\u251c\u2500\u2500 wal/\n\u251c\u2500\u2500 data/\n\u251c\u2500\u2500 metadata/\n\u2502   \u2514\u2500\u2500 schemas/\n\u2514\u2500\u2500 clean_shutdown\n</code></pre> <p>Rules:</p> <ul> <li>Created if missing</li> <li>Must be writable</li> <li>Immutable after first successful startup</li> </ul> <p>Violation \u2192 FATAL.</p>"},{"location":"CONFIG/#max_wal_size_bytes-integer-optional","title":"max_wal_size_bytes (integer, OPTIONAL)","text":"<p>Default: <code>1073741824</code> (1GB)</p> <p>Rules:</p> <ul> <li>Must be &gt; 0</li> <li>Immutable after first startup</li> </ul> <p>Phase 0 behavior:</p> <ul> <li>WAL is NOT truncated</li> <li>Value is informational only</li> </ul>"},{"location":"CONFIG/#max_memory_bytes-integer-optional","title":"max_memory_bytes (integer, OPTIONAL)","text":"<p>Default: <code>536870912</code> (512MB)</p> <p>Rules:</p> <ul> <li>Must be &gt; 0</li> <li>Immutable after first startup</li> </ul> <p>Phase 0 behavior:</p> <ul> <li>No enforcement</li> <li>Reserved for future use</li> </ul>"},{"location":"CONFIG/#wal_sync_mode-string-optional","title":"wal_sync_mode (string, OPTIONAL)","text":"<p>Allowed values:</p> <pre><code>\"fsync\"\n</code></pre> <p>Any other value \u2192 startup failure.</p> <p>Phase 0 enforces:</p> <ul> <li>WAL must fsync every write</li> </ul> <p>This field exists only for forward compatibility.</p>"},{"location":"CONFIG/#5-forbidden-configuration","title":"5. Forbidden Configuration","text":"<p>The following are explicitly rejected:</p> <ul> <li>Disabling WAL fsync</li> <li>Disabling schema validation</li> <li>Disabling checksums</li> <li>Allowing unbounded queries</li> <li>Partial success modes</li> <li>Any undocumented fields</li> </ul> <p>Unknown fields \u2192 FATAL.</p>"},{"location":"CONFIG/#6-startup-validation","title":"6. Startup Validation","text":"<p>Startup sequence:</p> <ol> <li>Parse config JSON</li> <li>Validate schema</li> <li>Reject unknown keys</li> <li>Validate paths</li> <li>Validate values</li> <li>Persist immutable fields (first startup only)</li> </ol> <p>Any failure \u2192 immediate exit.</p> <p>No files opened before config validation completes.</p>"},{"location":"CONFIG/#7-immutability-rules","title":"7. Immutability Rules","text":"<p>After first successful startup:</p> <p>These fields are immutable:</p> <ul> <li>data_dir</li> <li>max_wal_size_bytes</li> <li>max_memory_bytes</li> <li>wal_sync_mode</li> </ul> <p>Changing any \u2192 FATAL on next startup.</p> <p>This prevents silent behavioral drift.</p>"},{"location":"CONFIG/#8-error-handling","title":"8. Error Handling","text":"<p>Config errors use:</p> <ul> <li>AERO_CONFIG_INVALID</li> <li>AERO_CONFIG_IMMUTABLE</li> <li>AERO_CONFIG_IO_FAILED</li> </ul> <p>All are FATAL.</p> <p>AeroDB does not attempt recovery from config errors.</p>"},{"location":"CONFIG/#9-determinism","title":"9. Determinism","text":"<p>Given identical config file and filesystem:</p> <ul> <li>AeroDB must initialize identically</li> <li>Paths resolved deterministically</li> <li>Defaults applied deterministically</li> </ul> <p>No environment-dependent behavior allowed.</p>"},{"location":"CONFIG/#10-phase-0-limitations","title":"10. Phase-0 Limitations","text":"<p>Configuration does NOT support:</p> <ul> <li>logging levels</li> <li>thread counts</li> <li>buffer sizes</li> <li>cache tuning</li> <li>feature flags</li> </ul> <p>These belong to Phase 1+.</p>"},{"location":"CONFIG/#11-authority","title":"11. Authority","text":"<p>This document governs:</p> <ul> <li>Config loader</li> <li>CLI startup</li> <li>main.rs initialization</li> <li>Recovery Manager initialization</li> </ul> <p>Violations of this contract are correctness bugs.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to AeroDB","text":"<p>Thank you for your interest in contributing to AeroDB! We're building production-grade database infrastructure, and we value contributions that align with our core principles of correctness, predictability, and reliability.</p>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you agree to maintain a professional, respectful environment focused on technical excellence.</p>"},{"location":"CONTRIBUTING/#how-to-contribute","title":"How to Contribute","text":""},{"location":"CONTRIBUTING/#reporting-bugs","title":"Reporting Bugs","text":"<p>Before submitting a bug report: - Check the existing issues to avoid duplicates - Verify the bug exists in the latest version - Gather minimal reproduction steps</p> <p>When creating a bug report, include: - Summary: Clear one-line description - Environment: OS, Rust version, AeroDB version - Reproduction Steps: Minimal, complete code to reproduce - Expected vs Actual Behavior: What should happen vs what does happen - Logs/Errors: Relevant error messages or stack traces</p>"},{"location":"CONTRIBUTING/#suggesting-features","title":"Suggesting Features","text":"<p>AeroDB follows strict design principles. Before suggesting features:</p> <ol> <li>Read the Vision: Review CORE_VISION.md</li> <li>Check Alignment: Ensure the feature aligns with our principles (determinism, schema-first, fail-fast)</li> <li>Search Existing Discussions: Check if it's already been proposed</li> </ol> <p>Feature proposals should include: - Problem Statement: What problem does this solve? - Proposed Solution: How should it work? - Alternatives Considered: What other approaches did you consider? - Impact on Principles: How does this affect determinism, correctness, etc?</p>"},{"location":"CONTRIBUTING/#development-workflow","title":"Development Workflow","text":""},{"location":"CONTRIBUTING/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code>git clone https://github.com/YOUR_USERNAME/AeroDB.git\ncd AeroDB\ngit remote add upstream https://github.com/eshanized/AeroDB.git\n</code></pre>"},{"location":"CONTRIBUTING/#2-create-a-branch","title":"2. Create a Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/bug-description\n</code></pre> <p>Branch naming conventions: - <code>feature/</code> - New features - <code>fix/</code> - Bug fixes - <code>` - Documentation updates -</code>refactor/<code>- Code refactoring -</code>test/` - Test additions/improvements</p>"},{"location":"CONTRIBUTING/#3-make-your-changes","title":"3. Make Your Changes","text":""},{"location":"CONTRIBUTING/#backend-rust","title":"Backend (Rust)","text":"<pre><code># Format code\ncargo fmt\n\n# Check for issues\ncargo clippy -- -D warnings\n\n# Run tests\ncargo test\n\n# Build\ncargo build --release\n</code></pre> <p>Code Standards: - Follow Rust naming conventions (snake_case for functions/variables, PascalCase for types) - Add documentation comments (<code>///</code>) for public APIs - Write comprehensive error messages - Include unit tests for new functionality</p>"},{"location":"CONTRIBUTING/#frontend-vuejstypescript","title":"Frontend (Vue.js/TypeScript)","text":"<pre><code>cd dashboard\n\n# Install dependencies\nnpm install\n\n# Development server\nnpm run dev\n\n# Type checking\nnpm run build\n\n# Run tests\nnpm test\n\n# E2E tests\nnpm run test:e2e\n</code></pre> <p>Code Standards: - Use TypeScript strict mode - Follow Vue 3 Composition API patterns - Use Pinia for state management - Write component tests for new UI features</p>"},{"location":"CONTRIBUTING/#4-write-tests","title":"4. Write Tests","text":"<p>All contributions must include tests:</p> <ul> <li>Backend: Unit tests in <code>tests/</code> or inline tests</li> <li>Frontend: Component tests using Vitest and Vue Test Utils</li> <li>Integration: End-to-end tests if changing user workflows</li> </ul> <p>Test Naming: <pre><code>#[test]\nfn test_feature_name_specific_behavior() {\n    // Arrange\n    // Act\n    // Assert\n}\n</code></pre></p>"},{"location":"CONTRIBUTING/#5-update-documentation","title":"5. Update Documentation","text":"<p>If your changes affect: - Public APIs: Update <code>CORE_API_SPEC.md</code> - User Behavior: Update README.md - Architecture: Update relevant <code>PHASE*</code> files - Configuration: Update setup wizard docs</p>"},{"location":"CONTRIBUTING/#6-commit-your-changes","title":"6. Commit Your Changes","text":"<p>Commit message format: <pre><code>type(scope): brief description\n\nLonger explanation if needed\n\nCloses #issue-number\n</code></pre></p> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation only - <code>style</code>: Formatting changes - <code>refactor</code>: Code restructuring - <code>test</code>: Adding tests - <code>chore</code>: Maintenance</p> <p>Example: <pre><code>feat(auth): add password reset email workflow\n\nImplements email-based password reset with secure token generation\nand expiration. Tokens are single-use and expire after 1 hour.\n\nCloses #123\n</code></pre></p>"},{"location":"CONTRIBUTING/#7-push-and-create-pr","title":"7. Push and Create PR","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Then create a Pull Request on GitHub.</p>"},{"location":"CONTRIBUTING/#pull-request-guidelines","title":"Pull Request Guidelines","text":""},{"location":"CONTRIBUTING/#pr-title-format","title":"PR Title Format","text":"<p>Same as commit messages: <code>type(scope): description</code></p>"},{"location":"CONTRIBUTING/#pr-description-template","title":"PR Description Template","text":"<pre><code>## Summary\nBrief overview of changes\n\n## Motivation\nWhy is this change needed?\n\n## Changes Made\n- Change 1\n- Change 2\n\n## Testing\nHow was this tested?\n\n## Checklist\n- [ ] Tests pass (`cargo test` and `npm test`)\n- [ ] Code formatted (`cargo fmt`)\n- [ ] No clippy warnings (`cargo clippy`)\n- [ ] Documentation updated\n- [ ] Changelog entry added (if applicable)\n\n## Related Issues\nCloses #issue-number\n</code></pre>"},{"location":"CONTRIBUTING/#review-process","title":"Review Process","text":"<ol> <li>Automated Checks: CI must pass (tests, linting, build)</li> <li>Code Review: At least one maintainer approval required</li> <li>Testing: Verify changes work as described</li> <li>Documentation: Ensure docs are updated</li> <li>Merge: Squash and merge when approved</li> </ol>"},{"location":"CONTRIBUTING/#code-review-standards","title":"Code Review Standards","text":""},{"location":"CONTRIBUTING/#what-we-look-for","title":"What We Look For","text":"<p>\u2705 Correctness: Does it work as intended? \u2705 Testing: Are edge cases covered? \u2705 Performance: Any unnecessary performance degradation? \u2705 Safety: Memory safety, error handling \u2705 Clarity: Is the code readable and well-documented? \u2705 Consistency: Matches existing code style</p>"},{"location":"CONTRIBUTING/#what-we-reject","title":"What We Reject","text":"<p>\u274c Breaking Changes: Without RFC and justification \u274c Unsafe Code: Unless absolutely necessary with clear safety comments \u274c Magic Behavior: Implicit assumptions, hidden side effects \u274c Untested Code: Missing tests for new functionality \u274c Poor Error Handling: <code>.unwrap()</code> abuse, unclear error messages</p>"},{"location":"CONTRIBUTING/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"CONTRIBUTING/#recommended-tools","title":"Recommended Tools","text":"<p>Rust: - rust-analyzer - IDE support - cargo-watch - Auto-rebuild on changes</p> <p>Frontend: - Vue DevTools - Browser extension - Volar - VS Code extension</p>"},{"location":"CONTRIBUTING/#running-locally","title":"Running Locally","text":"<pre><code># Terminal 1: Backend\ncargo run -- serve\n\n# Terminal 2: Frontend\ncd dashboard &amp;&amp; npm run dev\n\n# Terminal 3: Tests (watch mode)\ncargo watch -x test\n</code></pre>"},{"location":"CONTRIBUTING/#architecture-decision-records-adrs","title":"Architecture Decision Records (ADRs)","text":"<p>For significant changes, create an ADR:</p> <pre><code># ADR-XXX: Title\n\n## Status\nProposed | Accepted | Rejected\n\n## Context\nWhat problem are we solving?\n\n## Decision\nWhat approach did we choose?\n\n## Consequences\nWhat are the trade-offs?\n</code></pre> <p>Save in <code>adr-XXX-title.md</code></p>"},{"location":"CONTRIBUTING/#community","title":"Community","text":"<ul> <li>Discussions: GitHub Discussions</li> <li>Issues: GitHub Issues</li> </ul>"},{"location":"CONTRIBUTING/#questions","title":"Questions?","text":"<p>If you're unsure about anything, feel free to: 1. Open a discussion thread 2. Comment on a relevant issue 3. Ask in your PR description</p> <p>We value thoughtful questions and constructive discussion.</p> <p>Thank you for contributing to AeroDB! Together, we're building infrastructure that engineers can trust.</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/","title":"PHASE 7 AUDITABILITY \u2014 TRACEABILITY, ACCOUNTABILITY, AND POST-INCIDENT RECONSTRUCTION","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 NON-NEGOTIABLE</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the auditability guarantees of Phase 7.</p> <p>Its purpose is to ensure that every control-plane action, decision, failure, and non-action can be reconstructed after the fact with high confidence.</p> <p>Auditability is not optional. It is a core safety property of AeroDB.</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#2-foundational-principle","title":"2. Foundational Principle","text":"<p>If an action cannot be reconstructed, it must not be allowed to execute.</p> <p>Phase 7 exists at the boundary between human intent and system mutation. That boundary must be permanently observable.</p> <p>Auditability ensures:</p> <ul> <li>Accountability</li> <li>Post-incident analysis</li> <li>Trust in operational correctness</li> </ul>"},{"location":"CONTROL_PLANE_AUDITABILITY/#3-what-must-be-auditable","title":"3. What Must Be Auditable","text":"<p>The following MUST be auditable in Phase 7:</p> <ol> <li>Operator-issued commands</li> <li>Confirmation events</li> <li>Kernel execution outcomes</li> <li>Kernel rejections</li> <li>Phase 7 validation failures</li> <li>Infrastructure / transport failures</li> <li>Explicit non-execution (\"nothing happened\")</li> </ol> <p>Absence of an audit record implies the action did not occur.</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#4-audit-record-properties","title":"4. Audit Record Properties","text":"<p>Every audit record MUST satisfy the following properties:</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#41-append-only","title":"4.1 Append-Only","text":"<ul> <li>Audit records MUST be immutable once written</li> <li>Deletion or modification is forbidden</li> </ul>"},{"location":"CONTROL_PLANE_AUDITABILITY/#42-complete","title":"4.2 Complete","text":"<p>Each record MUST include:</p> <ul> <li>Timestamp (with declared clock source)</li> <li>Action or attempted action</li> <li>Operator identity (if available)</li> <li>Authority level used</li> <li>Confirmation status</li> <li>Kernel response (accepted / rejected)</li> <li>Execution outcome (executed / not executed)</li> </ul>"},{"location":"CONTROL_PLANE_AUDITABILITY/#43-deterministic","title":"4.3 Deterministic","text":"<ul> <li>Given identical events, audit records must be identical</li> <li>No non-deterministic fields are allowed</li> </ul>"},{"location":"CONTROL_PLANE_AUDITABILITY/#44-durable","title":"4.4 Durable","text":"<ul> <li>Audit records MUST survive control-plane crashes</li> <li>Loss of audit data is a critical failure</li> </ul>"},{"location":"CONTROL_PLANE_AUDITABILITY/#5-audit-record-lifecycle","title":"5. Audit Record Lifecycle","text":""},{"location":"CONTROL_PLANE_AUDITABILITY/#51-creation","title":"5.1 Creation","text":"<p>Audit records are created:</p> <ul> <li>When a command is requested</li> <li>When confirmation is given</li> <li>When execution succeeds or fails</li> </ul> <p>Each stage must produce a distinct, ordered record.</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#52-ordering","title":"5.2 Ordering","text":"<ul> <li>Records MUST have a total, explicit order</li> <li>Ordering must not rely solely on wall-clock time</li> </ul> <p>If ordering cannot be determined, the ambiguity must be recorded explicitly.</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#53-retention","title":"5.3 Retention","text":"<ul> <li>Audit records MUST NOT be garbage-collected automatically</li> <li>Retention policy is external and explicit</li> </ul>"},{"location":"CONTROL_PLANE_AUDITABILITY/#6-auditability-and-failures","title":"6. Auditability and Failures","text":""},{"location":"CONTROL_PLANE_AUDITABILITY/#61-control-plane-failures","title":"6.1 Control-Plane Failures","text":"<p>If the control plane crashes:</p> <ul> <li>Audit records up to the crash MUST be preserved</li> <li>No new records may be synthesized on restart</li> </ul>"},{"location":"CONTROL_PLANE_AUDITABILITY/#62-partial-failures","title":"6.2 Partial Failures","text":"<p>If an action fails mid-flow:</p> <ul> <li>The audit log MUST show the last completed stage</li> <li>Missing stages must be explicit</li> </ul> <p>Silent gaps are forbidden.</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#7-auditability-vs-observability","title":"7. Auditability vs Observability","text":"<p>Auditability and observability are related but distinct:</p> <ul> <li>Observability explains what is happening now</li> <li>Auditability explains what happened then</li> </ul> <p>Observability failure MUST NOT affect auditability.</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#8-auditability-and-authority","title":"8. Auditability and Authority","text":"<p>Audit records MUST make authority explicit:</p> <ul> <li>Who initiated the action</li> <li>Under which authority level</li> <li>Whether overrides were used</li> </ul> <p>If authority cannot be determined, the action must not execute.</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#9-audit-queries-and-access","title":"9. Audit Queries and Access","text":"<p>Phase 7 MAY support:</p> <ul> <li>Read-only audit queries</li> <li>Time-bounded reconstruction</li> <li>Cross-referencing with kernel events</li> </ul> <p>Audit queries MUST NOT mutate state or trigger execution.</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#10-auditability-and-privacy-boundaries","title":"10. Auditability and Privacy Boundaries","text":"<p>Auditability MUST respect conceptual privacy boundaries:</p> <ul> <li>Sensitive data may be redacted</li> <li>Redaction MUST be explicit and logged</li> </ul> <p>Auditability must not become silent data exposure.</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#11-testing-requirements","title":"11. Testing Requirements","text":"<p>Auditability MUST be tested to ensure:</p> <ul> <li>Every command produces audit records</li> <li>Failures produce audit records</li> <li>Crashes do not erase records</li> <li>No execution occurs without an audit trail</li> </ul> <p>Any missing audit record is a test failure.</p>"},{"location":"CONTROL_PLANE_AUDITABILITY/#12-final-statement","title":"12. Final Statement","text":"<p>Auditability is the last line of defense against silent failure and unaccountable action.</p> <p>Phase 7 must make it impossible to ask:</p> <p>\u201cDid this happen, and if so, who did it?\u201d</p> <p>If that question cannot be answered, Phase 7 is wrong.</p> <p>This auditability model is absolute.</p> <p>END OF PHASE 7 AUDITABILITY</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/","title":"PHASE 7 AUTHORITY MODEL \u2014 OPERATOR POWER, BOUNDARIES, AND RESPONSIBILITY","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 NON-NEGOTIABLE</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the authority model for Phase 7.</p> <p>Authority in Phase 7 determines:</p> <ul> <li>Who is permitted to request actions</li> <li>What actions may be requested</li> <li>How irreversible actions are gated</li> <li>Where responsibility lies when actions cause harm</li> </ul> <p>Phase 7 authority is human authority, not system authority.</p> <p>The system never assumes intent, never escalates privileges, and never substitutes its judgment for a human\u2019s decision.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#2-fundamental-authority-principle","title":"2. Fundamental Authority Principle","text":"<p>Phase 7 grants the ability to ask. It never grants the ability to decide.</p> <p>All correctness, safety, and durability decisions remain exclusively within the kernel (Phases 0\u20136).</p> <p>Phase 7 authority:</p> <ul> <li>Allows a human to request kernel actions</li> <li>Allows a human to observe kernel state</li> <li>Allows a human to acknowledge consequences</li> </ul> <p>Phase 7 authority does NOT:</p> <ul> <li>Permit bypassing kernel validation</li> <li>Permit overriding kernel rejection</li> <li>Permit speculative execution</li> </ul>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#3-authority-layers","title":"3. Authority Layers","text":"<p>Phase 7 defines three conceptual authority layers.</p> <p>These layers are conceptual, not implementation-specific.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#31-observer-authority","title":"3.1 Observer Authority","text":"<p>Observers may:</p> <ul> <li>View cluster state</li> <li>Inspect logs, metrics, and explanations</li> <li>Review historical timelines</li> </ul> <p>Observers may NOT:</p> <ul> <li>Trigger any mutating action</li> <li>Confirm actions</li> <li>Escalate privileges</li> </ul> <p>Read access never implies write authority.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#32-operator-authority","title":"3.2 Operator Authority","text":"<p>Operators may:</p> <ul> <li>Issue explicit, mutating commands</li> <li>Confirm irreversible actions</li> <li>Initiate diagnostics</li> </ul> <p>Operators must:</p> <ul> <li>Accept responsibility for outcomes</li> <li>Explicitly acknowledge risk</li> </ul> <p>Operator authority is required for all state mutation.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#33-auditor-authority","title":"3.3 Auditor Authority","text":"<p>Auditors may:</p> <ul> <li>Review action logs</li> <li>Inspect decisions and explanations</li> <li>Reconstruct historical events</li> </ul> <p>Auditors may NOT:</p> <ul> <li>Execute commands</li> <li>Replay actions</li> <li>Mutate state</li> </ul> <p>Audit authority exists to support accountability, not control.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#4-authority-does-not-imply-trust","title":"4. Authority Does Not Imply Trust","text":"<p>Possession of authority does not imply:</p> <ul> <li>Correct judgment</li> <li>Safe intent</li> <li>Appropriate timing</li> </ul> <p>Therefore:</p> <ul> <li>The system must never infer safety from authority</li> <li>All requests are validated equally</li> <li>All kernel invariants apply regardless of who issues a request</li> </ul> <p>Authority grants permission to ask, not permission to succeed.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#5-explicit-authority-boundaries","title":"5. Explicit Authority Boundaries","text":"<p>Phase 7 MUST enforce clear boundaries:</p> <ul> <li>Observer \u2192 Operator escalation is explicit</li> <li>Operator \u2192 Auditor escalation is forbidden</li> <li>Authority transitions are never automatic</li> </ul> <p>Any ambiguity in authority is treated as no authority.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#6-irreversible-actions","title":"6. Irreversible Actions","text":"<p>Some Phase 7 actions are irreversible or high-risk (e.g. promotion, demotion, destructive diagnostics).</p> <p>Rules for irreversible actions:</p> <ul> <li>MUST require explicit confirmation</li> <li>MUST surface consequences clearly</li> <li>MUST reference relevant invariants</li> <li>MUST NOT execute implicitly</li> </ul> <p>If an operator does not confirm explicitly, the action MUST NOT proceed.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#7-force-and-override-semantics","title":"7. Force and Override Semantics","text":"<p>Phase 7 MAY expose explicit override capabilities (e.g. force promotion), subject to strict rules.</p> <p>Override rules:</p> <ul> <li>Overrides MUST be explicit</li> <li>Overrides MUST be documented</li> <li>Overrides MUST reference violated invariants</li> <li>Overrides MUST surface full risk</li> </ul> <p>Overrides transfer responsibility entirely to the operator.</p> <p>The system remains correctness-enforcing; it does not become permissive.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#8-responsibility-and-accountability","title":"8. Responsibility and Accountability","text":"<p>Every mutating action must have a clear responsibility chain.</p> <p>The system MUST record:</p> <ul> <li>Who issued the request (if identity is available)</li> <li>What authority level was used</li> <li>What confirmations were given</li> <li>What kernel state existed at the time</li> </ul> <p>If responsibility cannot be assigned, the action MUST NOT execute.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#9-authority-and-failure","title":"9. Authority and Failure","text":"<p>Failures do not escalate authority.</p> <p>Rules:</p> <ul> <li>A failed request does not grant retry rights</li> <li>A crash does not imply success</li> <li>A reconnect does not restore in-flight authority</li> </ul> <p>Authority must be reasserted explicitly after failure.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#10-authority-and-automation-explicitly-forbidden","title":"10. Authority and Automation (Explicitly Forbidden)","text":"<p>Authority MUST NOT be delegated to:</p> <ul> <li>Background processes</li> <li>Schedulers</li> <li>Policies</li> <li>Scripts that auto-execute without confirmation</li> </ul> <p>Human authority must remain human.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#11-future-authentication-authorization","title":"11. Future Authentication &amp; Authorization","text":"<p>This document defines authority boundaries, not authentication mechanisms.</p> <p>Future phases may introduce:</p> <ul> <li>Identity</li> <li>Authentication</li> <li>Authorization</li> </ul> <p>Those mechanisms MUST respect this authority model.</p> <p>No future feature may weaken the guarantees defined here.</p>"},{"location":"CONTROL_PLANE_AUTHORITY_MODEL/#12-final-statement","title":"12. Final Statement","text":"<p>Phase 7 authority exists to empower humans without empowering mistakes.</p> <p>It is intentionally constrained.</p> <p>If the system ever assumes authority it was not explicitly given, it is incorrect.</p> <p>This authority model is absolute.</p> <p>END OF PHASE 7 AUTHORITY MODEL</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/","title":"PHASE 7 COMMAND MODEL \u2014 EXPLICIT OPERATOR ACTIONS AND GUARANTEES","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 NON-NEGOTIABLE</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the complete and closed set of operator commands exposed by Phase 7.</p> <p>Its goals are to:</p> <ul> <li>Enumerate every allowed mutating and non-mutating command</li> <li>Define command semantics precisely</li> <li>Prevent the introduction of ad-hoc or implicit actions</li> <li>Ensure every command is auditable, explainable, and deterministic</li> </ul> <p>If a command is not defined in this document, it must not exist.</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#2-fundamental-command-principles","title":"2. Fundamental Command Principles","text":"<p>All Phase 7 commands MUST obey the following principles:</p> <ol> <li>Explicitness \u2014 every command is intentionally issued by a human</li> <li>Singularity \u2014 one command maps to one kernel action</li> <li>Determinism \u2014 same input yields same result</li> <li>Explainability \u2014 every command can be explained before execution</li> <li>Auditability \u2014 every command leaves a permanent audit trail</li> </ol> <p>No command may violate Phase 7 invariants.</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#3-command-classification","title":"3. Command Classification","text":"<p>Phase 7 commands are divided into three classes:</p> <ol> <li>Inspection Commands (read-only)</li> <li>Diagnostic Commands (read-only but potentially expensive)</li> <li>Control Commands (mutating, high-risk)</li> </ol> <p>Each class has different confirmation and failure requirements.</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#4-inspection-commands-read-only","title":"4. Inspection Commands (Read-Only)","text":"<p>Inspection commands MUST NOT mutate any kernel state.</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#41-inspect_cluster_state","title":"4.1 <code>inspect_cluster_state</code>","text":"<p>Purpose:</p> <ul> <li>Retrieve current cluster topology and roles</li> </ul> <p>Kernel Interaction:</p> <ul> <li>Read-only</li> </ul> <p>Confirmation Required: No</p> <p>Failure Semantics:</p> <ul> <li>Fail closed</li> <li>Partial data forbidden</li> </ul>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#42-inspect_node","title":"4.2 <code>inspect_node</code>","text":"<p>Purpose:</p> <ul> <li>Inspect a specific node\u2019s role, WAL position, and health</li> </ul> <p>Kernel Interaction:</p> <ul> <li>Read-only</li> </ul> <p>Confirmation Required: No</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#43-inspect_replication_status","title":"4.3 <code>inspect_replication_status</code>","text":"<p>Purpose:</p> <ul> <li>View replication lag and replica health</li> </ul> <p>Kernel Interaction:</p> <ul> <li>Read-only</li> </ul>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#44-inspect_promotion_state","title":"4.4 <code>inspect_promotion_state</code>","text":"<p>Purpose:</p> <ul> <li>View current promotion / demotion state machine status</li> </ul> <p>Kernel Interaction:</p> <ul> <li>Read-only</li> </ul>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#5-diagnostic-commands","title":"5. Diagnostic Commands","text":"<p>Diagnostic commands are read-only but may be disruptive or expensive.</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#51-run_diagnostics","title":"5.1 <code>run_diagnostics</code>","text":"<p>Purpose:</p> <ul> <li>Collect kernel diagnostic information</li> </ul> <p>Kernel Interaction:</p> <ul> <li>Read-only</li> </ul> <p>Confirmation Required: Yes</p> <p>Rules:</p> <ul> <li>Must declare cost before execution</li> <li>Must not mutate state</li> </ul>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#52-inspect_wal","title":"5.2 <code>inspect_wal</code>","text":"<p>Purpose:</p> <ul> <li>Inspect WAL metadata and boundaries</li> </ul> <p>Kernel Interaction:</p> <ul> <li>Read-only</li> </ul>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#53-inspect_snapshots","title":"5.3 <code>inspect_snapshots</code>","text":"<p>Purpose:</p> <ul> <li>Inspect available snapshots and checkpoints</li> </ul> <p>Kernel Interaction:</p> <ul> <li>Read-only</li> </ul>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#6-control-commands-mutating","title":"6. Control Commands (Mutating)","text":"<p>Control commands mutate kernel state and are strictly regulated.</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#61-request_promotion","title":"6.1 <code>request_promotion</code>","text":"<p>Purpose:</p> <ul> <li>Request promotion of a replica to primary</li> </ul> <p>Kernel Interaction:</p> <ul> <li>Promotion state machine</li> </ul> <p>Confirmation Required: Yes (mandatory)</p> <p>Preconditions:</p> <ul> <li>Kernel validation must succeed</li> <li>WAL prefix rules must hold</li> </ul> <p>Failure Semantics:</p> <ul> <li>Reject on ambiguity</li> </ul>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#62-request_demotion","title":"6.2 <code>request_demotion</code>","text":"<p>Purpose:</p> <ul> <li>Request demotion of a primary</li> </ul> <p>Kernel Interaction:</p> <ul> <li>Demotion state machine</li> </ul> <p>Confirmation Required: Yes</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#63-force_promotion","title":"6.3 <code>force_promotion</code>","text":"<p>Purpose:</p> <ul> <li>Explicit operator override for promotion</li> </ul> <p>Kernel Interaction:</p> <ul> <li>Promotion with override flag</li> </ul> <p>Confirmation Required: Yes (explicit override acknowledgement)</p> <p>Rules:</p> <ul> <li>Must reference overridden invariants</li> <li>Must surface full risk</li> </ul>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#7-command-preconditions-and-validation","title":"7. Command Preconditions and Validation","text":"<p>For every command:</p> <ul> <li>Preconditions MUST be checked before execution</li> <li>Failed preconditions MUST be reported explicitly</li> <li>Phase 7 MUST NOT attempt corrective action</li> </ul> <p>Validation failure always results in rejection.</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#8-confirmation-model-integration","title":"8. Confirmation Model Integration","text":"<p>Control commands MUST integrate with the confirmation model:</p> <ul> <li>Clear description of action</li> <li>Clear description of consequences</li> <li>Explicit acknowledgement</li> </ul> <p>No confirmation \u2192 no execution.</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#9-command-idempotency-and-duplication","title":"9. Command Idempotency and Duplication","text":"<p>Commands are not implicitly idempotent.</p> <p>Rules:</p> <ul> <li>Duplicate requests MUST be detected or rejected</li> <li>Silent re-execution is forbidden</li> </ul>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#10-error-semantics","title":"10. Error Semantics","text":"<p>Command errors MUST:</p> <ul> <li>Reference kernel or Phase 7 invariants</li> <li>Be deterministic</li> <li>Be auditable</li> </ul> <p>No generic errors are allowed.</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#11-extensibility-rules","title":"11. Extensibility Rules","text":"<p>New commands MAY be added only by:</p> <ul> <li>Updating this document</li> <li>Updating testing strategy</li> <li>Passing an explicit audit</li> </ul> <p>Ad-hoc commands are forbidden.</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#12-testing-requirements","title":"12. Testing Requirements","text":"<p>Every command MUST have tests covering:</p> <ul> <li>Successful execution (if allowed)</li> <li>Validation failure</li> <li>Confirmation refusal</li> <li>Crash safety</li> </ul> <p>Missing tests block Phase 7 freeze.</p>"},{"location":"CONTROL_PLANE_COMMAND_MODEL/#13-final-statement","title":"13. Final Statement","text":"<p>The Phase 7 command set is intentionally small.</p> <p>Every command represents power.</p> <p>If an operator action is not defined here, it must not exist.</p> <p>This command model is closed and authoritative.</p> <p>END OF PHASE 7 COMMAND MODEL</p>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/","title":"PHASE 7 CONFIRMATION MODEL \u2014 EXPLICIT CONSENT, RISK ACKNOWLEDGEMENT, AND IRREVERSIBILITY","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 NON-NEGOTIABLE</p>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the confirmation model for Phase 7.</p> <p>Its purpose is to ensure that:</p> <ul> <li>Dangerous or irreversible actions are never executed accidentally</li> <li>Operator intent is explicit, informed, and auditable</li> <li>No UI, CLI, or transport behavior can substitute for human consent</li> </ul> <p>Confirmation is a safety boundary, not a usability feature.</p>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#2-foundational-principle","title":"2. Foundational Principle","text":"<p>No irreversible or high-risk action may execute without explicit, contemporaneous human confirmation.</p> <p>Confirmation is required to:</p> <ul> <li>Prove intent</li> <li>Transfer responsibility</li> <li>Prevent accidental execution</li> </ul> <p>Absence of confirmation is always interpreted as rejection.</p>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#3-actions-requiring-confirmation","title":"3. Actions Requiring Confirmation","text":"<p>The following classes of commands REQUIRE confirmation:</p> <ol> <li>All Control Commands (mutating)</li> <li>All Override / Force Commands</li> <li>Any command explicitly marked as dangerous or disruptive</li> </ol> <p>Read-only inspection commands NEVER require confirmation.</p>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#4-confirmation-properties","title":"4. Confirmation Properties","text":"<p>Every valid confirmation MUST satisfy all of the following properties:</p>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#41-explicitness","title":"4.1 Explicitness","text":"<ul> <li>Confirmation must be an explicit operator action</li> <li>Defaults, timeouts, or focus changes are forbidden</li> </ul>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#42-contemporaneity","title":"4.2 Contemporaneity","text":"<ul> <li>Confirmation must occur immediately after explanation</li> <li>Stored, delayed, or pre-approved confirmations are forbidden</li> </ul>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#43-specificity","title":"4.3 Specificity","text":"<ul> <li>Confirmation must apply to exactly one command</li> <li>Confirmation cannot be reused</li> </ul>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#44-visibility-of-consequences","title":"4.4 Visibility of Consequences","text":"<p>Before confirmation, the system MUST surface:</p> <ul> <li>The exact action to be taken</li> <li>The affected components</li> <li>The irreversible consequences (if any)</li> <li>The invariants involved</li> </ul>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#5-confirmation-workflow","title":"5. Confirmation Workflow","text":"<p>The confirmation workflow MUST follow this exact sequence:</p> <ol> <li>Operator issues command</li> <li>System generates pre-execution explanation</li> <li>System requests confirmation</li> <li>Operator explicitly confirms</li> <li>Command is dispatched to the kernel</li> </ol> <p>If any step is interrupted, the workflow is aborted.</p>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#6-confirmation-and-failure","title":"6. Confirmation and Failure","text":""},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#61-failure-before-confirmation","title":"6.1 Failure Before Confirmation","text":"<p>If failure occurs before confirmation:</p> <ul> <li>The command MUST NOT execute</li> </ul>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#62-failure-after-confirmation-before-execution","title":"6.2 Failure After Confirmation, Before Execution","text":"<p>If failure occurs after confirmation but before kernel dispatch:</p> <ul> <li>The command MUST NOT execute</li> </ul> <p>Confirmation is not durable intent.</p>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#63-failure-after-execution","title":"6.3 Failure After Execution","text":"<p>If failure occurs after kernel execution:</p> <ul> <li>Kernel state is authoritative</li> <li>Confirmation remains valid only for audit</li> </ul>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#7-confirmation-and-retries","title":"7. Confirmation and Retries","text":"<p>Confirmations MUST NOT be reused for retries.</p> <p>Rules:</p> <ul> <li>Retrying a command requires a new confirmation</li> <li>Network retries must never imply consent</li> </ul>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#8-confirmation-and-overrides","title":"8. Confirmation and Overrides","text":"<p>Override commands (e.g. force promotion) require enhanced confirmation:</p> <ul> <li>Explicit acknowledgement of overridden invariants</li> <li>Explicit acceptance of risk</li> <li>Clear statement of responsibility transfer</li> </ul> <p>If enhanced confirmation is incomplete, the override MUST be rejected.</p>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#9-confirmation-record","title":"9. Confirmation Record","text":"<p>Every confirmation MUST produce an audit record including:</p> <ul> <li>Operator identity (if available)</li> <li>Timestamp</li> <li>Command</li> <li>Confirmation type (standard / override)</li> <li>Acknowledged risks</li> </ul> <p>Lack of a confirmation record invalidates execution.</p>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#10-forbidden-confirmation-patterns","title":"10. Forbidden Confirmation Patterns","text":"<p>Phase 7 MUST NOT:</p> <ul> <li>Auto-confirm actions</li> <li>Confirm via implicit gestures</li> <li>Use time-based confirmation</li> <li>Allow bulk confirmation</li> </ul> <p>Any such pattern is a correctness violation.</p>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#11-testing-requirements","title":"11. Testing Requirements","text":"<p>The confirmation model MUST be tested to ensure:</p> <ul> <li>No execution without confirmation</li> <li>Confirmation loss aborts execution</li> <li>Confirmation cannot be replayed</li> <li>Override confirmation enforces enhanced rules</li> </ul>"},{"location":"CONTROL_PLANE_CONFIRMATION_MODEL/#12-final-statement","title":"12. Final Statement","text":"<p>Confirmation is the final barrier between human intent and system mutation.</p> <p>It must be:</p> <ul> <li>Explicit</li> <li>Informed</li> <li>Auditable</li> <li>Non-reusable</li> </ul> <p>If an action executes without a human explicitly saying \u201cyes\u201d at that moment, Phase 7 is wrong.</p> <p>This confirmation model is absolute.</p> <p>END OF PHASE 7 CONFIRMATION MODEL</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/","title":"PHASE 7 CONTROL PLANE ARCHITECTURE \u2014 STRUCTURE, BOUNDARIES, AND DATA FLOW","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 PRE-IMPLEMENTATION</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the architectural structure of the Phase 7 control plane.</p> <p>Its purpose is to:</p> <ul> <li>Establish clear component boundaries</li> <li>Define allowed communication paths</li> <li>Prevent hidden coupling with the correctness kernel</li> <li>Ensure Phase 7 remains replaceable, observable, and non-authoritative</li> </ul> <p>Architecture exists to constrain behavior, not to enable convenience.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#2-architectural-principle","title":"2. Architectural Principle","text":"<p>The control plane observes and requests. It never decides or executes.</p> <p>All correctness-critical execution occurs exclusively within Phases 0\u20136.</p> <p>Phase 7 architecture must ensure:</p> <ul> <li>No backchannels into the kernel</li> <li>No implicit execution paths</li> <li>No stateful coupling that affects correctness</li> </ul> <p>If the control plane is removed, the kernel must continue to function correctly.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#3-high-level-architecture-overview","title":"3. High-Level Architecture Overview","text":"<p>Phase 7 consists of four primary components:</p> <ol> <li>Control Plane API</li> <li>Operator Interfaces (UI / CLI)</li> <li>Explanation &amp; Observability Layer</li> <li>Kernel Boundary Adapter</li> </ol> <p>These components are strictly layered.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Operator Interfaces      \u2502  (UI / CLI)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Control Plane API     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Explanation &amp; Observability\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Kernel Boundary Adapter  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Correctness Kernel       \u2502 (Phases 0\u20136)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Data flows downward only. Decisions flow upward only as explanations.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#4-component-responsibilities","title":"4. Component Responsibilities","text":""},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#41-operator-interfaces-ui-cli","title":"4.1 Operator Interfaces (UI / CLI)","text":"<p>Responsibilities:</p> <ul> <li>Present state to humans</li> <li>Collect explicit operator intent</li> <li>Require confirmations for dangerous actions</li> </ul> <p>Rules:</p> <ul> <li>MUST NOT contain business logic</li> <li>MUST NOT cache authoritative state</li> <li>MUST NOT retry mutating requests automatically</li> </ul> <p>Interfaces are replaceable.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#42-control-plane-api","title":"4.2 Control Plane API","text":"<p>Responsibilities:</p> <ul> <li>Validate request structure</li> <li>Enforce Phase 7 invariants</li> <li>Orchestrate confirmation flows</li> <li>Route requests to kernel boundary adapter</li> </ul> <p>Rules:</p> <ul> <li>MUST be stateless across restarts</li> <li>MUST treat kernel responses as authoritative</li> <li>MUST NOT mutate kernel state directly</li> </ul>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#43-explanation-observability-layer","title":"4.3 Explanation &amp; Observability Layer","text":"<p>Responsibilities:</p> <ul> <li>Produce explanations for requests</li> <li>Surface kernel decisions</li> <li>Aggregate observable events</li> </ul> <p>Rules:</p> <ul> <li>MUST be passive</li> <li>MUST NOT influence control flow</li> <li>MUST NOT trigger execution</li> </ul> <p>Observability must never become a control mechanism.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#44-kernel-boundary-adapter","title":"4.4 Kernel Boundary Adapter","text":"<p>Responsibilities:</p> <ul> <li>Translate control-plane requests into kernel calls</li> <li>Enforce strict API boundaries</li> <li>Prevent forbidden invocation patterns</li> </ul> <p>Rules:</p> <ul> <li>MUST expose only explicitly allowed kernel operations</li> <li>MUST NOT batch or chain kernel calls</li> <li>MUST NOT infer or synthesize kernel behavior</li> </ul> <p>This is the only component allowed to call kernel APIs.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#5-communication-paths","title":"5. Communication Paths","text":""},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#51-allowed-paths","title":"5.1 Allowed Paths","text":"<ul> <li>UI \u2192 Control Plane API</li> <li>CLI \u2192 Control Plane API</li> <li>Control Plane API \u2192 Explanation Layer</li> <li>Control Plane API \u2192 Kernel Boundary Adapter</li> <li>Kernel Boundary Adapter \u2192 Kernel</li> <li>Kernel \u2192 Explanation Layer \u2192 Control Plane API \u2192 UI / CLI</li> </ul>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#52-forbidden-paths","title":"5.2 Forbidden Paths","text":"<ul> <li>UI / CLI \u2192 Kernel (direct)</li> <li>Explanation Layer \u2192 Kernel</li> <li>Kernel \u2192 UI / CLI (direct)</li> <li>Control Plane API \u2192 Kernel (bypassing adapter)</li> </ul> <p>Any forbidden path is an architectural violation.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#6-request-lifecycle","title":"6. Request Lifecycle","text":"<ol> <li>Operator issues request via UI or CLI</li> <li>Control Plane API validates structure and authority</li> <li>Explanation Layer generates pre-execution explanation</li> <li>Operator confirms (if required)</li> <li>Control Plane API forwards request to Kernel Boundary Adapter</li> <li>Kernel validates and executes (or rejects)</li> <li>Result propagates back through Explanation Layer</li> <li>Outcome is surfaced to operator</li> </ol> <p>At no point does Phase 7 assume success.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#7-state-placement-rules","title":"7. State Placement Rules","text":"<p>Phase 7 state placement MUST follow <code>CONTROL_PLANE_STATE_MODEL.md</code>:</p> <ul> <li>No authoritative state stored in Phase 7</li> <li>Only ephemeral and derived state allowed</li> <li>No recovery logic required for Phase 7 state</li> </ul> <p>Any persisted state in Phase 7 is a design error.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#8-failure-containment","title":"8. Failure Containment","text":"<p>Failures must be contained to the layer in which they occur:</p> <ul> <li>UI failure \u2192 UI restarts</li> <li>API failure \u2192 request aborted</li> <li>Explanation failure \u2192 explanation unavailable</li> <li>Adapter failure \u2192 request rejected</li> </ul> <p>Kernel state must remain unchanged under all Phase 7 failures.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#9-extensibility-rules","title":"9. Extensibility Rules","text":"<p>Phase 7 architecture MAY allow:</p> <ul> <li>New UI implementations</li> <li>New CLI implementations</li> <li>New explanation renderers</li> </ul> <p>Phase 7 architecture MUST NOT allow:</p> <ul> <li>New execution paths</li> <li>Background schedulers</li> <li>Automated decision engines</li> </ul> <p>Extensibility must never increase system autonomy.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#10-testing-requirements","title":"10. Testing Requirements","text":"<p>The architecture MUST be tested to ensure:</p> <ul> <li>Forbidden paths are impossible</li> <li>Removing Phase 7 does not affect kernel behavior</li> <li>No component holds authoritative state</li> </ul> <p>Architecture tests are mandatory.</p>"},{"location":"CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE/#11-final-statement","title":"11. Final Statement","text":"<p>Phase 7 architecture exists to constrain power, not distribute it.</p> <p>It is deliberately layered, deliberately limited, and deliberately boring.</p> <p>If Phase 7 can accidentally execute something, the architecture is wrong.</p> <p>This architecture is authoritative.</p> <p>END OF PHASE 7 CONTROL PLANE ARCHITECTURE</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/","title":"PHASE 7 ERROR MODEL \u2014 EXPLICIT FAILURE, MEANING, AND SURFACING","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 NON-NEGOTIABLE</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the error model for Phase 7.</p> <p>Its purpose is to ensure that:</p> <ul> <li>Errors are explicit, deterministic, and meaningful</li> <li>Errors never mask or reinterpret kernel decisions</li> <li>Errors do not trigger retries, fallbacks, or hidden behavior</li> <li>Operators can understand why an action failed and what did not happen</li> </ul> <p>Errors are a safety mechanism, not an inconvenience.</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#2-foundational-principle","title":"2. Foundational Principle","text":"<p>An unclear error is worse than a failed action.</p> <p>Phase 7 errors MUST:</p> <ul> <li>Preserve correctness</li> <li>Preserve determinism</li> <li>Preserve operator responsibility</li> </ul> <p>If an error cannot be explained precisely, execution MUST NOT proceed.</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#3-error-domains","title":"3. Error Domains","text":"<p>Phase 7 errors originate from exactly four domains:</p> <ol> <li>Operator Input Errors</li> <li>Phase 7 Validation Errors</li> <li>Kernel Rejection Errors</li> <li>Infrastructure / Transport Errors</li> </ol> <p>Errors MUST be classified into one and only one domain.</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#4-operator-input-errors","title":"4. Operator Input Errors","text":""},{"location":"CONTROL_PLANE_ERROR_MODEL/#41-definition","title":"4.1 Definition","text":"<p>Errors caused by invalid or incomplete operator input.</p> <p>Examples:</p> <ul> <li>Missing required arguments</li> <li>Invalid node identifiers</li> <li>Malformed requests</li> </ul>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#42-rules","title":"4.2 Rules","text":"<ul> <li>MUST be detected before kernel interaction</li> <li>MUST NOT reach the kernel</li> <li>MUST be reported with precise field-level detail</li> </ul> <p>Execution MUST NOT occur.</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#5-phase-7-validation-errors","title":"5. Phase 7 Validation Errors","text":""},{"location":"CONTROL_PLANE_ERROR_MODEL/#51-definition","title":"5.1 Definition","text":"<p>Errors arising from Phase 7 invariant enforcement or precondition checks.</p> <p>Examples:</p> <ul> <li>Missing confirmation</li> <li>Invalid authority level</li> <li>Confirmation reuse attempt</li> <li>Scope violation</li> </ul>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#52-rules","title":"5.2 Rules","text":"<ul> <li>MUST be deterministic</li> <li>MUST reference violated Phase 7 invariants</li> <li>MUST NOT be retried automatically</li> </ul> <p>Execution MUST NOT occur.</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#6-kernel-rejection-errors","title":"6. Kernel Rejection Errors","text":""},{"location":"CONTROL_PLANE_ERROR_MODEL/#61-definition","title":"6.1 Definition","text":"<p>Errors returned by the correctness kernel (Phases 0\u20136).</p> <p>Examples:</p> <ul> <li>Invariant violations</li> <li>Promotion safety rejection</li> <li>WAL prefix mismatch</li> </ul>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#62-rules","title":"6.2 Rules","text":"<ul> <li>MUST be surfaced verbatim</li> <li>MUST NOT be wrapped or softened</li> <li>MUST preserve kernel error codes and explanations</li> </ul> <p>Phase 7 MUST NOT reinterpret kernel intent.</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#7-infrastructure-transport-errors","title":"7. Infrastructure / Transport Errors","text":""},{"location":"CONTROL_PLANE_ERROR_MODEL/#71-definition","title":"7.1 Definition","text":"<p>Errors arising from:</p> <ul> <li>Network failure</li> <li>Control-plane crash</li> <li>Timeout before kernel acknowledgement</li> </ul>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#72-rules","title":"7.2 Rules","text":"<ul> <li>MUST be treated as unknown execution outcome</li> <li>MUST NOT assume success</li> <li>MUST require explicit operator re-issuance</li> </ul> <p>If kernel state cannot prove execution, the action is considered not executed.</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#8-error-semantics","title":"8. Error Semantics","text":""},{"location":"CONTROL_PLANE_ERROR_MODEL/#81-determinism","title":"8.1 Determinism","text":"<p>Given identical inputs and system state:</p> <ul> <li>The same error MUST be produced</li> <li>With the same classification and explanation</li> </ul>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#82-no-error-recovery","title":"8.2 No Error Recovery","text":"<p>Phase 7 MUST NOT:</p> <ul> <li>Retry failed actions</li> <li>Attempt fallback execution</li> <li>Mask errors with retries</li> </ul> <p>All recovery is explicit and human-driven.</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#83-no-partial-success","title":"8.3 No Partial Success","text":"<p>Errors MUST imply:</p> <ul> <li>No kernel mutation occurred</li> <li>Or kernel state must prove otherwise</li> </ul> <p>Ambiguous outcomes are forbidden.</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#9-error-representation","title":"9. Error Representation","text":"<p>Errors MUST include:</p> <ul> <li>Error domain</li> <li>Stable error code</li> <li>Human-readable message</li> <li>Referenced invariant(s), if applicable</li> <li>Execution outcome (executed / not executed)</li> </ul> <p>Free-form or ad-hoc errors are forbidden.</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#10-error-and-observability-interaction","title":"10. Error and Observability Interaction","text":"<p>Errors MUST:</p> <ul> <li>Be observable</li> <li>Be auditable</li> <li>Appear in timelines</li> </ul> <p>Errors MUST NOT:</p> <ul> <li>Influence future behavior</li> <li>Trigger recommendations</li> </ul>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#11-error-and-confirmation-interaction","title":"11. Error and Confirmation Interaction","text":"<p>Errors MUST NOT:</p> <ul> <li>Consume confirmations</li> <li>Allow confirmation reuse</li> </ul> <p>A new attempt always requires new confirmation.</p>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#12-error-testing-requirements","title":"12. Error Testing Requirements","text":"<p>The error model MUST be tested to ensure:</p> <ul> <li>Correct domain classification</li> <li>Correct invariant references</li> <li>No retries occur implicitly</li> <li>Deterministic output</li> </ul> <p>Tests MUST include:</p> <ul> <li>Operator input errors</li> <li>Phase 7 invariant violations</li> <li>Kernel rejections</li> <li>Transport failures</li> </ul>"},{"location":"CONTROL_PLANE_ERROR_MODEL/#13-final-statement","title":"13. Final Statement","text":"<p>Errors exist to prevent silent harm.</p> <p>They must be:</p> <ul> <li>Explicit</li> <li>Honest</li> <li>Deterministic</li> <li>Action-stopping</li> </ul> <p>If an error can be ignored, Phase 7 is wrong.</p> <p>This error model is authoritative.</p> <p>END OF PHASE 7 ERROR MODEL</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/","title":"PHASE 7 FAILURE MODEL \u2014 CONTROL PLANE CRASH, ERROR, AND RECOVERY SEMANTICS","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 NON-NEGOTIABLE</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the failure model for Phase 7.</p> <p>Phase 7 failures are fundamentally different from data-plane failures:</p> <ul> <li>They MUST NOT affect data correctness</li> <li>They MUST NOT alter kernel state implicitly</li> <li>They MUST NOT create ambiguity about what has or has not executed</li> </ul> <p>This document ensures that control-plane failure cannot become system failure.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#2-failure-philosophy","title":"2. Failure Philosophy","text":"<p>When the control plane fails, the system must remain unchanged.</p> <p>Phase 7 failures are handled by:</p> <ul> <li>Explicit rejection</li> <li>Explicit termination</li> <li>Explicit operator re-issuance</li> </ul> <p>Phase 7 never attempts to repair, retry, or complete an action after failure.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#3-failure-domains","title":"3. Failure Domains","text":"<p>Phase 7 defines the following failure domains:</p> <ol> <li>Client-side failures (UI / CLI)</li> <li>Control-plane process failures</li> <li>Network and transport failures</li> <li>Kernel rejection or failure</li> <li>Operator-induced errors</li> </ol> <p>Each domain is handled explicitly and deterministically.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#4-client-side-failures-ui-cli","title":"4. Client-Side Failures (UI / CLI)","text":""},{"location":"CONTROL_PLANE_FAILURE_MODEL/#41-crash-or-termination-before-request-submission","title":"4.1 Crash or Termination Before Request Submission","text":"<p>If the UI or CLI crashes before a request is submitted:</p> <ul> <li>No request reaches the kernel</li> <li>No state change occurs</li> <li>No audit record of execution is created</li> </ul> <p>Outcome:</p> <ul> <li>System state is unchanged</li> <li>Operator must reissue the request</li> </ul>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#42-crash-after-request-submission-before-confirmation","title":"4.2 Crash After Request Submission, Before Confirmation","text":"<p>If a mutating action requires confirmation and the client crashes before confirmation:</p> <ul> <li>The request MUST NOT be executed</li> <li>No kernel action occurs</li> </ul> <p>Outcome:</p> <ul> <li>Action is discarded</li> <li>Operator must restart and reissue</li> </ul>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#43-client-crash-after-confirmation-before-response","title":"4.3 Client Crash After Confirmation, Before Response","text":"<p>If the client crashes after confirmation but before receiving a response:</p> <ul> <li>The execution outcome MUST be determined from kernel state</li> <li>The control plane MUST NOT guess</li> </ul> <p>Rules:</p> <ul> <li>If kernel state reflects execution \u2192 action succeeded</li> <li>Otherwise \u2192 action did not occur</li> </ul> <p>Client-side uncertainty does not alter system truth.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#5-control-plane-process-failures","title":"5. Control-Plane Process Failures","text":""},{"location":"CONTROL_PLANE_FAILURE_MODEL/#51-crash-before-kernel-request-dispatch","title":"5.1 Crash Before Kernel Request Dispatch","text":"<p>If the control-plane process crashes before forwarding a request:</p> <ul> <li>No kernel request occurs</li> <li>No state change occurs</li> </ul> <p>Outcome:</p> <ul> <li>Action did not execute</li> </ul>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#52-crash-during-kernel-request-dispatch","title":"5.2 Crash During Kernel Request Dispatch","text":"<p>If the control-plane process crashes while dispatching a request:</p> <ul> <li>The request is treated as not executed unless kernel durability proves otherwise</li> </ul> <p>Rules:</p> <ul> <li>No assumptions are allowed</li> <li>Kernel state is authoritative</li> </ul>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#53-crash-after-kernel-acknowledgement","title":"5.3 Crash After Kernel Acknowledgement","text":"<p>If the control-plane process crashes after the kernel acknowledges execution:</p> <ul> <li>The action is considered executed</li> <li>Recovery MUST rely on kernel state only</li> </ul> <p>The control plane does not attempt replay.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#6-network-and-transport-failures","title":"6. Network and Transport Failures","text":""},{"location":"CONTROL_PLANE_FAILURE_MODEL/#61-request-transmission-failure","title":"6.1 Request Transmission Failure","text":"<p>If a request fails to reach the kernel:</p> <ul> <li>The action MUST NOT execute</li> </ul> <p>Outcome:</p> <ul> <li>Operator must reissue</li> </ul>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#62-duplicate-requests","title":"6.2 Duplicate Requests","text":"<p>If duplicate requests are received:</p> <p>Rules:</p> <ul> <li>The control plane MUST detect duplicates where possible</li> <li>Otherwise, the kernel MUST reject duplicates deterministically</li> </ul> <p>Silent duplicate execution is forbidden.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#7-kernel-rejection-and-failure","title":"7. Kernel Rejection and Failure","text":""},{"location":"CONTROL_PLANE_FAILURE_MODEL/#71-kernel-rejection","title":"7.1 Kernel Rejection","text":"<p>If the kernel rejects a request:</p> <ul> <li>The rejection MUST be surfaced verbatim</li> <li>The control plane MUST NOT reinterpret or retry</li> </ul> <p>Kernel rejection is final.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#72-kernel-failure","title":"7.2 Kernel Failure","text":"<p>If the kernel fails (crash, fatal error) during request handling:</p> <ul> <li>The control plane MUST treat the request as not executed unless kernel durability proves otherwise</li> </ul> <p>Operator must investigate kernel state explicitly.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#8-operator-induced-errors","title":"8. Operator-Induced Errors","text":""},{"location":"CONTROL_PLANE_FAILURE_MODEL/#81-invalid-requests","title":"8.1 Invalid Requests","text":"<p>If an operator issues an invalid request:</p> <ul> <li>The request is rejected</li> <li>The rejection must include explanation</li> </ul> <p>No attempt is made to auto-correct input.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#82-abandoned-operations","title":"8.2 Abandoned Operations","text":"<p>If an operator abandons an operation mid-flow:</p> <ul> <li>No partial execution may occur</li> <li>No cleanup action is triggered automatically</li> </ul> <p>The system remains unchanged.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#9-failure-visibility-and-audit","title":"9. Failure Visibility and Audit","text":"<p>All failures MUST:</p> <ul> <li>Be observable</li> <li>Be logged</li> <li>Be explainable</li> </ul> <p>Audit records MUST include:</p> <ul> <li>Failure type</li> <li>Time</li> <li>Affected request</li> <li>Outcome (executed / not executed)</li> </ul>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#10-recovery-rules","title":"10. Recovery Rules","text":"<p>Phase 7 recovery is trivial by design.</p> <p>Rules:</p> <ul> <li>No in-flight state is recovered</li> <li>No partial execution is completed</li> <li>No retries are attempted</li> </ul> <p>Recovery means restart and resume observation only.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#11-explicit-non-recovery","title":"11. Explicit Non-Recovery","text":"<p>Phase 7 MUST NOT:</p> <ul> <li>Attempt rollback</li> <li>Attempt roll-forward</li> <li>Attempt reconciliation</li> </ul> <p>Those concepts belong to the kernel only.</p>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#12-testing-requirements","title":"12. Testing Requirements","text":"<p>Phase 7 failure handling MUST be tested for:</p> <ul> <li>Client crash scenarios</li> <li>Control-plane crash scenarios</li> <li>Network failure scenarios</li> <li>Kernel rejection propagation</li> </ul> <p>Tests MUST assert:</p> <ul> <li>No partial execution</li> <li>No hidden retries</li> <li>Deterministic outcomes</li> </ul>"},{"location":"CONTROL_PLANE_FAILURE_MODEL/#13-final-statement","title":"13. Final Statement","text":"<p>Phase 7 failure handling exists to protect correctness by doing nothing.</p> <p>It prefers:</p> <ul> <li>Rejection over uncertainty</li> <li>Restart over repair</li> <li>Human re-issuance over automation</li> </ul> <p>If the control plane fails, the safest action is inaction.</p> <p>This failure model is absolute.</p> <p>END OF PHASE 7 FAILURE MODEL</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/","title":"PHASE 7 FREEZE CHECKLIST \u2014 FINAL GATE FOR IMMUTABILITY","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 FREEZE GATE</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document is the final, mandatory checklist required to freeze Phase 7.</p> <p>It exists to:</p> <ul> <li>Eliminate ambiguity</li> <li>Prevent assumption-based freeze decisions</li> <li>Force explicit verification of all Phase 7 guarantees</li> </ul> <p>Phase 7 MUST NOT be frozen unless every item in this checklist is satisfied and explicitly confirmed.</p> <p>This checklist is binary.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#2-freeze-rule","title":"2. Freeze Rule","text":"<p>If any checklist item cannot be answered \u201cYES\u201d with evidence, Phase 7 MUST NOT be frozen.</p> <p>No partial freeze is allowed. No conditional freeze is allowed.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#3-documentation-verification","title":"3. Documentation Verification","text":"<p>Confirm that the following documents:</p> <ul> <li>Exist</li> <li>Are complete</li> <li>Are internally consistent</li> <li>Are mutually non-contradictory</li> </ul>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#required-documents","title":"Required Documents","text":"<ul> <li> CONTROL_PLANE_VISION.md</li> <li> CONTROL_PLANE_SCOPE.md</li> <li> CONTROL_PLANE_INVARIANTS.md</li> <li> CONTROL_PLANE_AUTHORITY_MODEL.md</li> <li> CONTROL_PLANE_FAILURE_MODEL.md</li> <li> CONTROL_PLANE_STATE_MODEL.md</li> <li> CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE.md</li> <li> CONTROL_PLANE_COMMAND_MODEL.md</li> <li> CONTROL_PLANE_CONFIRMATION_MODEL.md</li> <li> CONTROL_PLANE_OBSERVABILITY_MODEL.md</li> <li> CONTROL_PLANE_ERROR_MODEL.md</li> <li> CONTROL_PLANE_AUDITABILITY.md</li> <li> CONTROL_PLANE_TESTING_STRATEGY.md</li> <li> CONTROL_PLANE_READINESS.md</li> <li> CONTROL_PLANE_FREEZE_CHECKLIST.md</li> </ul> <p>If any document is missing or contradictory \u2192 FAIL.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#4-invariant-enforcement-verification","title":"4. Invariant Enforcement Verification","text":"<p>Confirm that every Phase 7 invariant:</p> <ul> <li> Is enforced in code</li> <li> Is enforced by tests</li> <li> Cannot be bypassed via UI</li> <li> Cannot be bypassed via CLI</li> </ul> <p>Any invariant that exists only on paper \u2192 FAIL.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#5-command-surface-verification","title":"5. Command Surface Verification","text":"<p>Confirm that:</p> <ul> <li> All operator commands are defined in CONTROL_PLANE_COMMAND_MODEL.md</li> <li> No undocumented or experimental commands exist</li> <li> Each command maps to exactly one kernel action</li> </ul> <p>Any undocumented command \u2192 FAIL.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#6-confirmation-safety-verification","title":"6. Confirmation Safety Verification","text":"<p>Confirm that:</p> <ul> <li> All mutating commands require explicit confirmation</li> <li> Override commands require enhanced confirmation</li> <li> No command executes without confirmation</li> <li> Confirmations are non-reusable and non-durable</li> </ul> <p>Any execution without confirmation \u2192 FAIL.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#7-failure-handling-verification","title":"7. Failure Handling Verification","text":"<p>Confirm that:</p> <ul> <li> Control-plane crashes do not mutate kernel state</li> <li> Network failures do not cause partial execution</li> <li> Ambiguous outcomes are treated as not executed</li> <li> No automatic retries mutate state</li> </ul> <p>Any ambiguous execution outcome \u2192 FAIL.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#8-auditability-verification","title":"8. Auditability Verification","text":"<p>Confirm that:</p> <ul> <li> Every command attempt produces an audit record</li> <li> Every confirmation produces an audit record</li> <li> Every failure produces an audit record</li> <li> Control-plane crashes do not erase audit data</li> <li> Audit records support full reconstruction</li> </ul> <p>Missing audit trail \u2192 FAIL.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#9-observability-isolation-verification","title":"9. Observability Isolation Verification","text":"<p>Confirm that:</p> <ul> <li> Observability is passive</li> <li> Observability cannot trigger actions</li> <li> Observability failures do not affect behavior</li> </ul> <p>Any observability-driven action \u2192 FAIL.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#10-non-interference-verification","title":"10. Non-Interference Verification","text":"<p>Confirm that:</p> <ul> <li> Kernel behavior is identical with Phase 7 disabled</li> <li> Phase 7 does not alter kernel timing or ordering</li> <li> Phase 7 does not alter durability semantics</li> </ul> <p>Any interference \u2192 FAIL.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#11-testing-verification","title":"11. Testing Verification","text":"<p>Confirm that:</p> <ul> <li> All tests defined in CONTROL_PLANE_TESTING_STRATEGY.md pass</li> <li> All invariants have negative tests</li> <li> No flaky or nondeterministic tests exist</li> </ul> <p>Test gaps \u2192 FAIL.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#12-explicit-non-existence-verification","title":"12. Explicit Non-Existence Verification","text":"<p>Confirm that Phase 7 contains none of the following:</p> <ul> <li> Automation</li> <li> Heuristics</li> <li> Background control loops</li> <li> Recommendation engines</li> <li> Silent retries</li> </ul> <p>Presence of any above \u2192 FAIL.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#13-responsibility-confirmation","title":"13. Responsibility Confirmation","text":"<p>Confirm that:</p> <ul> <li> Operator responsibility is explicit</li> <li> Overrides transfer responsibility clearly</li> <li> No action is executed without accountability</li> </ul> <p>Unattributable actions \u2192 FAIL.</p>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#14-final-freeze-declaration","title":"14. Final Freeze Declaration","text":"<p>Phase 7 may be frozen only if:</p> <ul> <li>All checklist items above are checked</li> <li>All failures have been resolved</li> <li>No open TODOs or deferred correctness work exists</li> </ul> <p>When all conditions are met, record the following:</p> <ul> <li>Freeze Date: ______________________</li> <li>Freeze Authority: __________________</li> <li>Evidence Location: _________________</li> </ul>"},{"location":"CONTROL_PLANE_FREEZE_CHECKLIST/#15-final-statement","title":"15. Final Statement","text":"<p>Phase 7 freeze is a point of no return.</p> <p>After freeze:</p> <ul> <li>Phase 7 behavior is immutable</li> <li>Any change requires reopening the phase</li> </ul> <p>If there is doubt, do not freeze.</p> <p>This checklist is the final authority.</p> <p>END OF PHASE 7 FREEZE CHECKLIST</p>"},{"location":"CONTROL_PLANE_INVARIANTS/","title":"PHASE 7 INVARIANTS \u2014 CONTROL PLANE SAFETY &amp; DISCIPLINE","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 NON-NEGOTIABLE</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the absolute invariants governing Phase 7.</p> <p>An invariant is a rule that MUST hold:</p> <ul> <li>During normal operation</li> <li>Under operator error</li> <li>Under partial failure</li> <li>Under crashes of the control plane</li> <li>Under retries and reconnects</li> </ul> <p>If any invariant is violated, Phase 7 is incorrect, regardless of intent or convenience.</p> <p>Phase 7 invariants exist to ensure that power does not become autonomy.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#2-relationship-to-earlier-phases","title":"2. Relationship to Earlier Phases","text":"<p>Phase 7 invariants are strictly subordinate to Phases 0\u20136.</p> <p>Rules:</p> <ul> <li>Phase 7 MUST NOT weaken, reinterpret, or bypass any invariant from Phases 0\u20136</li> <li>Phase 7 invariants apply only to the control plane</li> <li>If Phase 7 conflicts with the kernel, the kernel always wins</li> </ul> <p>Phase 7 is replaceable. The correctness kernel is not.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#3-invariant-categories","title":"3. Invariant Categories","text":"<p>Phase 7 invariants are grouped into the following categories:</p> <ol> <li>Authority &amp; Intent Invariants</li> <li>Execution Invariants</li> <li>Failure Invariants</li> <li>Determinism Invariants</li> <li>Observability &amp; Audit Invariants</li> <li>Scope &amp; Non-Interference Invariants</li> </ol> <p>Every invariant is mandatory.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#4-authority-intent-invariants","title":"4. Authority &amp; Intent Invariants","text":""},{"location":"CONTROL_PLANE_INVARIANTS/#p7-a1-no-implicit-authority","title":"P7-A1 \u2014 No Implicit Authority","text":"<p>Phase 7 MUST NOT create authority implicitly.</p> <p>Rules:</p> <ul> <li>Every mutating action MUST originate from an explicit operator request</li> <li>Viewing state MUST NOT grant authority</li> <li>UI focus, refresh, or reconnect MUST NOT trigger actions</li> </ul> <p>Violation of this invariant is a critical bug.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#p7-a2-explicit-human-intent","title":"P7-A2 \u2014 Explicit Human Intent","text":"<p>Every mutating action MUST be traceable to a conscious human decision.</p> <p>Rules:</p> <ul> <li>Commands MUST be explicitly issued</li> <li>Dangerous actions MUST require confirmation</li> <li>No default acceptance is allowed</li> </ul> <p>If intent cannot be proven, the action MUST NOT execute.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#p7-a3-no-delegated-decision-making","title":"P7-A3 \u2014 No Delegated Decision-Making","text":"<p>Phase 7 MUST NOT decide on behalf of the operator.</p> <p>Rules:</p> <ul> <li>No automatic recommendations that execute</li> <li>No ranking or scoring of nodes</li> <li>No policy engines</li> </ul> <p>Phase 7 may explain facts, never choices.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#5-execution-invariants","title":"5. Execution Invariants","text":""},{"location":"CONTROL_PLANE_INVARIANTS/#p7-e1-single-explicit-action","title":"P7-E1 \u2014 Single Explicit Action","text":"<p>Each operator command MUST correspond to exactly one kernel action.</p> <p>Rules:</p> <ul> <li>No command chaining</li> <li>No implicit follow-up actions</li> <li>No batch mutation without explicit repetition</li> </ul> <p>If multiple kernel actions are desired, they must be requested separately.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#p7-e2-no-partial-execution","title":"P7-E2 \u2014 No Partial Execution","text":"<p>Phase 7 MUST NOT produce partial success.</p> <p>Rules:</p> <ul> <li>Actions are either executed fully or not at all</li> <li>If execution outcome is unknown, it MUST be treated as failed</li> </ul> <p>Ambiguous outcomes are forbidden.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#p7-e3-kernel-validation-is-final","title":"P7-E3 \u2014 Kernel Validation Is Final","text":"<p>All safety decisions are made by the kernel.</p> <p>Rules:</p> <ul> <li>Phase 7 MUST forward requests verbatim</li> <li>Kernel rejections MUST NOT be overridden</li> <li>Phase 7 MUST surface kernel errors exactly</li> </ul> <p>Control plane logic may not second-guess correctness logic.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#6-failure-invariants","title":"6. Failure Invariants","text":""},{"location":"CONTROL_PLANE_INVARIANTS/#p7-f1-fail-closed","title":"P7-F1 \u2014 Fail Closed","text":"<p>Under any failure, Phase 7 MUST fail closed.</p> <p>Rules:</p> <ul> <li>No retries that mutate state</li> <li>No fallback execution paths</li> <li>No speculative execution</li> </ul> <p>Operator re-issuance is the only recovery path.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#p7-f2-control-plane-crash-safety","title":"P7-F2 \u2014 Control Plane Crash Safety","text":"<p>A crash of the control plane MUST NOT:</p> <ul> <li>Mutate kernel state</li> <li>Complete partially executed actions</li> <li>Leave the system in an ambiguous state</li> </ul> <p>If the control plane crashes mid-request, the request is considered not executed.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#p7-f3-no-hidden-retries","title":"P7-F3 \u2014 No Hidden Retries","text":"<p>Phase 7 MUST NOT retry mutating actions automatically.</p> <p>Rules:</p> <ul> <li>Network retries MUST be surfaced</li> <li>Duplicate requests MUST be detected or rejected</li> </ul> <p>Silent retry is forbidden.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#7-determinism-invariants","title":"7. Determinism Invariants","text":""},{"location":"CONTROL_PLANE_INVARIANTS/#p7-d1-deterministic-presentation","title":"P7-D1 \u2014 Deterministic Presentation","text":"<p>Given identical kernel state and inputs, Phase 7 MUST:</p> <ul> <li>Display identical information</li> <li>Produce identical explanations</li> </ul> <p>UI rendering MUST NOT affect semantics.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#p7-d2-deterministic-decision-results","title":"P7-D2 \u2014 Deterministic Decision Results","text":"<p>Given identical requests and kernel state, Phase 7 MUST:</p> <ul> <li>Accept or reject requests identically</li> <li>Surface identical denial reasons</li> </ul> <p>No timing-based divergence is allowed.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#8-observability-audit-invariants","title":"8. Observability &amp; Audit Invariants","text":""},{"location":"CONTROL_PLANE_INVARIANTS/#p7-o1-complete-observability","title":"P7-O1 \u2014 Complete Observability","text":"<p>All Phase 7 actions MUST be observable.</p> <p>Rules:</p> <ul> <li>Requests, decisions, and outcomes must be logged</li> <li>Observability must not block execution</li> </ul>"},{"location":"CONTROL_PLANE_INVARIANTS/#p7-o2-explainability","title":"P7-O2 \u2014 Explainability","text":"<p>Every decision MUST be explainable.</p> <p>Rules:</p> <ul> <li>Rejections MUST reference violated invariants</li> <li>Explanations MUST be deterministic</li> </ul>"},{"location":"CONTROL_PLANE_INVARIANTS/#p7-o3-auditability","title":"P7-O3 \u2014 Auditability","text":"<p>Phase 7 MUST support post-incident reconstruction.</p> <p>Audit records MUST include:</p> <ul> <li>Operator identity (if known)</li> <li>Timestamp</li> <li>Requested action</li> <li>Kernel state summary</li> <li>Outcome</li> </ul> <p>If an action cannot be reconstructed, this invariant is violated.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#9-scope-non-interference-invariants","title":"9. Scope &amp; Non-Interference Invariants","text":""},{"location":"CONTROL_PLANE_INVARIANTS/#p7-s1-no-background-activity","title":"P7-S1 \u2014 No Background Activity","text":"<p>Phase 7 MUST NOT run background processes that mutate state.</p> <p>All mutation must be synchronous with an operator request.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#p7-s2-no-correctness-interference","title":"P7-S2 \u2014 No Correctness Interference","text":"<p>Phase 7 MUST NOT:</p> <ul> <li>Alter kernel timing</li> <li>Alter execution order</li> <li>Alter durability semantics</li> </ul> <p>Kernel behavior must be identical with or without Phase 7.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#p7-s3-no-expansion-beyond-scope","title":"P7-S3 \u2014 No Expansion Beyond Scope","text":"<p>Any feature not explicitly allowed in CONTROL_PLANE_SCOPE.md is forbidden.</p> <p>This invariant is enforced socially and technically.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#10-enforcement-testing-requirements","title":"10. Enforcement &amp; Testing Requirements","text":"<p>Each invariant MUST:</p> <ul> <li>Be enforceable by code</li> <li>Be testable</li> <li>Have at least one negative test</li> </ul> <p>If an invariant cannot be tested, Phase 7 is incomplete.</p>"},{"location":"CONTROL_PLANE_INVARIANTS/#11-final-statement","title":"11. Final Statement","text":"<p>Phase 7 invariants exist to prevent operator tooling from becoming an autonomous system.</p> <p>They are intentionally conservative.</p> <p>If Phase 7 ever acts without a human asking it to, it is wrong.</p> <p>These invariants are absolute.</p> <p>END OF PHASE 7 INVARIANTS</p>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/","title":"PHASE 7 OBSERVABILITY MODEL \u2014 VISIBILITY WITHOUT CONTROL","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 NON-NEGOTIABLE</p>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the observability model for Phase 7.</p> <p>Its purpose is to ensure that:</p> <ul> <li>Operators can understand system behavior</li> <li>Failures can be investigated post\u2011incident</li> <li>Decisions can be reconstructed and explained</li> </ul> <p>\u2026without observability ever becoming a control mechanism.</p> <p>Observability exists to illuminate reality, not to change it.</p>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#2-foundational-principle","title":"2. Foundational Principle","text":"<p>Observability must be strictly passive.</p> <p>Observability:</p> <ul> <li>MAY read kernel state</li> <li>MAY read event streams</li> <li>MAY read audit logs</li> </ul> <p>Observability:</p> <ul> <li>MUST NOT trigger actions</li> <li>MUST NOT influence control flow</li> <li>MUST NOT infer or recommend decisions</li> </ul> <p>If observability alters behavior, it is incorrect.</p>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#3-sources-of-observability","title":"3. Sources of Observability","text":"<p>Phase 7 observability is derived from authoritative sources only:</p> <ol> <li>Kernel event streams (Phases 0\u20136)</li> <li>Kernel state snapshots</li> <li>Phase 6 explanation artifacts</li> <li>Phase 7 audit logs</li> </ol> <p>No synthetic or speculative sources are allowed.</p>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#4-observability-surfaces","title":"4. Observability Surfaces","text":"<p>Phase 7 MAY expose the following surfaces.</p>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#41-state-views","title":"4.1 State Views","text":"<ul> <li>Current cluster topology</li> <li>Node roles and liveness</li> <li>Replication state and lag</li> <li>Promotion / demotion state</li> </ul> <p>Rules:</p> <ul> <li>Views must reflect a single kernel snapshot</li> <li>Partial or mixed views are forbidden</li> </ul>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#42-event-timelines","title":"4.2 Event Timelines","text":"<ul> <li>Ordered kernel events</li> <li>Promotion state transitions</li> <li>Failover\u2011related decisions</li> </ul> <p>Rules:</p> <ul> <li>Events must be immutable</li> <li>Ordering must be explicit</li> <li>Gaps must be visible, not hidden</li> </ul>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#43-explanation-views","title":"4.3 Explanation Views","text":"<ul> <li>Pre\u2011execution explanations</li> <li>Rejection explanations</li> <li>Invariant references</li> </ul> <p>Rules:</p> <ul> <li>Explanations must be deterministic</li> <li>Explanations must reference concrete invariants</li> </ul>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#44-audit-trails","title":"4.4 Audit Trails","text":"<ul> <li>Operator commands</li> <li>Confirmations</li> <li>Outcomes</li> </ul> <p>Rules:</p> <ul> <li>Append\u2011only</li> <li>Tamper\u2011evident</li> <li>Never editable</li> </ul>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#5-temporal-semantics","title":"5. Temporal Semantics","text":"<p>Observability must respect explicit time semantics.</p> <p>Rules:</p> <ul> <li>Every observation is timestamped</li> <li>Clock source must be declared</li> <li>Ordering must not rely on wall\u2011clock assumptions</li> </ul> <p>If ordering is uncertain, it must be marked as such.</p>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#6-observability-and-failure","title":"6. Observability and Failure","text":"<p>Under failure conditions:</p> <ul> <li>Observability may degrade</li> <li>Observability may become unavailable</li> </ul> <p>But:</p> <ul> <li>Kernel behavior must remain unchanged</li> <li>Control plane behavior must remain unchanged</li> </ul> <p>Observability failure is never a reason to retry or act.</p>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#7-observability-and-determinism","title":"7. Observability and Determinism","text":"<p>Given identical inputs and kernel state:</p> <ul> <li>Observability output must be identical</li> <li>Explanations must not vary</li> </ul> <p>UI rendering differences must not affect semantics.</p>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#8-forbidden-observability-patterns","title":"8. Forbidden Observability Patterns","text":"<p>Phase 7 MUST NOT:</p> <ul> <li>Suggest actions</li> <li>Highlight \u201crecommended\u201d paths</li> <li>Auto\u2011select defaults based on state</li> <li>Hide or smooth over failures</li> </ul> <p>Observability must present facts, not guidance.</p>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#9-privacy-and-sensitivity-boundaries","title":"9. Privacy and Sensitivity Boundaries","text":"<p>Observability MUST respect conceptual boundaries:</p> <ul> <li>Sensitive kernel internals may be summarized</li> <li>Raw data exposure must be intentional</li> </ul> <p>This document defines visibility boundaries, not access control.</p>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#10-observability-and-testing-requirements","title":"10. Observability and Testing Requirements","text":"<p>The observability model MUST be tested to ensure:</p> <ul> <li>Observability never triggers control actions</li> <li>Missing observability does not alter behavior</li> <li>Explanations match kernel decisions</li> </ul> <p>Tests must simulate:</p> <ul> <li>Partial observability</li> <li>Delayed event streams</li> <li>Missing logs</li> </ul>"},{"location":"CONTROL_PLANE_OBSERVABILITY_MODEL/#11-final-statement","title":"11. Final Statement","text":"<p>Observability exists to explain what happened, not to decide what should happen.</p> <p>It must remain:</p> <ul> <li>Passive</li> <li>Deterministic</li> <li>Honest</li> </ul> <p>If observability ever influences action, Phase 7 is wrong.</p> <p>This observability model is authoritative.</p> <p>END OF PHASE 7 OBSERVABILITY MODEL</p>"},{"location":"CONTROL_PLANE_READINESS/","title":"PHASE 7 READINESS \u2014 COMPLETION CRITERIA AND LAUNCH GATE","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 PRE-FREEZE</p>"},{"location":"CONTROL_PLANE_READINESS/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines what it means for Phase 7 to be complete and ready.</p> <p>Phase 7 readiness is not subjective. It is not based on feature count, UI polish, or perceived usability.</p> <p>Phase 7 is ready only when it is provably incapable of violating AeroDB\u2019s correctness guarantees.</p> <p>This document is the formal gate between:</p> <ul> <li>\u201cPhase 7 exists\u201d</li> <li>\u201cPhase 7 is safe to freeze and ship\u201d</li> </ul>"},{"location":"CONTROL_PLANE_READINESS/#2-readiness-philosophy","title":"2. Readiness Philosophy","text":"<p>A control plane is ready when it can do nothing safely, not everything conveniently.</p> <p>Phase 7 readiness prioritizes:</p> <ol> <li>Safety over completeness</li> <li>Explicit rejection over implicit behavior</li> <li>Auditability over convenience</li> <li>Operator responsibility over system autonomy</li> </ol> <p>If any readiness requirement is ambiguous, Phase 7 is not ready.</p>"},{"location":"CONTROL_PLANE_READINESS/#3-mandatory-readiness-preconditions","title":"3. Mandatory Readiness Preconditions","text":"<p>Phase 7 may be considered ready only if all conditions in this section are met.</p> <p>Failure of any single condition blocks readiness.</p>"},{"location":"CONTROL_PLANE_READINESS/#31-documentation-completeness","title":"3.1 Documentation Completeness","text":"<p>The following documents MUST exist, be complete, and be internally consistent:</p> <ol> <li>CONTROL_PLANE_VISION.md</li> <li>CONTROL_PLANE_SCOPE.md</li> <li>CONTROL_PLANE_INVARIANTS.md</li> <li>CONTROL_PLANE_AUTHORITY_MODEL.md</li> <li>CONTROL_PLANE_FAILURE_MODEL.md</li> <li>CONTROL_PLANE_STATE_MODEL.md</li> <li>CONTROL_PLANE_CONTROL_PLANE_ARCHITECTURE.md</li> <li>CONTROL_PLANE_COMMAND_MODEL.md</li> <li>CONTROL_PLANE_CONFIRMATION_MODEL.md</li> <li>CONTROL_PLANE_OBSERVABILITY_MODEL.md</li> <li>CONTROL_PLANE_ERROR_MODEL.md</li> <li>CONTROL_PLANE_AUDITABILITY.md</li> <li>CONTROL_PLANE_TESTING_STRATEGY.md</li> <li>CONTROL_PLANE_READINESS.md</li> </ol> <p>Missing or contradictory documentation blocks readiness.</p>"},{"location":"CONTROL_PLANE_READINESS/#32-invariant-enforcement","title":"3.2 Invariant Enforcement","text":"<p>All Phase 7 invariants MUST be:</p> <ul> <li>Enforced in code</li> <li>Enforced by tests</li> <li>Impossible to bypass via UI or CLI</li> </ul> <p>Any invariant that exists only on paper blocks readiness.</p>"},{"location":"CONTROL_PLANE_READINESS/#33-command-surface-closure","title":"3.3 Command Surface Closure","text":"<p>The Phase 7 command surface MUST be:</p> <ul> <li>Finite</li> <li>Fully documented</li> <li>Fully tested</li> </ul> <p>No ad-hoc, experimental, or undocumented commands are permitted.</p>"},{"location":"CONTROL_PLANE_READINESS/#34-confirmation-safety","title":"3.4 Confirmation Safety","text":"<p>All mutating and override commands MUST:</p> <ul> <li>Require explicit confirmation</li> <li>Reject execution without confirmation</li> <li>Produce auditable confirmation records</li> </ul> <p>Any path that executes without confirmation blocks readiness.</p>"},{"location":"CONTROL_PLANE_READINESS/#35-failure-safety","title":"3.5 Failure Safety","text":"<p>Phase 7 MUST demonstrate:</p> <ul> <li>Fail-closed behavior under all tested failures</li> <li>No partial execution under crash or timeout</li> <li>Deterministic outcomes under retry and reconnect</li> </ul> <p>Any ambiguous execution outcome blocks readiness.</p>"},{"location":"CONTROL_PLANE_READINESS/#36-auditability-guarantees","title":"3.6 Auditability Guarantees","text":"<p>Phase 7 MUST demonstrate:</p> <ul> <li>Every action produces audit records</li> <li>Failures produce audit records</li> <li>Crashes do not erase audit records</li> <li>Audit records allow full reconstruction</li> </ul> <p>If an action cannot be reconstructed, readiness is blocked.</p>"},{"location":"CONTROL_PLANE_READINESS/#37-non-interference-proof","title":"3.7 Non-Interference Proof","text":"<p>Phase 7 MUST demonstrate that:</p> <ul> <li>Kernel behavior is identical with Phase 7 disabled</li> <li>Observability paths do not mutate state</li> <li>Control-plane crashes do not affect kernel state</li> </ul> <p>Any interference blocks readiness.</p>"},{"location":"CONTROL_PLANE_READINESS/#4-testing-completion-criteria","title":"4. Testing Completion Criteria","text":"<p>Phase 7 testing is complete only if:</p> <ul> <li>All tests defined in CONTROL_PLANE_TESTING_STRATEGY.md pass</li> <li>All invariants have negative tests</li> <li>No flaky or nondeterministic tests exist</li> </ul> <p>Test coverage gaps block readiness.</p>"},{"location":"CONTROL_PLANE_READINESS/#5-operational-readiness-explicitly-limited","title":"5. Operational Readiness (Explicitly Limited)","text":"<p>Phase 7 operational readiness requires:</p> <ul> <li>Deterministic startup</li> <li>Deterministic shutdown</li> <li>Safe restart with no state recovery</li> </ul> <p>Operational convenience features are not required.</p>"},{"location":"CONTROL_PLANE_READINESS/#6-explicit-non-readiness-conditions","title":"6. Explicit Non-Readiness Conditions","text":"<p>Phase 7 is not ready if:</p> <ul> <li>Any automation exists</li> <li>Any background control loop exists</li> <li>Any retry logic mutates state</li> <li>Any UI hint implies recommendation</li> <li>Any confirmation can be bypassed</li> </ul> <p>Presence of any above condition blocks readiness.</p>"},{"location":"CONTROL_PLANE_READINESS/#7-readiness-review-process","title":"7. Readiness Review Process","text":"<p>Phase 7 readiness MUST be established by:</p> <ol> <li>Documentation review</li> <li>Test suite execution</li> <li>Adversarial failure review</li> </ol> <p>Readiness may not be assumed.</p>"},{"location":"CONTROL_PLANE_READINESS/#8-readiness-verdict","title":"8. Readiness Verdict","text":"<p>Phase 7 may be marked READY only if:</p> <ul> <li>All requirements in this document are satisfied</li> <li>No open issues remain</li> <li>No TODOs or deferred correctness work exists</li> </ul> <p>Otherwise, Phase 7 remains NOT READY.</p>"},{"location":"CONTROL_PLANE_READINESS/#9-final-statement","title":"9. Final Statement","text":"<p>Phase 7 readiness means the control plane is:</p> <ul> <li>Powerful enough to be useful</li> <li>Constrained enough to be safe</li> <li>Transparent enough to be trusted</li> </ul> <p>If Phase 7 is convenient but unsafe, it is not ready.</p> <p>This readiness definition is authoritative.</p> <p>END OF PHASE 7 READINESS</p>"},{"location":"CONTROL_PLANE_SCOPE/","title":"PHASE 7 SCOPE \u2014 CONTROL PLANE &amp; OPERATOR INTERACTION","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 PRE-IMPLEMENTATION</p>"},{"location":"CONTROL_PLANE_SCOPE/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the exact scope boundaries of Phase 7.</p> <p>Its purpose is to:</p> <ul> <li>Explicitly state what Phase 7 is allowed to do</li> <li>Explicitly state what Phase 7 is forbidden from doing</li> <li>Prevent scope creep, implicit behavior, and accidental automation</li> </ul> <p>Phase 7 introduces power. This document limits that power.</p> <p>If any behavior is not explicitly permitted in this document, it is out of scope.</p>"},{"location":"CONTROL_PLANE_SCOPE/#2-phase-7-position-in-the-aerodb-architecture","title":"2. Phase 7 Position in the AeroDB Architecture","text":"<p>Phase 7 exists above the correctness kernel (Phases 0\u20136).</p> <p>Architectural layering:</p> <ol> <li> <p>Phases 0\u20136 \u2014 Correctness kernel</p> </li> <li> <p>Durability</p> </li> <li>Determinism</li> <li>Replication correctness</li> <li> <p>Failover safety</p> </li> <li> <p>Phase 7 \u2014 Control plane</p> </li> <li> <p>Human interaction</p> </li> <li>Visibility</li> <li>Explicit commands</li> </ol> <p>Phase 7:</p> <ul> <li>May observe kernel state</li> <li>May request kernel actions</li> <li>May explain kernel decisions</li> </ul> <p>Phase 7:</p> <ul> <li>May NOT reinterpret kernel state</li> <li>May NOT infer kernel safety</li> <li>May NOT bypass kernel validation</li> </ul>"},{"location":"CONTROL_PLANE_SCOPE/#3-in-scope-capabilities-allowed","title":"3. In-Scope Capabilities (Allowed)","text":"<p>The following capabilities are explicitly in scope for Phase 7.</p>"},{"location":"CONTROL_PLANE_SCOPE/#31-read-only-observability","title":"3.1 Read-Only Observability","text":"<p>Phase 7 MAY provide:</p> <ul> <li>Cluster topology views</li> <li>Node role and health summaries</li> <li>Replication lag visibility</li> <li>WAL position visibility</li> <li>Promotion state visibility</li> <li>Historical timelines of events</li> </ul> <p>Rules:</p> <ul> <li>All views must be derived from authoritative kernel state</li> <li>No derived view may be authoritative</li> <li>Observability must be passive</li> </ul>"},{"location":"CONTROL_PLANE_SCOPE/#32-explicit-operator-commands","title":"3.2 Explicit Operator Commands","text":"<p>Phase 7 MAY expose explicit, human-triggered commands, including:</p> <ul> <li>Request promotion or demotion</li> <li>Request role inspection</li> <li>Trigger diagnostics</li> <li>Inspect snapshots, checkpoints, and WAL state</li> </ul> <p>Rules:</p> <ul> <li>Commands must map 1:1 to kernel operations</li> <li>No command may bundle multiple kernel actions implicitly</li> <li>Commands must be rejected if kernel validation fails</li> </ul>"},{"location":"CONTROL_PLANE_SCOPE/#33-pre-execution-explanation","title":"3.3 Pre-Execution Explanation","text":"<p>Phase 7 MAY:</p> <ul> <li>Explain what a requested command will do</li> <li>Explain why it may be rejected</li> <li>Explain which invariants are involved</li> </ul> <p>Rules:</p> <ul> <li>Explanations must be deterministic</li> <li>Explanations must not speculate</li> <li>Explanations must not guarantee success</li> </ul>"},{"location":"CONTROL_PLANE_SCOPE/#34-explicit-confirmation-flows","title":"3.4 Explicit Confirmation Flows","text":"<p>Phase 7 MAY require:</p> <ul> <li>Explicit confirmation for dangerous actions</li> <li>Multi-step acknowledgements for irreversible commands</li> </ul> <p>Rules:</p> <ul> <li>Confirmations must be explicit</li> <li>Confirmations must never auto-expire into execution</li> <li>No implicit confirmation is allowed</li> </ul>"},{"location":"CONTROL_PLANE_SCOPE/#35-audit-trace-surfaces","title":"3.5 Audit &amp; Trace Surfaces","text":"<p>Phase 7 MAY provide:</p> <ul> <li>Operator action logs</li> <li>Command execution timelines</li> <li>Decision explanations</li> <li>Post-incident reconstruction tools</li> </ul> <p>Rules:</p> <ul> <li>Audit data must be append-only</li> <li>Audit data must not affect execution</li> </ul>"},{"location":"CONTROL_PLANE_SCOPE/#4-explicitly-out-of-scope-capabilities-forbidden","title":"4. Explicitly Out-of-Scope Capabilities (Forbidden)","text":"<p>The following capabilities are explicitly forbidden in Phase 7.</p>"},{"location":"CONTROL_PLANE_SCOPE/#41-automation-and-autonomy","title":"4.1 Automation and Autonomy","text":"<p>Phase 7 MUST NOT:</p> <ul> <li>Automatically trigger promotion or demotion</li> <li>Automatically retry failed commands</li> <li>Automatically heal replicas</li> <li>Automatically reconfigure the cluster</li> </ul> <p>Any behavior that changes system state without direct human intent is forbidden.</p>"},{"location":"CONTROL_PLANE_SCOPE/#42-heuristics-and-policy-engines","title":"4.2 Heuristics and Policy Engines","text":"<p>Phase 7 MUST NOT:</p> <ul> <li>Evaluate thresholds</li> <li>Rank nodes</li> <li>Recommend actions</li> <li>Make safety judgments</li> </ul> <p>The system must never tell the operator what it \u201cthinks should be done\u201d.</p>"},{"location":"CONTROL_PLANE_SCOPE/#43-background-control-loops","title":"4.3 Background Control Loops","text":"<p>Phase 7 MUST NOT:</p> <ul> <li>Poll kernel state and act on changes</li> <li>Schedule actions</li> <li>Maintain feedback loops</li> </ul> <p>All actions must originate from a human request.</p>"},{"location":"CONTROL_PLANE_SCOPE/#44-implicit-state-mutation","title":"4.4 Implicit State Mutation","text":"<p>Phase 7 MUST NOT:</p> <ul> <li>Mutate state as a side effect of viewing</li> <li>Mutate state during explanation</li> <li>Mutate state during validation</li> </ul> <p>Read-only operations must remain read-only.</p>"},{"location":"CONTROL_PLANE_SCOPE/#45-correctness-overrides","title":"4.5 Correctness Overrides","text":"<p>Phase 7 MUST NOT:</p> <ul> <li>Override durability rules</li> <li>Override replication invariants</li> <li>Override fail-closed behavior</li> <li>Override kernel rejection decisions</li> </ul> <p>If the kernel rejects an action, Phase 7 must surface the rejection verbatim.</p>"},{"location":"CONTROL_PLANE_SCOPE/#46-bulk-or-compound-actions","title":"4.6 Bulk or Compound Actions","text":"<p>Phase 7 MUST NOT:</p> <ul> <li>Chain multiple actions implicitly</li> <li>Execute batches of mutating commands without explicit operator intent</li> </ul> <p>Every kernel action must be individually requested.</p>"},{"location":"CONTROL_PLANE_SCOPE/#5-explicit-non-goals","title":"5. Explicit Non-Goals","text":"<p>Phase 7 does NOT aim to:</p> <ul> <li>Optimize performance</li> <li>Reduce operator workload via automation</li> <li>Hide complexity</li> <li>Abstract away failure modes</li> </ul> <p>Phase 7 intentionally exposes complexity rather than masking it.</p>"},{"location":"CONTROL_PLANE_SCOPE/#6-failure-handling-scope","title":"6. Failure Handling Scope","text":"<p>Phase 7 is responsible for:</p> <ul> <li>Surfacing failures clearly</li> <li>Ensuring no partial execution</li> <li>Requiring explicit operator re-issuance after failure</li> </ul> <p>Phase 7 is NOT responsible for:</p> <ul> <li>Recovering from failures automatically</li> <li>Rolling forward incomplete actions</li> <li>Repairing inconsistent state</li> </ul>"},{"location":"CONTROL_PLANE_SCOPE/#7-interaction-with-future-phases","title":"7. Interaction with Future Phases","text":"<p>Phase 7 MUST NOT assume:</p> <ul> <li>Authentication mechanisms</li> <li>Authorization models</li> <li>Multi-tenant environments</li> <li>Cloud-managed infrastructure</li> </ul> <p>Those concerns belong to later phases.</p>"},{"location":"CONTROL_PLANE_SCOPE/#8-scope-enforcement-rule","title":"8. Scope Enforcement Rule","text":"<p>If a proposed feature or behavior:</p> <ul> <li>Is not listed in Section 3</li> <li>Or violates any rule in Section 4</li> </ul> <p>Then it is out of scope for Phase 7 and must be rejected.</p> <p>There are no implicit inclusions.</p>"},{"location":"CONTROL_PLANE_SCOPE/#9-final-statement","title":"9. Final Statement","text":"<p>Phase 7 is intentionally narrow.</p> <p>It is designed to:</p> <ul> <li>Give operators power</li> <li>Without giving the system autonomy</li> </ul> <p>Any attempt to expand Phase 7 beyond this scope risks violating AeroDB\u2019s core philosophy.</p> <p>Phase 7 must never act on behalf of the operator.</p> <p>This scope is non-negotiable.</p> <p>END OF PHASE 7 SCOPE</p>"},{"location":"CONTROL_PLANE_STATE_MODEL/","title":"PHASE 7 STATE MODEL \u2014 CONTROL PLANE STATE, DERIVATION, AND AUTHORITY","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 NON-NEGOTIABLE</p>"},{"location":"CONTROL_PLANE_STATE_MODEL/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the state model for Phase 7.</p> <p>The Phase 7 state model exists to answer one question unambiguously:</p> <p>What state may the control plane hold without becoming a source of truth?</p> <p>Incorrect state modeling is one of the most common ways control planes accidentally become correctness-critical. This document prevents that.</p>"},{"location":"CONTROL_PLANE_STATE_MODEL/#2-fundamental-state-principle","title":"2. Fundamental State Principle","text":"<p>Phase 7 MUST NOT own authoritative system state.</p> <p>All authoritative state belongs to the correctness kernel (Phases 0\u20136).</p> <p>Phase 7 state is:</p> <ul> <li>Ephemeral</li> <li>Derived</li> <li>Replaceable</li> <li>Non-authoritative</li> </ul> <p>If all Phase 7 state is lost, the system must remain fully correct and recoverable.</p>"},{"location":"CONTROL_PLANE_STATE_MODEL/#3-state-categories","title":"3. State Categories","text":"<p>Phase 7 state is divided into three explicit categories:</p> <ol> <li>Authoritative Kernel State (Referenced Only)</li> <li>Derived Presentation State</li> <li>Ephemeral Interaction State</li> </ol> <p>No other categories are permitted.</p>"},{"location":"CONTROL_PLANE_STATE_MODEL/#4-authoritative-kernel-state-referenced-only","title":"4. Authoritative Kernel State (Referenced Only)","text":""},{"location":"CONTROL_PLANE_STATE_MODEL/#41-definition","title":"4.1 Definition","text":"<p>Authoritative kernel state includes:</p> <ul> <li>Node roles and replication state</li> <li>WAL positions</li> <li>MVCC visibility state</li> <li>Promotion and demotion state</li> <li>Snapshot and checkpoint metadata</li> </ul> <p>This state:</p> <ul> <li>Is owned exclusively by Phases 0\u20136</li> <li>Is persisted durably</li> <li>Is crash-recoverable</li> </ul>"},{"location":"CONTROL_PLANE_STATE_MODEL/#42-rules","title":"4.2 Rules","text":"<p>Phase 7 MUST:</p> <ul> <li>Read kernel state via explicit APIs</li> <li>Treat kernel state as immutable input</li> <li>Never cache kernel state as authoritative</li> </ul> <p>Phase 7 MUST NOT:</p> <ul> <li>Modify kernel state implicitly</li> <li>Infer kernel state transitions</li> <li>Persist kernel state copies for recovery</li> </ul>"},{"location":"CONTROL_PLANE_STATE_MODEL/#5-derived-presentation-state","title":"5. Derived Presentation State","text":""},{"location":"CONTROL_PLANE_STATE_MODEL/#51-definition","title":"5.1 Definition","text":"<p>Derived presentation state is computed by Phase 7 for human consumption.</p> <p>Examples:</p> <ul> <li>Aggregated health summaries</li> <li>Timelines composed from event streams</li> <li>Human-readable role summaries</li> <li>Sorted or filtered views</li> </ul> <p>Derived state:</p> <ul> <li>Is recomputable</li> <li>Has no independent authority</li> <li>Exists only to improve understanding</li> </ul>"},{"location":"CONTROL_PLANE_STATE_MODEL/#52-rules","title":"5.2 Rules","text":"<p>Derived presentation state:</p> <ul> <li>MUST be derivable solely from kernel state and immutable logs</li> <li>MUST NOT introduce new semantics</li> <li>MUST NOT be persisted as authoritative</li> </ul> <p>If derived state disagrees with kernel state, the kernel wins.</p>"},{"location":"CONTROL_PLANE_STATE_MODEL/#6-ephemeral-interaction-state","title":"6. Ephemeral Interaction State","text":""},{"location":"CONTROL_PLANE_STATE_MODEL/#61-definition","title":"6.1 Definition","text":"<p>Ephemeral interaction state supports active operator workflows.</p> <p>Examples:</p> <ul> <li>Pending confirmation dialogs</li> <li>In-progress command forms</li> <li>UI selection context</li> <li>Temporary client-side request IDs</li> </ul> <p>This state:</p> <ul> <li>Exists only for the duration of interaction</li> <li>Is safe to discard at any time</li> </ul>"},{"location":"CONTROL_PLANE_STATE_MODEL/#62-rules","title":"6.2 Rules","text":"<p>Ephemeral interaction state:</p> <ul> <li>MUST NOT survive control-plane restarts</li> <li>MUST NOT be persisted durably</li> <li>MUST NOT trigger kernel actions by itself</li> </ul> <p>If ephemeral state is lost, the operator must restart the interaction.</p>"},{"location":"CONTROL_PLANE_STATE_MODEL/#7-forbidden-state","title":"7. Forbidden State","text":"<p>Phase 7 MUST NOT hold:</p> <ul> <li>In-flight mutation state</li> <li>Partially executed command state</li> <li>Retry queues</li> <li>Background task state</li> <li>Decision memory</li> </ul> <p>Any such state would make Phase 7 correctness-critical, which is forbidden.</p>"},{"location":"CONTROL_PLANE_STATE_MODEL/#8-state-transitions","title":"8. State Transitions","text":""},{"location":"CONTROL_PLANE_STATE_MODEL/#81-control-plane-state-transitions","title":"8.1 Control-Plane State Transitions","text":"<p>Phase 7 state transitions:</p> <ul> <li>Are local to the control plane</li> <li>Do not affect kernel state</li> <li>Must be deterministic</li> </ul> <p>Example:</p> <ul> <li>Viewing \u2192 Confirming \u2192 Viewing</li> </ul>"},{"location":"CONTROL_PLANE_STATE_MODEL/#82-kernel-state-transitions","title":"8.2 Kernel State Transitions","text":"<p>Kernel state transitions:</p> <ul> <li>Occur only within Phases 0\u20136</li> <li>Are requested, not executed, by Phase 7</li> <li>Are validated exclusively by the kernel</li> </ul> <p>Phase 7 observes these transitions but does not own them.</p>"},{"location":"CONTROL_PLANE_STATE_MODEL/#9-state-and-failure-interaction","title":"9. State and Failure Interaction","text":"<p>Under any Phase 7 failure:</p> <ul> <li>All Phase 7 state may be discarded</li> <li>Kernel state must remain unchanged</li> </ul> <p>Recovery requires:</p> <ul> <li>Re-fetching kernel state</li> <li>Rebuilding derived views</li> </ul> <p>No state reconciliation is permitted.</p>"},{"location":"CONTROL_PLANE_STATE_MODEL/#10-state-consistency-rules","title":"10. State Consistency Rules","text":"<p>Phase 7 MUST present state consistently:</p> <ul> <li>All views must reflect a single kernel snapshot</li> <li>Mixed-version presentation is forbidden</li> </ul> <p>If consistent state cannot be obtained, Phase 7 must refuse to render.</p>"},{"location":"CONTROL_PLANE_STATE_MODEL/#11-state-and-testing-requirements","title":"11. State and Testing Requirements","text":"<p>Phase 7 state handling MUST be tested to ensure:</p> <ul> <li>Loss of control-plane state does not affect kernel state</li> <li>Derived state is recomputable</li> <li>No hidden persistence exists</li> </ul> <p>Tests MUST simulate:</p> <ul> <li>Control-plane crashes</li> <li>UI reloads</li> <li>Client restarts</li> </ul>"},{"location":"CONTROL_PLANE_STATE_MODEL/#12-final-statement","title":"12. Final Statement","text":"<p>Phase 7 state exists to support humans, not to define reality.</p> <p>The moment Phase 7 begins to remember things the kernel does not, it becomes dangerous.</p> <p>If Phase 7 state ever becomes required for correctness, Phase 7 is wrong.</p> <p>This state model is absolute.</p> <p>END OF PHASE 7 STATE MODEL</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/","title":"PHASE 7 TESTING STRATEGY \u2014 PROVING CONTROL PLANE SAFETY","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 NON-NEGOTIABLE</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines how Phase 7 is tested.</p> <p>The goal of Phase 7 testing is not feature validation or UI polish. The goal is to prove that the control plane cannot violate correctness, determinism, or auditability guarantees.</p> <p>Testing exists to demonstrate that Phase 7:</p> <ul> <li>Cannot act autonomously</li> <li>Cannot partially execute actions</li> <li>Cannot hide failures</li> <li>Cannot interfere with the kernel</li> </ul> <p>If a test cannot fail when an invariant is violated, the test is invalid.</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#2-testing-philosophy","title":"2. Testing Philosophy","text":"<p>Phase 7 tests are adversarial.</p> <p>Tests must assume:</p> <ul> <li>Operator error</li> <li>Network failure</li> <li>Control-plane crash</li> <li>Duplicate requests</li> <li>UI misbehavior</li> </ul> <p>Happy-path testing alone is insufficient.</p> <p>Every test must ask:</p> <p>What happens if this goes wrong?</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#3-test-scope","title":"3. Test Scope","text":"<p>Phase 7 tests MUST cover:</p> <ol> <li>Command execution semantics</li> <li>Confirmation enforcement</li> <li>Failure handling</li> <li>Determinism</li> <li>Auditability</li> <li>Non-interference with kernel behavior</li> </ol> <p>Tests outside this scope are optional and must not weaken guarantees.</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#4-test-categories","title":"4. Test Categories","text":""},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#41-invariant-enforcement-tests","title":"4.1 Invariant Enforcement Tests","text":"<p>Purpose:</p> <ul> <li>Prove Phase 7 invariants cannot be violated</li> </ul> <p>Required tests:</p> <ul> <li>No execution without confirmation</li> <li>No execution without authority</li> <li>No retries on failure</li> <li>No background execution</li> </ul> <p>Each invariant MUST have at least one negative test.</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#42-command-semantics-tests","title":"4.2 Command Semantics Tests","text":"<p>Purpose:</p> <ul> <li>Prove one command maps to one kernel action</li> </ul> <p>Required tests:</p> <ul> <li>Duplicate command rejection</li> <li>No implicit chaining</li> <li>Explicit rejection propagation</li> </ul>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#43-failure-injection-tests","title":"4.3 Failure Injection Tests","text":"<p>Purpose:</p> <ul> <li>Prove fail-closed behavior</li> </ul> <p>Required tests:</p> <ul> <li>Client crash before confirmation</li> <li>Client crash after confirmation</li> <li>Control-plane crash during dispatch</li> <li>Network timeout before kernel response</li> </ul> <p>Expected result:</p> <ul> <li>No partial execution</li> <li>Deterministic outcome</li> </ul>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#44-determinism-tests","title":"4.4 Determinism Tests","text":"<p>Purpose:</p> <ul> <li>Prove identical input yields identical outcome</li> </ul> <p>Required tests:</p> <ul> <li>Same command + same kernel state \u2192 same result</li> <li>Same error conditions \u2192 same error output</li> </ul> <p>No timing-based divergence allowed.</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#45-auditability-tests","title":"4.5 Auditability Tests","text":"<p>Purpose:</p> <ul> <li>Prove nothing executes without audit records</li> </ul> <p>Required tests:</p> <ul> <li>Command attempt creates audit record</li> <li>Confirmation creates audit record</li> <li>Failure creates audit record</li> <li>Crash does not erase records</li> </ul> <p>Missing audit record = test failure.</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#46-non-interference-tests","title":"4.6 Non-Interference Tests","text":"<p>Purpose:</p> <ul> <li>Prove Phase 7 does not affect kernel behavior</li> </ul> <p>Required tests:</p> <ul> <li>Kernel behavior identical with Phase 7 disabled</li> <li>Observability-only operations cause no mutation</li> </ul>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#5-forbidden-testing-patterns","title":"5. Forbidden Testing Patterns","text":"<p>Phase 7 tests MUST NOT:</p> <ul> <li>Mock kernel correctness decisions</li> <li>Bypass confirmation logic</li> <li>Assume retries</li> <li>Use timing sleeps for correctness</li> </ul> <p>If a test relies on timeouts or race conditions, it is invalid.</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#6-test-environment-requirements","title":"6. Test Environment Requirements","text":"<p>Tests MUST:</p> <ul> <li>Run against real kernel components</li> <li>Use real storage where applicable</li> <li>Simulate crashes via process termination</li> </ul> <p>In-memory substitutes are allowed only if they do not weaken guarantees.</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#7-test-coverage-requirements","title":"7. Test Coverage Requirements","text":"<p>Coverage is measured by invariant coverage, not line coverage.</p> <p>Phase 7 MUST demonstrate:</p> <ul> <li>100% invariant coverage</li> <li>Explicit tests for every command</li> <li>Explicit tests for every failure class</li> </ul> <p>Uncovered invariant = incomplete Phase 7.</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#8-test-determinism","title":"8. Test Determinism","text":"<p>All tests MUST:</p> <ul> <li>Be repeatable</li> <li>Produce identical results across runs</li> <li>Avoid nondeterministic dependencies</li> </ul> <p>Flaky tests are correctness failures.</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#9-regression-testing","title":"9. Regression Testing","text":"<p>Any change to Phase 7 MUST:</p> <ul> <li>Add or update tests</li> <li>Demonstrate no regression in invariants</li> </ul> <p>Removing tests requires reopening Phase 7.</p>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#10-acceptance-criteria","title":"10. Acceptance Criteria","text":"<p>Phase 7 passes testing only if:</p> <ul> <li>All invariants are enforced</li> <li>All failure paths are tested</li> <li>All audit records are validated</li> <li>No kernel interference is observed</li> </ul>"},{"location":"CONTROL_PLANE_TESTING_STRATEGY/#11-final-statement","title":"11. Final Statement","text":"<p>Phase 7 testing exists to prove nothing bad can happen, even when everything goes wrong.</p> <p>If a bug escapes Phase 7 testing, it means the tests were insufficient.</p> <p>A control plane that cannot be proven safe must not exist.</p> <p>This testing strategy is authoritative.</p> <p>END OF PHASE 7 TESTING STRATEGY</p>"},{"location":"CONTROL_PLANE_VISION/","title":"PHASE 7 VISION \u2014 CONTROL PLANE &amp; OPERATOR INTERACTION","text":"<p>Project: AeroDB Phase: Phase 7 \u2014 Control Plane, Admin UI, and Operator Tooling Status: AUTHORITATIVE \u00b7 PRE-IMPLEMENTATION</p>"},{"location":"CONTROL_PLANE_VISION/#1-purpose-of-phase-7","title":"1. Purpose of Phase 7","text":"<p>Phase 7 introduces explicit human-operated control surfaces for AeroDB.</p> <p>The purpose of Phase 7 is not to make AeroDB smarter, faster, or more autonomous. The purpose is to make AeroDB:</p> <ul> <li>Operable by humans</li> <li>Observable in complex failure scenarios</li> <li>Auditable after incidents</li> <li>Controllable only through explicit, deliberate action</li> </ul> <p>Phase 7 exists to give operators visibility and authority, not to give the system decision-making power.</p> <p>Phase 7 is a control plane, not a brain.</p>"},{"location":"CONTROL_PLANE_VISION/#2-foundational-principle","title":"2. Foundational Principle","text":"<p>AeroDB is correctness-first infrastructure software.</p> <p>All correctness, safety, durability, and determinism guarantees are fully defined and enforced by Phases 0\u20136.</p> <p>Phase 7:</p> <ul> <li>MUST NOT weaken those guarantees</li> <li>MUST NOT reinterpret them</li> <li>MUST NOT add alternative execution paths</li> </ul> <p>Phase 7 is strictly downstream of the correctness kernel.</p> <p>If Phase 7 is removed entirely, AeroDB must remain correct, deterministic, and crash-safe.</p>"},{"location":"CONTROL_PLANE_VISION/#3-explicit-non-goals-critical","title":"3. Explicit Non-Goals (Critical)","text":"<p>Phase 7 MUST NOT:</p> <ol> <li> <p>Automate decisions</p> </li> <li> <p>No automatic failover</p> </li> <li>No automatic promotion</li> <li> <p>No automatic remediation</p> </li> <li> <p>Introduce heuristics</p> </li> <li> <p>No thresholds that trigger actions</p> </li> <li>No background evaluators</li> <li> <p>No \u201crecommended actions\u201d executed implicitly</p> </li> <li> <p>Create control loops</p> </li> <li> <p>No polling \u2192 decision \u2192 action cycles</p> </li> <li> <p>No retry loops that change state</p> </li> <li> <p>Act without human intent</p> </li> <li> <p>No implicit retries</p> </li> <li>No hidden confirmations</li> <li> <p>No background mutations</p> </li> <li> <p>Override invariants</p> </li> <li> <p>No bypassing durability</p> </li> <li>No bypassing single-writer rules</li> <li> <p>No bypassing fail-closed behavior</p> </li> <li> <p>Hide consequences</p> </li> <li> <p>No silent partial success</p> </li> <li>No best-effort execution</li> <li>No \u201ceventual\u201d control-plane effects</li> </ol> <p>Any of the above would violate AeroDB\u2019s philosophy and are forbidden.</p>"},{"location":"CONTROL_PLANE_VISION/#4-human-in-the-loop-model","title":"4. Human-in-the-Loop Model","text":"<p>Phase 7 is explicitly designed around a human-in-the-loop execution model.</p> <p>This means:</p> <ul> <li>Every mutating action requires an explicit operator request</li> <li>Every request must be explainable before execution</li> <li>Every action must be confirmable by the operator</li> <li>Every outcome must be observable and auditable</li> </ul> <p>The system does nothing unless a human asks it to.</p>"},{"location":"CONTROL_PLANE_VISION/#5-authority-separation","title":"5. Authority Separation","text":"<p>Phase 7 introduces no new authority over data correctness.</p> <p>Authority boundaries:</p> <ul> <li>Data plane authority: Phases 0\u20136</li> <li>Control plane authority: Phase 7</li> </ul> <p>The control plane:</p> <ul> <li>May request actions</li> <li>May observe system state</li> <li>May surface explanations</li> </ul> <p>The control plane:</p> <ul> <li>May NOT decide correctness</li> <li>May NOT infer safety</li> <li>May NOT repair inconsistencies</li> </ul> <p>If the control plane requests an invalid action, the request MUST be rejected explicitly.</p>"},{"location":"CONTROL_PLANE_VISION/#6-determinism-guarantee","title":"6. Determinism Guarantee","text":"<p>All Phase 7 behavior MUST be deterministic.</p> <p>Given identical:</p> <ul> <li>System state</li> <li>Operator input</li> <li>Configuration</li> </ul> <p>Phase 7 MUST:</p> <ul> <li>Present identical information</li> <li>Produce identical explanations</li> <li>Accept or reject actions identically</li> </ul> <p>No Phase 7 behavior may depend on:</p> <ul> <li>Timing</li> <li>Ordering of UI events</li> <li>Retry timing</li> <li>UI refresh behavior</li> </ul>"},{"location":"CONTROL_PLANE_VISION/#7-failure-philosophy","title":"7. Failure Philosophy","text":"<p>Phase 7 MUST fail closed and loudly.</p> <p>Failure rules:</p> <ul> <li>If an action cannot be proven safe \u2192 it is rejected</li> <li>If system state is ambiguous \u2192 no action is taken</li> <li>If the control plane crashes \u2192 no partial action occurs</li> </ul> <p>The control plane MUST NEVER attempt:</p> <ul> <li>Partial execution</li> <li>Roll-forward repair</li> <li>Automatic retry</li> </ul> <p>Operator re-issuance is the only recovery mechanism.</p>"},{"location":"CONTROL_PLANE_VISION/#8-idempotence-and-replay","title":"8. Idempotence and Replay","text":"<p>Phase 7 actions are not implicitly idempotent.</p> <p>An operator action:</p> <ul> <li>Is either executed exactly once</li> <li>Or not executed at all</li> </ul> <p>If a client retries a request:</p> <ul> <li>The system must detect duplicates</li> <li>Or explicitly reject the retry</li> </ul> <p>Silent re-execution is forbidden.</p>"},{"location":"CONTROL_PLANE_VISION/#9-observability-as-a-first-class-requirement","title":"9. Observability as a First-Class Requirement","text":"<p>Phase 7 is the primary interface through which humans understand AeroDB.</p> <p>Therefore:</p> <ul> <li>All state transitions must be observable</li> <li>All decisions must have explanations</li> <li>All rejections must reference violated invariants</li> <li>All actions must leave an audit trail</li> </ul> <p>Observability is passive.</p> <p>It must never influence control flow.</p>"},{"location":"CONTROL_PLANE_VISION/#10-auditability-and-accountability","title":"10. Auditability and Accountability","text":"<p>Phase 7 MUST make post-incident analysis possible.</p> <p>This includes:</p> <ul> <li>Who requested an action</li> <li>When it was requested</li> <li>What state existed at the time</li> <li>Why the action was accepted or rejected</li> <li>What invariants were relied upon</li> </ul> <p>If a past action cannot be reconstructed, Phase 7 has failed its purpose.</p>"},{"location":"CONTROL_PLANE_VISION/#11-security-boundary-conceptual","title":"11. Security Boundary (Conceptual)","text":"<p>Phase 7 defines security boundaries, even if enforcement is deferred.</p> <p>This includes:</p> <ul> <li>What actions are considered privileged</li> <li>What information is considered sensitive</li> <li>What boundaries exist between observers and actors</li> </ul> <p>Actual authentication and authorization mechanisms may be implemented in later phases, but boundaries must be explicit now.</p>"},{"location":"CONTROL_PLANE_VISION/#12-compatibility-with-future-phases","title":"12. Compatibility with Future Phases","text":"<p>Phase 7 MUST NOT pre-commit AeroDB to:</p> <ul> <li>Any specific UI framework</li> <li>Any specific deployment model</li> <li>Any specific auth system</li> <li>Any cloud-provider assumptions</li> </ul> <p>Phase 7 defines behavioral contracts, not implementation choices.</p>"},{"location":"CONTROL_PLANE_VISION/#13-freeze-criteria","title":"13. Freeze Criteria","text":"<p>Phase 7 may be frozen only when:</p> <ol> <li>All operator actions are explicitly specified</li> <li>All failure modes are documented</li> <li>No automation exists</li> <li>All actions are explainable</li> <li>All invariants are preserved</li> <li>Auditability is demonstrably complete</li> </ol>"},{"location":"CONTROL_PLANE_VISION/#14-final-statement","title":"14. Final Statement","text":"<p>Phase 7 exists to make AeroDB usable by humans without making it dangerous.</p> <p>It is intentionally conservative.</p> <p>It prefers:</p> <ul> <li>Rejection over ambiguity</li> <li>Explicit failure over silent action</li> <li>Human responsibility over system autonomy</li> </ul> <p>If Phase 7 ever makes a decision on behalf of an operator, it is wrong.</p> <p>This vision is non-negotiable.</p> <p>END OF PHASE 7 VISION</p>"},{"location":"CORE_API_SPEC/","title":"API Specification","text":"<p>This document defines the authoritative client-facing API for AeroDB Phase 0.</p> <p>It governs:</p> <ul> <li>API Layer implementation</li> <li>CLI behavior</li> <li>Integration tests</li> <li>Client expectations</li> </ul> <p>If implementation behavior conflicts with this document, the implementation is wrong.</p> <p>This API is intentionally minimal, explicit, and deterministic.</p> <p>No undocumented behavior is allowed.</p>"},{"location":"CORE_API_SPEC/#1-core-principles","title":"1. Core Principles","text":"<p>The AeroDB API follows these non-negotiable rules:</p> <ul> <li>All operations are synchronous.</li> <li>All requests are serialized (global execution lock).</li> <li>All errors are explicit.</li> <li>No implicit defaults.</li> <li>No hidden metadata.</li> <li>No automatic ID generation.</li> <li>No partial success.</li> </ul> <p>Every request either:</p> <ul> <li>fully succeeds or  </li> <li>fully fails  </li> </ul> <p>There is no intermediate state.</p>"},{"location":"CORE_API_SPEC/#2-transport","title":"2. Transport","text":"<p>Phase 0 uses JSON over stdin/stdout (via CLI or embedded API).</p> <p>There is no HTTP server in Phase 0.</p> <p>All requests and responses are JSON objects.</p> <p>Encoding: UTF-8.</p>"},{"location":"CORE_API_SPEC/#3-request-envelope","title":"3. Request Envelope","text":"<p>Every request MUST be a JSON object with:</p> <pre><code>{\n\"op\": \"&lt;operation&gt;\",\n...\n}\n</code></pre> <p>If <code>op</code> is missing or unknown:</p> <p>\u2192 <code>AERO_QUERY_INVALID</code></p> <p>No additional top-level fields are allowed unless explicitly documented.</p>"},{"location":"CORE_API_SPEC/#4-supported-operations","title":"4. Supported Operations","text":"<p>Phase 0 supports exactly:</p> <ul> <li>insert</li> <li>update</li> <li>delete</li> <li>query</li> <li>explain</li> </ul> <p>No other operations exist.</p>"},{"location":"CORE_API_SPEC/#5-insert","title":"5. Insert","text":""},{"location":"CORE_API_SPEC/#request","title":"Request","text":"<pre><code>{\n\"op\": \"insert\",\n\"schema_id\": \"user\",\n\"schema_version\": \"v1\",\n\"document\": {\n\"_id\": \"123\",\n\"name\": \"alice\",\n\"age\": 30\n}\n}\n</code></pre>"},{"location":"CORE_API_SPEC/#rules","title":"Rules","text":"<ul> <li><code>_id</code> is mandatory</li> <li>Schema must exist</li> <li>Schema version must exist</li> <li>Document must fully validate</li> </ul>"},{"location":"CORE_API_SPEC/#success-response","title":"Success Response","text":"<pre><code>{\n\"status\": \"ok\",\n\"data\": []\n}\n</code></pre> <p>Insert does NOT return the document.</p>"},{"location":"CORE_API_SPEC/#6-update","title":"6. Update","text":""},{"location":"CORE_API_SPEC/#request_1","title":"Request","text":"<pre><code>{\n\"op\": \"update\",\n\"schema_id\": \"user\",\n\"schema_version\": \"v1\",\n\"document\": {\n\"_id\": \"123\",\n\"name\": \"alice\",\n\"age\": 31\n}\n}\n</code></pre>"},{"location":"CORE_API_SPEC/#rules_1","title":"Rules","text":"<ul> <li>Full document replacement only</li> <li><code>_id</code> must match existing document</li> <li><code>_id</code> is immutable</li> <li>Same validation rules as insert</li> </ul>"},{"location":"CORE_API_SPEC/#success-response_1","title":"Success Response","text":"<pre><code>{\n\"status\": \"ok\",\n\"data\": []\n}\n</code></pre> <p>No partial updates exist in Phase 0.</p>"},{"location":"CORE_API_SPEC/#7-delete","title":"7. Delete","text":""},{"location":"CORE_API_SPEC/#request_2","title":"Request","text":"<pre><code>{\n\"op\": \"delete\",\n\"schema_id\": \"user\",\n\"schema_version\": \"v1\",\n\"_id\": \"123\"\n}\n</code></pre>"},{"location":"CORE_API_SPEC/#rules_2","title":"Rules","text":"<ul> <li><code>_id</code> required</li> <li>Delete writes tombstone</li> <li>Silent success if document does not exist</li> </ul>"},{"location":"CORE_API_SPEC/#success-response_2","title":"Success Response","text":"<pre><code>{\n\"status\": \"ok\",\n\"data\": []\n}\n</code></pre>"},{"location":"CORE_API_SPEC/#8-query","title":"8. Query","text":""},{"location":"CORE_API_SPEC/#request_3","title":"Request","text":"<pre><code>{\n\"op\": \"query\",\n\"schema_id\": \"user\",\n\"schema_version\": \"v1\",\n\"filter\": {\n\"age\": 30\n},\n\"sort\": \"name\",\n\"limit\": 10\n}\n</code></pre>"},{"location":"CORE_API_SPEC/#required-fields","title":"Required Fields","text":"<ul> <li>schema_id</li> <li>schema_version</li> <li>filter</li> <li>limit</li> </ul>"},{"location":"CORE_API_SPEC/#optional-fields","title":"Optional Fields","text":"<ul> <li>sort</li> </ul>"},{"location":"CORE_API_SPEC/#filter-rules","title":"Filter Rules","text":"<ul> <li>AND only</li> <li>Equality or indexed range</li> <li>No OR</li> <li>No functions</li> <li>No expressions</li> <li>All fields must be indexed</li> </ul>"},{"location":"CORE_API_SPEC/#limit-rules","title":"Limit Rules","text":"<ul> <li>Must be present</li> <li>Must be &gt; 0</li> </ul> <p>Missing or invalid limit:</p> <p>\u2192 <code>AERO_QUERY_LIMIT_REQUIRED</code></p>"},{"location":"CORE_API_SPEC/#sort-rules","title":"Sort Rules","text":"<ul> <li>Must reference indexed field</li> <li>Optional</li> <li>Stable deterministic ordering</li> </ul> <p>Unindexed sort:</p> <p>\u2192 <code>AERO_QUERY_SORT_NOT_INDEXED</code></p>"},{"location":"CORE_API_SPEC/#success-response_3","title":"Success Response","text":"<pre><code>{\n\"status\": \"ok\",\n\"data\": [\n{\n\"_id\": \"123\",\n\"name\": \"alice\",\n\"age\": 30\n}\n]\n}\n</code></pre> <p>Returned documents are ordered and schema-valid.</p>"},{"location":"CORE_API_SPEC/#9-explain","title":"9. Explain","text":"<p>Explain uses the same input as query:</p> <pre><code>{\n\"op\": \"explain\",\n\"schema_id\": \"user\",\n\"schema_version\": \"v1\",\n\"filter\": {\n\"age\": 30\n},\n\"sort\": \"name\",\n\"limit\": 10\n}\n</code></pre>"},{"location":"CORE_API_SPEC/#response","title":"Response","text":"<pre><code>{\n\"status\": \"ok\",\n\"data\": {\n\"chosen_index\": \"age\",\n\"scan_type\": \"EQ\",\n\"predicates\": [\"age = 30\"],\n\"sort\": \"name\",\n\"limit\": 10,\n\"bounded\": true\n}\n}\n</code></pre> <p>Explain output must be deterministic.</p>"},{"location":"CORE_API_SPEC/#10-error-response-format","title":"10. Error Response Format","text":"<p>All errors use:</p> <pre><code>{\n\"status\": \"error\",\n\"code\": \"AERO_QUERY_UNBOUNDED\",\n\"message\": \"Range query requires explicit limit\"\n}\n</code></pre> <p>Rules:</p> <ul> <li>code must match ERRORS.md</li> <li>message is human-readable</li> <li>no stack traces</li> <li>no internal details</li> </ul>"},{"location":"CORE_API_SPEC/#11-error-propagation","title":"11. Error Propagation","text":"<p>API Layer must:</p> <ul> <li>pass subsystem errors directly</li> <li>not remap codes</li> <li>not downgrade severity</li> <li>not suppress failures</li> </ul> <p>Corruption errors are always FATAL.</p>"},{"location":"CORE_API_SPEC/#12-determinism","title":"12. Determinism","text":"<p>API must NOT:</p> <ul> <li>add timestamps</li> <li>add request IDs</li> <li>generate document IDs</li> <li>inject metadata</li> <li>reorder results</li> </ul> <p>Given same input and same database state:</p> <p>API must return identical output.</p>"},{"location":"CORE_API_SPEC/#13-serialization","title":"13. Serialization","text":"<p>All API calls are serialized via global execution lock.</p> <p>Only one request executes at any time.</p> <p>Concurrent requests block.</p>"},{"location":"CORE_API_SPEC/#14-phase-0-limitations","title":"14. Phase-0 Limitations","text":"<p>Explicitly unsupported:</p> <ul> <li>joins</li> <li>aggregations</li> <li>projections</li> <li>partial updates</li> <li>transactions</li> <li>pagination</li> <li>streaming</li> <li>subscriptions</li> <li>bulk writes</li> </ul> <p>Any attempt results in <code>AERO_QUERY_INVALID</code>.</p>"},{"location":"CORE_API_SPEC/#15-authority","title":"15. Authority","text":"<p>This document governs:</p> <ul> <li>API Layer</li> <li>CLI request formats</li> <li>Client expectations</li> <li>Integration tests</li> </ul> <p>Any deviation is a correctness bug.</p>"},{"location":"CORE_BACKUP/","title":"BACKUP.md \u2014 AeroDB Backup Specification (Phase 1)","text":"<p>This document defines the authoritative backup behavior for AeroDB Phase 1.</p> <p>Backups provide an offline, portable representation of database state suitable for:</p> <ul> <li>disaster recovery</li> <li>migration</li> <li>archival storage</li> </ul> <p>Backups are created from snapshots and WAL.</p> <p>If implementation behavior conflicts with this document, the implementation is wrong.</p>"},{"location":"CORE_BACKUP/#1-principles","title":"1. Principles","text":"<p>Backups must satisfy:</p> <ul> <li>Atomic consistency</li> <li>Full durability</li> <li>Explicit integrity verification</li> <li>Deterministic restore</li> <li>Zero partial success</li> </ul> <p>Backups are not incremental.</p> <p>Each backup is complete.</p>"},{"location":"CORE_BACKUP/#2-backup-command","title":"2. Backup Command","text":"<p>Backups are triggered manually:</p> <pre><code>aerodb backup --config aerodb.json --output backup.tar\n</code></pre> <p>No automatic backups.</p> <p>No background jobs.</p>"},{"location":"CORE_BACKUP/#3-backup-contents","title":"3. Backup Contents","text":"<p>A backup archive contains:</p> <p>```</p> <p>backup.tar \u251c\u2500\u2500 snapshot/ \u2502   \u251c\u2500\u2500 storage.dat \u2502   \u251c\u2500\u2500 schemas/ \u2502   \u2514\u2500\u2500 manifest.json \u251c\u2500\u2500 wal/ \u2502   \u2514\u2500\u2500 wal.log \u2514\u2500\u2500 backup_manifest.json</p> <p>````</p>"},{"location":"CORE_BACKUP/#31-snapshot","title":"3.1 snapshot/","text":"<p>Exact copy of latest valid snapshot directory.</p> <p>Includes:</p> <ul> <li>storage.dat</li> <li>schemas</li> <li>snapshot manifest</li> </ul> <p>Indexes excluded.</p>"},{"location":"CORE_BACKUP/#32-wal","title":"3.2 wal/","text":"<p>Contains WAL tail after snapshot.</p> <p>Rules:</p> <ul> <li>byte-for-byte copy</li> <li>fsync before packaging</li> </ul>"},{"location":"CORE_BACKUP/#33-backup_manifestjson","title":"3.3 backup_manifest.json","text":"<p>Top-level descriptor.</p> <p>Example:</p> <p>```json {   \"backup_id\": \"20260204T120000Z\",   \"created_at\": \"2026-02-04T12:00:00Z\",   \"snapshot_id\": \"20260204T113000Z\",   \"wal_present\": true,   \"format_version\": 1 } ````</p>"},{"location":"CORE_BACKUP/#4-backup-creation-algorithm","title":"4. Backup Creation Algorithm","text":"<p>Backup creation MUST follow:</p> <ol> <li>Acquire global execution lock</li> <li>fsync WAL</li> <li>Identify latest valid snapshot</li> <li>Copy snapshot \u2192 temp directory</li> <li>Copy WAL tail \u2192 temp directory</li> <li>Generate backup_manifest.json</li> <li>fsync temp directory</li> <li>Package temp directory into tar</li> <li>fsync backup.tar</li> <li>Release global execution lock</li> </ol> <p>Any failure aborts backup.</p> <p>Temporary directories removed.</p>"},{"location":"CORE_BACKUP/#5-atomicity","title":"5. Atomicity","text":"<p>Backup becomes valid only after:</p> <ul> <li>tar creation complete</li> <li>tar fsync</li> </ul> <p>Partial backups must be deleted.</p>"},{"location":"CORE_BACKUP/#6-integrity-verification","title":"6. Integrity Verification","text":"<p>Backup must contain:</p> <ul> <li>snapshot manifest</li> <li>schema files</li> <li>WAL</li> </ul> <p>Restore verifies:</p> <ul> <li>snapshot checksums</li> <li>schema checksums</li> <li>WAL checksums</li> </ul> <p>Any mismatch \u2192 FATAL.</p>"},{"location":"CORE_BACKUP/#7-determinism","title":"7. Determinism","text":"<p>Given identical:</p> <ul> <li>snapshot</li> <li>WAL tail</li> </ul> <p>Backup archives must be identical.</p> <p>No timestamps inside tar except manifest fields.</p>"},{"location":"CORE_BACKUP/#8-corruption-policy","title":"8. Corruption Policy","text":"<p>Backup corruption detected during restore:</p> <ul> <li>restore aborts</li> <li>database not modified</li> </ul> <p>No partial restore.</p>"},{"location":"CORE_BACKUP/#9-phase-1-limitations","title":"9. Phase-1 Limitations","text":"<p>Backups do NOT support:</p> <ul> <li>encryption</li> <li>compression</li> <li>streaming</li> <li>incremental mode</li> </ul> <p>These belong to later phases.</p>"},{"location":"CORE_BACKUP/#10-authority","title":"10. Authority","text":"<p>This document governs:</p> <ul> <li>aerodb backup</li> <li>backup format</li> <li>restore inputs</li> <li>disaster recovery</li> </ul> <p>Violations are correctness bugs.</p>"},{"location":"CORE_BOOT/","title":"BOOT.md \u2014 AeroDB Boot &amp; Startup Contract (Phase 0)","text":"<p>This document defines the authoritative startup, recovery, and shutdown behavior of AeroDB.</p> <p>It is a governing specification.</p> <p>If implementation behavior conflicts with this document, the implementation is wrong.</p> <p>This applies to:</p> <ul> <li><code>main.rs</code></li> <li>Recovery Manager</li> <li>API Layer</li> <li>CLI</li> <li>Config Loader</li> </ul> <p>No component may violate this contract.</p>"},{"location":"CORE_BOOT/#1-principles","title":"1. Principles","text":"<p>AeroDB boot is designed around the following non-negotiable principles:</p> <ul> <li>Storage is the source of truth.</li> <li>WAL is the recovery authority.</li> <li>Indexes are derived state.</li> <li>Startup must be deterministic.</li> <li>Corruption must halt the system.</li> <li>No partial availability.</li> <li>No background recovery.</li> <li>No speculative serving.</li> </ul> <p>The system is either:</p> <ul> <li>Fully consistent and serving or  </li> <li>Completely offline</li> </ul> <p>There is no intermediate state.</p>"},{"location":"CORE_BOOT/#2-high-level-boot-phases","title":"2. High-Level Boot Phases","text":"<p>Startup proceeds in strict sequence:</p> <ol> <li>Configuration Load</li> <li>Schema Load</li> <li>Recovery</li> <li>Index Rebuild</li> <li>Verification</li> <li>API Activation</li> </ol> <p>No phase may be skipped or reordered.</p>"},{"location":"CORE_BOOT/#3-detailed-boot-sequence","title":"3. Detailed Boot Sequence","text":""},{"location":"CORE_BOOT/#31-configuration-load","title":"3.1 Configuration Load","text":"<p>Performed by Config Loader.</p> <p>Steps:</p> <ol> <li>Read config file</li> <li>Apply defaults</li> <li>Validate constraints</li> <li>Reject unsafe values</li> </ol> <p>Failures:</p> <ul> <li>Any invalid configuration \u2192 process exits immediately</li> </ul> <p>No files are opened before config validation completes.</p>"},{"location":"CORE_BOOT/#32-schema-load","title":"3.2 Schema Load","text":"<p>Performed before any WAL or storage access.</p> <p>Steps:</p> <ol> <li>Load all schemas from:</li> </ol> <pre><code>&lt;data_dir&gt;/metadata/schemas/\n</code></pre> <ol> <li>Parse schema JSON</li> <li>Validate schema format</li> <li>Register schemas in memory</li> </ol> <p>Failures:</p> <ul> <li>Missing schema file</li> <li>Malformed schema</li> <li>Duplicate schema versions</li> </ul> <p>Result:</p> <p>\u2192 FATAL: <code>AERO_RECOVERY_SCHEMA_MISSING</code></p> <p>Startup stops.</p>"},{"location":"CORE_BOOT/#33-recovery-phase","title":"3.3 Recovery Phase","text":"<p>Performed by Recovery Manager.</p> <p>This phase ALWAYS runs, even after clean shutdown.</p> <p>Steps:</p> <ol> <li>Open WAL reader</li> <li>Open storage files</li> <li>Replay WAL from byte 0 sequentially</li> </ol> <p>For each WAL record:</p> <ul> <li>Validate checksum</li> <li>Apply record via <code>storage.apply_wal_record</code></li> </ul> <p>Rules:</p> <ul> <li>Any WAL corruption \u2192 FATAL</li> <li>No partial replay</li> <li>No skipping entries</li> <li>No heuristics</li> </ul> <p>Same WAL must always produce the same storage state.</p>"},{"location":"CORE_BOOT/#34-index-rebuild","title":"3.4 Index Rebuild","text":"<p>Indexes are rebuilt only AFTER WAL replay completes.</p> <p>Steps:</p> <ol> <li>Sequentially scan storage</li> <li>Ignore tombstones</li> <li>Extract indexed fields</li> <li>Populate in-memory BTreeMaps</li> </ol> <p>Rules:</p> <ul> <li>Indexes are derived state</li> <li>Indexes are never persisted</li> <li>Corruption during rebuild \u2192 FATAL</li> </ul>"},{"location":"CORE_BOOT/#35-consistency-verification","title":"3.5 Consistency Verification","text":"<p>Performed after index rebuild.</p> <p>Verifier must:</p> <ul> <li>Sequentially scan storage</li> <li>Validate checksum on every record</li> <li>Ensure all schema references exist</li> </ul> <p>Failures:</p> <ul> <li>Storage corruption</li> <li>Unknown schema ID</li> <li>Unknown schema version</li> </ul> <p>Result:</p> <p>\u2192 FATAL: <code>AERO_RECOVERY_VERIFICATION_FAILED</code></p>"},{"location":"CORE_BOOT/#36-clean-shutdown-marker-handling","title":"3.6 Clean Shutdown Marker Handling","text":"<p>Location:</p> <pre><code>&lt;data_dir&gt;/clean_shutdown\n</code></pre> <p>Behavior:</p> <ul> <li>Marker presence does NOT skip recovery</li> <li>Marker is informational only in Phase 0</li> <li>Marker removed after successful boot</li> </ul> <p>Clean shutdown marker does NOT affect replay behavior.</p> <p>WAL is always replayed fully.</p>"},{"location":"CORE_BOOT/#37-api-activation","title":"3.7 API Activation","text":"<p>Only after ALL previous phases succeed:</p> <ol> <li>Global execution lock initialized</li> <li>API handlers registered</li> <li>System enters serving state</li> </ol> <p>Before this point:</p> <ul> <li>No requests accepted</li> <li>No partial availability</li> </ul>"},{"location":"CORE_BOOT/#4-serving-state","title":"4. Serving State","text":"<p>System is considered \"online\" only after:</p> <ul> <li>WAL replay completed</li> <li>Index rebuild completed</li> <li>Verification completed</li> <li>API layer initialized</li> </ul> <p>Only then may queries or writes occur.</p>"},{"location":"CORE_BOOT/#5-shutdown-semantics","title":"5. Shutdown Semantics","text":"<p>Graceful shutdown:</p> <ol> <li>Stop accepting API requests</li> <li>Wait for in-flight operation to complete</li> <li>Write <code>clean_shutdown</code> marker</li> <li>Exit process</li> </ol> <p>No background flushes. No delayed cleanup.</p> <p>Crash shutdown:</p> <ul> <li>No marker written</li> <li>Recovery runs normally on next startup</li> </ul>"},{"location":"CORE_BOOT/#6-fatal-error-policy","title":"6. Fatal Error Policy","text":"<p>Any of the following causes immediate process termination:</p> <ul> <li>WAL corruption</li> <li>Storage corruption</li> <li>Schema inconsistency</li> <li>Verification failure</li> <li>Index rebuild failure</li> <li>Invalid configuration</li> </ul> <p>AeroDB does NOT attempt:</p> <ul> <li>partial recovery</li> <li>degraded mode</li> <li>read-only fallback</li> </ul> <p>Failure is explicit and terminal.</p> <p>Operator intervention is required.</p>"},{"location":"CORE_BOOT/#7-determinism-guarantees","title":"7. Determinism Guarantees","text":"<p>Given identical:</p> <ul> <li>WAL</li> <li>Storage files</li> <li>Schemas</li> <li>Config</li> </ul> <p>AeroDB must:</p> <ul> <li>Produce identical in-memory state</li> <li>Build identical indexes</li> <li>Serve identical query results</li> </ul> <p>No timestamps, randomness, or environment-dependent behavior may affect boot.</p>"},{"location":"CORE_BOOT/#8-phase-0-limitations","title":"8. Phase-0 Limitations","text":"<p>Phase 0 intentionally does NOT include:</p> <ul> <li>Checkpointing</li> <li>WAL truncation</li> <li>Fast startup</li> <li>Parallel recovery</li> <li>Incremental index rebuild</li> </ul> <p>Every startup performs full replay and full rebuild.</p>"},{"location":"CORE_BOOT/#9-authority","title":"9. Authority","text":"<p>This document governs:</p> <ul> <li>Recovery Manager</li> <li>main.rs</li> <li>API startup</li> <li>CLI start command</li> </ul> <p>Violations of this contract are considered correctness bugs.</p>"},{"location":"CORE_CHECKPOINT/","title":"CHECKPOINT.md \u2014 AeroDB Checkpointing Specification (Phase 1)","text":"<p>This document defines the authoritative checkpointing behavior for AeroDB Phase 1.</p> <p>Checkpointing bounds:</p> <ul> <li>WAL growth</li> <li>recovery time</li> <li>snapshot cadence</li> </ul> <p>If implementation behavior conflicts with this document, the implementation is wrong.</p> <p>Checkpointing exists to make AeroDB operationally viable.</p> <p>Correctness is prioritized over speed.</p>"},{"location":"CORE_CHECKPOINT/#1-principles","title":"1. Principles","text":"<p>Checkpointing must satisfy:</p> <ul> <li>Atomicity</li> <li>Durability</li> <li>Determinism</li> <li>No partial success</li> <li>Explicit failure</li> </ul> <p>Checkpointing integrates snapshots with WAL truncation.</p>"},{"location":"CORE_CHECKPOINT/#2-definitions","title":"2. Definitions","text":""},{"location":"CORE_CHECKPOINT/#snapshot","title":"Snapshot","text":"<p>A durable copy of storage and schemas per SNAPSHOT.md.</p>"},{"location":"CORE_CHECKPOINT/#checkpoint","title":"Checkpoint","text":"<p>A successful snapshot PLUS WAL truncation.</p> <p>Checkpoint = Snapshot + WAL Reset.</p>"},{"location":"CORE_CHECKPOINT/#3-trigger-conditions","title":"3. Trigger Conditions","text":"<p>Phase 1 checkpointing is manual only.</p> <p>Triggered via:</p> <pre><code>aerodb checkpoint\n</code></pre> <p>No automatic or background checkpoints.</p>"},{"location":"CORE_CHECKPOINT/#4-checkpoint-algorithm-strict-order","title":"4. Checkpoint Algorithm (Strict Order)","text":"<p>Checkpoint execution MUST follow:</p> <ol> <li>Acquire global execution lock</li> <li>fsync WAL</li> <li>Create snapshot (per SNAPSHOT.md)</li> <li>fsync snapshot</li> <li>Write checkpoint manifest</li> <li>Truncate WAL to zero</li> <li>fsync WAL directory</li> <li>Release global execution lock</li> </ol> <p>Any failure aborts checkpoint.</p>"},{"location":"CORE_CHECKPOINT/#5-checkpoint-manifest","title":"5. Checkpoint Manifest","text":"<p>Location:</p> <p>```</p> <p>/checkpoint.json <p>````</p> <p>Example:</p> <p>```json {   \"snapshot_id\": \"20260204T113000Z\",   \"created_at\": \"2026-02-04T11:30:00Z\",   \"wal_truncated\": true,   \"format_version\": 1 } ````</p> <p>Written AFTER snapshot fsync and BEFORE WAL truncation.</p>"},{"location":"CORE_CHECKPOINT/#6-wal-truncation-rules","title":"6. WAL Truncation Rules","text":"<p>After snapshot success:</p> <ul> <li>WAL file deleted or truncated</li> <li>new WAL starts empty</li> <li>sequence numbers reset to 1</li> </ul> <p>Truncation must be atomic.</p> <p>If truncation fails:</p> <ul> <li>checkpoint fails</li> <li>snapshot remains</li> <li>WAL untouched</li> </ul>"},{"location":"CORE_CHECKPOINT/#7-crash-during-checkpoint","title":"7. Crash During Checkpoint","text":""},{"location":"CORE_CHECKPOINT/#case-1-crash-before-manifest-written","title":"Case 1 \u2014 crash before manifest written","text":"<p>\u2192 snapshot ignored \u2192 WAL replay from previous state</p>"},{"location":"CORE_CHECKPOINT/#case-2-crash-after-manifest-but-before-wal-truncation","title":"Case 2 \u2014 crash after manifest but before WAL truncation","text":"<p>\u2192 snapshot used \u2192 WAL replayed from beginning</p> <p>Safe but slower.</p>"},{"location":"CORE_CHECKPOINT/#case-3-crash-after-wal-truncation","title":"Case 3 \u2014 crash after WAL truncation","text":"<p>\u2192 snapshot used \u2192 WAL empty</p> <p>Fast recovery.</p> <p>No scenario causes data loss.</p>"},{"location":"CORE_CHECKPOINT/#8-startup-behavior","title":"8. Startup Behavior","text":"<p>On startup:</p> <ol> <li>Detect checkpoint.json</li> <li>Load referenced snapshot</li> <li>Replay WAL (if any)</li> <li>Rebuild indexes</li> <li>Verify consistency</li> </ol> <p>Checkpoint.json without snapshot is FATAL.</p> <p>Snapshot without checkpoint.json is ignored.</p>"},{"location":"CORE_CHECKPOINT/#9-corruption-policy","title":"9. Corruption Policy","text":"<p>Any corruption in:</p> <ul> <li>snapshot</li> <li>checkpoint.json</li> <li>WAL</li> </ul> <p>Results in:</p> <ul> <li>abort startup</li> <li>operator intervention required</li> </ul> <p>No auto-repair.</p>"},{"location":"CORE_CHECKPOINT/#10-phase-1-limitations","title":"10. Phase-1 Limitations","text":"<p>Checkpointing does NOT:</p> <ul> <li>run automatically</li> <li>run in background</li> <li>throttle writes</li> <li>support incremental snapshots</li> </ul> <p>All checkpoints are blocking and synchronous.</p>"},{"location":"CORE_CHECKPOINT/#11-determinism-guarantees","title":"11. Determinism Guarantees","text":"<p>Given identical:</p> <ul> <li>snapshot</li> <li>WAL</li> <li>schemas</li> </ul> <p>Recovery must produce identical state.</p> <p>Checkpointing introduces no non-determinism.</p>"},{"location":"CORE_CHECKPOINT/#12-authority","title":"12. Authority","text":"<p>This document governs:</p> <ul> <li>aerodb checkpoint</li> <li>WAL truncation</li> <li>startup recovery logic</li> <li>snapshot promotion</li> </ul> <p>Violations are correctness bugs.</p>"},{"location":"CORE_ERRORS/","title":"Error Handling","text":""},{"location":"CORE_ERRORS/#purpose","title":"Purpose","text":"<p>This document defines the error model for aerodb.</p> <p>Errors in aerodb are: - Explicit - Deterministic - Classified - Mapped to invariants</p> <p>There are no generic or silent failures.</p> <p>Every error must: - Have a stable code - Have a severity - Be traceable to a violated invariant or rule - Be explainable to humans</p> <p>If an error cannot be classified, it must not exist.</p>"},{"location":"CORE_ERRORS/#error-philosophy","title":"Error Philosophy","text":"<p>aerodb does not hide failures.</p> <p>Errors are treated as part of the public API and operational contract.</p> <p>The system prefers: - Loud failure over silent degradation - Deterministic errors over probabilistic behavior - Explicit rejection over best-effort execution</p>"},{"location":"CORE_ERRORS/#error-categories","title":"Error Categories","text":"<p>All errors belong to exactly one category:</p> Category Meaning CONFIG Startup / configuration invalid SCHEMA Schema definition or validation QUERY Query structure or safety STORAGE Persistent storage failures WAL Write-Ahead Log failures RECOVERY Crash recovery failures CORRUPTION Detected data corruption EXECUTION Runtime execution errors INTERNAL Logic violations (bugs) <p>Categories are part of the error code.</p>"},{"location":"CORE_ERRORS/#severity-levels","title":"Severity Levels","text":"<p>Every error has a severity:</p> Level Meaning FATAL aerodb must terminate ERROR Operation fails, server continues REJECT Client request rejected BUG Internal invariant violation <p>Severity is explicit and machine-readable.</p>"},{"location":"CORE_ERRORS/#error-code-format","title":"Error Code Format","text":"<p>All error codes follow:</p> <p>```</p> <p>AERO__ <p>````</p> <p>Examples: - <code>AERO_SCHEMA_VALIDATION_FAILED</code> - <code>AERO_WAL_CORRUPTION</code> - <code>AERO_QUERY_UNBOUNDED</code></p> <p>Codes are stable and never reused.</p>"},{"location":"CORE_ERRORS/#config-errors","title":"CONFIG Errors","text":"Code Severity Description AERO_CONFIG_INVALID FATAL Configuration file malformed AERO_CONFIG_UNSAFE FATAL Unsafe configuration detected AERO_CONFIG_IMMUTABLE FATAL Attempt to change immutable config"},{"location":"CORE_ERRORS/#schema-errors","title":"SCHEMA Errors","text":"Code Severity Description AERO_SCHEMA_REQUIRED REJECT No schema provided AERO_UNKNOWN_SCHEMA REJECT Schema ID not found AERO_UNKNOWN_SCHEMA_VERSION REJECT Schema version not found AERO_SCHEMA_VALIDATION_FAILED REJECT Document violates schema AERO_SCHEMA_IMMUTABLE REJECT Attempt to modify schema AERO_SCHEMA_VERSION_REQUIRED REJECT Missing schema_version in query"},{"location":"CORE_ERRORS/#query-errors","title":"QUERY Errors","text":"Code Severity Description AERO_QUERY_INVALID REJECT Malformed query AERO_QUERY_UNBOUNDED REJECT Query has no provable bounds AERO_QUERY_UNINDEXED_FIELD REJECT Predicate on non-indexed field AERO_QUERY_LIMIT_REQUIRED REJECT Missing or invalid limit AERO_QUERY_SORT_NOT_INDEXED REJECT Sort field not indexed AERO_QUERY_SCHEMA_MISMATCH REJECT Query schema version mismatch"},{"location":"CORE_ERRORS/#storage-errors","title":"STORAGE Errors","text":"Code Severity Description AERO_STORAGE_IO_ERROR ERROR Disk I/O failure AERO_STORAGE_WRITE_FAILED ERROR Document write failed AERO_STORAGE_READ_FAILED ERROR Document read failed"},{"location":"CORE_ERRORS/#wal-errors","title":"WAL Errors","text":"Code Severity Description AERO_WAL_APPEND_FAILED ERROR WAL write failed AERO_WAL_FSYNC_FAILED FATAL WAL fsync failed AERO_WAL_CORRUPTION FATAL WAL checksum failure"},{"location":"CORE_ERRORS/#recovery-errors","title":"RECOVERY Errors","text":"Code Severity Description AERO_RECOVERY_FAILED FATAL Recovery did not complete AERO_RECOVERY_SCHEMA_MISSING FATAL Schema missing during replay AERO_RECOVERY_INCONSISTENT FATAL Storage inconsistency detected"},{"location":"CORE_ERRORS/#corruption-errors","title":"CORRUPTION Errors","text":"Code Severity Description AERO_DATA_CORRUPTION FATAL Data checksum failure AERO_INDEX_CORRUPTION FATAL Index rebuild failed AERO_METADATA_CORRUPTION FATAL Metadata invalid"},{"location":"CORE_ERRORS/#execution-errors","title":"EXECUTION Errors","text":"Code Severity Description AERO_EXECUTION_FAILED ERROR Query execution failure AERO_EXECUTION_TIMEOUT ERROR Execution exceeded limits AERO_EXECUTION_LIMIT REJECT Memory or row limit exceeded"},{"location":"CORE_ERRORS/#internal-errors-bugs","title":"INTERNAL Errors (BUGS)","text":"<p>These represent invariant violations.</p> Code Severity Description AERO_INTERNAL_INVARIANT BUG Invariant violation AERO_INTERNAL_STATE BUG Impossible state AERO_INTERNAL_PANIC BUG Unhandled panic <p>These must: - Crash the process - Produce stack trace - Be treated as critical bugs</p>"},{"location":"CORE_ERRORS/#error-payload-structure","title":"Error Payload Structure","text":"<p>Every error response must include:</p> <p>```json {   \"code\": \"AERO_QUERY_UNBOUNDED\",   \"severity\": \"REJECT\",   \"message\": \"Range query on non-indexed field\",   \"invariant\": \"Q1\",   \"details\": {     \"field\": \"age\"   } } ````</p>"},{"location":"CORE_ERRORS/#required-fields","title":"Required Fields","text":"<ul> <li><code>code</code></li> <li><code>severity</code></li> <li><code>message</code></li> <li><code>invariant</code> (if applicable)</li> </ul>"},{"location":"CORE_ERRORS/#invariant-mapping","title":"Invariant Mapping","text":"<p>Errors must explicitly reference violated invariants when applicable.</p> <p>Examples:</p> Error Invariant AERO_QUERY_UNBOUNDED Q1 AERO_SCHEMA_VALIDATION_FAILED S2 AERO_WAL_CORRUPTION K2 AERO_DATA_CORRUPTION D2 AERO_CONFIG_UNSAFE O2"},{"location":"CORE_ERRORS/#operator-vs-client-responsibility","title":"Operator vs Client Responsibility","text":""},{"location":"CORE_ERRORS/#client-errors-reject","title":"Client Errors (REJECT)","text":"<p>Handled by user:</p> <ul> <li>Query violations</li> <li>Schema violations</li> <li>Limits exceeded</li> </ul>"},{"location":"CORE_ERRORS/#operator-errors-fatal","title":"Operator Errors (FATAL)","text":"<p>Require human intervention:</p> <ul> <li>Corruption</li> <li>Recovery failure</li> <li>WAL failure</li> <li>Config failure</li> </ul>"},{"location":"CORE_ERRORS/#logging-requirements","title":"Logging Requirements","text":"<p>All errors must be logged with:</p> <ul> <li>Timestamp</li> <li>Error code</li> <li>Severity</li> <li>Component</li> <li>Invariant (if any)</li> <li>Human-readable message</li> </ul> <p>FATAL errors must also log:</p> <ul> <li>Last WAL sequence number</li> <li>Recovery state (if applicable)</li> </ul>"},{"location":"CORE_ERRORS/#forbidden-error-behaviors","title":"Forbidden Error Behaviors","text":"<p>The following are forbidden:</p> <ul> <li>Generic \u201cunknown error\u201d</li> <li>Silent retries</li> <li>Partial success masking</li> <li>Random error messages</li> <li>Context-free failures</li> </ul> <p>Errors are contracts.</p>"},{"location":"CORE_ERRORS/#phase-0-trade-offs","title":"Phase 0 Trade-offs","text":"<ul> <li>Verbose errors preferred over minimal</li> <li>Crash on corruption</li> <li>Reject unsafe queries aggressively</li> </ul> <p>These are intentional.</p>"},{"location":"CORE_ERRORS/#final-statement","title":"Final Statement","text":"<p>Errors define operational truth.</p> <p>If aerodb fails quietly, it has already failed.</p> <p>Every failure must be explicit, classified, and traceable to a rule or invariant.</p> <p>This is not defensive programming.</p> <p>This is infrastructure discipline.</p>"},{"location":"CORE_INVARIANTS/","title":"Invariants","text":""},{"location":"CORE_INVARIANTS/#purpose","title":"Purpose","text":"<p>This document defines the absolute, non-negotiable invariants of aerodb.</p> <p>An invariant is a property that must hold true at all times: - During normal operation - Under load - During crashes - During recovery - Across upgrades - Across refactors</p> <p>If any invariant is violated, it is a critical bug. There are no exceptions, workarounds, or \u201ctemporary\u201d violations.</p> <p>aerodb is infrastructure software. Infrastructure without invariants is unreliable by definition.</p>"},{"location":"CORE_INVARIANTS/#invariant-categories","title":"Invariant Categories","text":"<p>The invariants are grouped into the following categories:</p> <ol> <li>Data Safety Invariants  </li> <li>Durability &amp; Recovery Invariants  </li> <li>Schema Invariants  </li> <li>Query &amp; Execution Invariants  </li> <li>Determinism Invariants  </li> <li>Failure Invariants  </li> <li>Operational Invariants  </li> <li>Evolution &amp; Upgrade Invariants  </li> </ol> <p>Each invariant is mandatory.</p>"},{"location":"CORE_INVARIANTS/#1-data-safety-invariants","title":"1. Data Safety Invariants","text":""},{"location":"CORE_INVARIANTS/#d1-no-acknowledged-write-is-ever-lost","title":"D1. No Acknowledged Write Is Ever Lost","text":"<ul> <li>Once a write operation is acknowledged as successful, it must survive:</li> <li>Process crashes</li> <li>Power loss</li> <li>System restarts</li> <li>Violating this invariant is a catastrophic failure.</li> </ul>"},{"location":"CORE_INVARIANTS/#d2-data-corruption-is-never-ignored","title":"D2. Data Corruption Is Never Ignored","text":"<ul> <li>Any detected corruption must:</li> <li>Halt affected operations</li> <li>Be surfaced explicitly</li> <li>Never be silently repaired or skipped</li> <li>Silent corruption is worse than downtime.</li> </ul>"},{"location":"CORE_INVARIANTS/#d3-reads-never-observe-invalid-state","title":"D3. Reads Never Observe Invalid State","text":"<ul> <li>A read must never return:</li> <li>Partially written data</li> <li>Corrupted records</li> <li>Schema-invalid data</li> <li>If consistency cannot be guaranteed, the read must fail.</li> </ul>"},{"location":"CORE_INVARIANTS/#2-durability-recovery-invariants","title":"2. Durability &amp; Recovery Invariants","text":""},{"location":"CORE_INVARIANTS/#r1-wal-precedes-acknowledgement","title":"R1. WAL Precedes Acknowledgement","text":"<ul> <li>All acknowledged writes must be recorded in the Write-Ahead Log   before the client receives success.</li> <li>There are no exceptions.</li> </ul>"},{"location":"CORE_INVARIANTS/#r2-recovery-is-deterministic","title":"R2. Recovery Is Deterministic","text":"<ul> <li>Given the same on-disk state and WAL,   recovery must always produce the same result.</li> <li>Recovery must not depend on timing, heuristics, or environment.</li> </ul>"},{"location":"CORE_INVARIANTS/#r3-recovery-completeness-is-verifiable","title":"R3. Recovery Completeness Is Verifiable","text":"<ul> <li>After recovery, aerodb must be able to assert:</li> <li>Whether recovery completed successfully</li> <li>Whether any data loss occurred</li> <li>Ambiguous recovery states are forbidden.</li> </ul>"},{"location":"CORE_INVARIANTS/#3-schema-invariants","title":"3. Schema Invariants","text":""},{"location":"CORE_INVARIANTS/#s1-schema-presence-is-mandatory","title":"S1. Schema Presence Is Mandatory","text":"<ul> <li>Every document belongs to a schema.</li> <li>Writes without a schema are forbidden.</li> <li>Partial schema validation is forbidden.</li> </ul>"},{"location":"CORE_INVARIANTS/#s2-schema-validity-is-enforced-on-write","title":"S2. Schema Validity Is Enforced on Write","text":"<ul> <li>No write may bypass schema validation.</li> <li>Invalid data must never enter persistent storage.</li> </ul>"},{"location":"CORE_INVARIANTS/#s3-schema-versions-are-explicit","title":"S3. Schema Versions Are Explicit","text":"<ul> <li>Schema changes create new schema versions.</li> <li>Schema versions are immutable once published.</li> <li>Documents must always reference an explicit schema version.</li> </ul>"},{"location":"CORE_INVARIANTS/#s4-schema-violations-are-fatal-to-the-write","title":"S4. Schema Violations Are Fatal to the Write","text":"<ul> <li>If data violates schema rules:</li> <li>The write fails</li> <li>No partial data is persisted</li> <li>There is no \u201cbest effort\u201d mode.</li> </ul>"},{"location":"CORE_INVARIANTS/#4-query-execution-invariants","title":"4. Query &amp; Execution Invariants","text":""},{"location":"CORE_INVARIANTS/#q1-queries-must-be-bounded","title":"Q1. Queries Must Be Bounded","text":"<ul> <li>Every query must have a provable upper bound on:</li> <li>Data scanned</li> <li>Time complexity</li> <li>Memory usage</li> <li>Queries without a bounded cost are rejected before execution.</li> </ul>"},{"location":"CORE_INVARIANTS/#q2-no-implicit-full-scans","title":"Q2. No Implicit Full Scans","text":"<ul> <li>Full collection scans are forbidden unless explicitly declared   and bounded.</li> <li>Hidden or accidental scans are a critical violation.</li> </ul>"},{"location":"CORE_INVARIANTS/#q3-execution-never-guesses","title":"Q3. Execution Never Guesses","text":"<ul> <li>The engine must not guess user intent.</li> <li>If intent is ambiguous, the query is rejected.</li> </ul>"},{"location":"CORE_INVARIANTS/#5-determinism-invariants","title":"5. Determinism Invariants","text":""},{"location":"CORE_INVARIANTS/#t1-deterministic-planning","title":"T1. Deterministic Planning","text":"<ul> <li>Given the same:</li> <li>Query</li> <li>Schema</li> <li>Indexes</li> <li>Data statistics</li> <li>The query planner must produce the same plan.</li> </ul>"},{"location":"CORE_INVARIANTS/#t2-deterministic-execution","title":"T2. Deterministic Execution","text":"<ul> <li>Query execution must not depend on:</li> <li>Runtime timing</li> <li>Thread scheduling</li> <li>Non-deterministic iteration order</li> <li>Results must be stable and repeatable.</li> </ul>"},{"location":"CORE_INVARIANTS/#t3-planner-changes-are-explicit","title":"T3. Planner Changes Are Explicit","text":"<ul> <li>Any change in planner behavior must:</li> <li>Be versioned</li> <li>Be opt-in</li> <li>Be observable</li> <li>Silent planner behavior changes are forbidden.</li> </ul>"},{"location":"CORE_INVARIANTS/#6-failure-invariants","title":"6. Failure Invariants","text":""},{"location":"CORE_INVARIANTS/#f1-fail-loudly-not-silently","title":"F1. Fail Loudly, Not Silently","text":"<ul> <li>Any failure must:</li> <li>Be explicit</li> <li>Be observable</li> <li>Be explainable</li> <li>Silent degradation is forbidden.</li> </ul>"},{"location":"CORE_INVARIANTS/#f2-partial-success-is-not-allowed","title":"F2. Partial Success Is Not Allowed","text":"<ul> <li>Operations must be:</li> <li>Fully successful, or</li> <li>Fully failed</li> <li>Mixed or partial outcomes are forbidden.</li> </ul>"},{"location":"CORE_INVARIANTS/#f3-errors-are-deterministic","title":"F3. Errors Are Deterministic","text":"<ul> <li>The same failure condition must produce the same error code   and classification.</li> <li>Random or context-dependent errors are forbidden.</li> </ul>"},{"location":"CORE_INVARIANTS/#7-operational-invariants","title":"7. Operational Invariants","text":""},{"location":"CORE_INVARIANTS/#o1-behavior-is-environment-independent","title":"O1. Behavior Is Environment-Independent","text":"<ul> <li>aerodb must behave identically across:</li> <li>Local development</li> <li>Self-hosted production</li> <li>CI environments</li> <li>Environment-specific behavior is forbidden.</li> </ul>"},{"location":"CORE_INVARIANTS/#o2-configuration-cannot-violate-safety","title":"O2. Configuration Cannot Violate Safety","text":"<ul> <li>Configuration options must not allow:</li> <li>Disabling durability</li> <li>Weakening validation</li> <li>Bypassing invariants</li> <li>Unsafe configuration states must be rejected.</li> </ul>"},{"location":"CORE_INVARIANTS/#o3-observability-is-mandatory","title":"O3. Observability Is Mandatory","text":"<ul> <li>The system must always be able to explain:</li> <li>What it is doing</li> <li>Why it failed</li> <li>What guarantees are currently upheld</li> <li>Opaque operation is forbidden.</li> </ul>"},{"location":"CORE_INVARIANTS/#8-evolution-upgrade-invariants","title":"8. Evolution &amp; Upgrade Invariants","text":""},{"location":"CORE_INVARIANTS/#e1-backward-compatibility-is-explicit","title":"E1. Backward Compatibility Is Explicit","text":"<ul> <li>Backward compatibility guarantees must be documented.</li> <li>Breaking changes must:</li> <li>Be deliberate</li> <li>Be visible</li> <li>Be justified</li> <li>Accidental breaking changes are unacceptable.</li> </ul>"},{"location":"CORE_INVARIANTS/#e2-upgrades-must-not-corrupt-data","title":"E2. Upgrades Must Not Corrupt Data","text":"<ul> <li>Upgrading aerodb must never:</li> <li>Corrupt data</li> <li>Silently rewrite data</li> <li>Change semantics without opt-in</li> </ul>"},{"location":"CORE_INVARIANTS/#e3-downgrade-safety-must-be-defined","title":"E3. Downgrade Safety Must Be Defined","text":"<ul> <li>If downgrades are unsupported, this must be explicit.</li> <li>Undefined downgrade behavior is forbidden.</li> </ul>"},{"location":"CORE_INVARIANTS/#enforcement-rules","title":"Enforcement Rules","text":"<ul> <li>All invariants must be enforceable by code.</li> <li>Invariants must be testable.</li> <li>Tests that validate invariants are higher priority than features.</li> <li>Performance optimizations must not weaken invariants.</li> </ul> <p>If an optimization conflicts with an invariant, the optimization is rejected.</p>"},{"location":"CORE_INVARIANTS/#final-statement","title":"Final Statement","text":"<p>These invariants are not aspirational. They are mandatory.</p> <p>aerodb is trusted only insofar as these invariants hold. If they are violated, trust is lost.</p> <p>There are no exceptions.</p>"},{"location":"CORE_LIFECYCLE/","title":"Lifecycle","text":"<p>This document defines the authoritative lifecycle of an AeroDB instance.</p> <p>It governs:</p> <ul> <li>CLI behavior</li> <li>Process startup</li> <li>Shutdown semantics</li> <li>Crash recovery</li> <li>Restart guarantees</li> <li>Operator expectations</li> </ul> <p>If implementation behavior conflicts with this document, the implementation is wrong.</p> <p>AeroDB lifecycle is explicit, deterministic, and conservative.</p>"},{"location":"CORE_LIFECYCLE/#1-lifecycle-states","title":"1. Lifecycle States","text":"<p>An AeroDB instance exists in exactly one of the following states:</p> <ol> <li>UNINITIALIZED  </li> <li>INITIALIZING  </li> <li>RECOVERING  </li> <li>VERIFYING  </li> <li>SERVING  </li> <li>SHUTTING_DOWN  </li> <li>TERMINATED  </li> </ol> <p>Transitions are strictly ordered.</p> <p>There are no parallel states.</p>"},{"location":"CORE_LIFECYCLE/#2-uninitialized","title":"2. UNINITIALIZED","text":"<p>The system is UNINITIALIZED when:</p> <ul> <li><code>data_dir</code> does not exist</li> <li>or contains no AeroDB metadata</li> </ul> <p>Allowed action:</p> <pre><code>aerodb init\n</code></pre> <p>Behavior:</p> <ul> <li>Creates directory structure</li> <li>Initializes WAL and storage files</li> <li>Creates metadata directories</li> <li>Does NOT start serving</li> </ul> <p>No queries or writes allowed.</p>"},{"location":"CORE_LIFECYCLE/#3-initializing","title":"3. INITIALIZING","text":"<p>Entered on:</p> <pre><code>aerodb start\n</code></pre> <p>Steps:</p> <ol> <li>Load configuration</li> <li>Validate config</li> <li>Load schemas</li> </ol> <p>Failure at any step \u2192 TERMINATED.</p> <p>No WAL or storage access before schema load completes.</p>"},{"location":"CORE_LIFECYCLE/#4-recovering","title":"4. RECOVERING","text":"<p>Entered after INITIALIZING succeeds.</p> <p>Performed by Recovery Manager.</p> <p>Steps:</p> <ol> <li>Replay WAL from byte 0</li> <li>Apply records to storage</li> <li>Rebuild indexes</li> </ol> <p>Rules:</p> <ul> <li>WAL corruption \u2192 TERMINATED</li> <li>Storage corruption \u2192 TERMINATED</li> <li>No partial replay</li> <li>No degraded mode</li> </ul> <p>Same WAL must always produce same state.</p>"},{"location":"CORE_LIFECYCLE/#5-verifying","title":"5. VERIFYING","text":"<p>Entered after RECOVERING.</p> <p>Steps:</p> <ol> <li>Sequentially scan storage</li> <li>Validate checksums</li> <li>Verify schema references</li> </ol> <p>Failure \u2192 TERMINATED.</p> <p>This guarantees internal consistency before serving.</p>"},{"location":"CORE_LIFECYCLE/#6-serving","title":"6. SERVING","text":"<p>Entered only after VERIFYING succeeds.</p> <p>Behavior:</p> <ul> <li>API becomes available</li> <li>Global execution lock active</li> <li>Queries and writes allowed</li> <li>All operations serialized</li> </ul> <p>System remains SERVING until explicit shutdown or crash.</p>"},{"location":"CORE_LIFECYCLE/#7-shutting_down","title":"7. SHUTTING_DOWN","text":"<p>Entered on:</p> <ul> <li>SIGTERM</li> <li>CLI stop</li> <li>controlled exit</li> </ul> <p>Steps:</p> <ol> <li>Stop accepting API requests</li> <li>Wait for in-flight operation</li> <li>Write <code>clean_shutdown</code> marker</li> <li>Exit process</li> </ol> <p>No background cleanup.</p>"},{"location":"CORE_LIFECYCLE/#8-terminated","title":"8. TERMINATED","text":"<p>Final state.</p> <p>Process exits.</p> <p>Causes:</p> <ul> <li>Fatal error</li> <li>Crash</li> <li>Operator shutdown</li> </ul> <p>On next start:</p> <ul> <li>Full recovery always runs</li> </ul>"},{"location":"CORE_LIFECYCLE/#9-crash-semantics","title":"9. Crash Semantics","text":"<p>Crash includes:</p> <ul> <li>power loss</li> <li>SIGKILL</li> <li>panic</li> <li>segmentation fault</li> </ul> <p>Behavior:</p> <ul> <li>clean_shutdown marker absent</li> <li>WAL replay required</li> <li>storage verified</li> <li>indexes rebuilt</li> </ul> <p>Crash does NOT corrupt correctness unless disk data is corrupted.</p>"},{"location":"CORE_LIFECYCLE/#10-restart-semantics","title":"10. Restart Semantics","text":"<p>Restart always executes:</p> <ol> <li>INITIALIZING</li> <li>RECOVERING</li> <li>VERIFYING</li> <li>SERVING</li> </ol> <p>Clean shutdown does NOT skip recovery in Phase 0.</p> <p>Fast-start is forbidden.</p>"},{"location":"CORE_LIFECYCLE/#11-upgrade-semantics-phase-0","title":"11. Upgrade Semantics (Phase 0)","text":"<p>Phase 0 does NOT support:</p> <ul> <li>in-place upgrades</li> <li>rolling upgrades</li> <li>schema migrations</li> </ul> <p>Binary upgrades require:</p> <ol> <li>Full shutdown</li> <li>Replace executable</li> <li>Start</li> </ol> <p>Backward compatibility is not guaranteed.</p>"},{"location":"CORE_LIFECYCLE/#12-operator-responsibilities","title":"12. Operator Responsibilities","text":"<p>Operators must:</p> <ul> <li>maintain backups</li> <li>monitor disk health</li> <li>respond to FATAL errors</li> <li>restore from backup if corruption occurs</li> </ul> <p>AeroDB does not auto-repair.</p>"},{"location":"CORE_LIFECYCLE/#13-determinism-guarantees","title":"13. Determinism Guarantees","text":"<p>Given identical:</p> <ul> <li>WAL</li> <li>storage</li> <li>schemas</li> <li>config</li> </ul> <p>AeroDB must:</p> <ul> <li>reach SERVING</li> <li>expose identical data</li> <li>return identical query results</li> </ul> <p>No lifecycle step may depend on time or environment.</p>"},{"location":"CORE_LIFECYCLE/#14-phase-0-limitations","title":"14. Phase-0 Limitations","text":"<p>Explicitly unsupported:</p> <ul> <li>hot reload</li> <li>online upgrades</li> <li>partial recovery</li> <li>read-only mode</li> <li>degraded serving</li> </ul> <p>Failure is terminal.</p>"},{"location":"CORE_LIFECYCLE/#15-authority","title":"15. Authority","text":"<p>This document governs:</p> <ul> <li>CLI commands</li> <li>Recovery Manager</li> <li>main.rs</li> <li>operator expectations</li> </ul> <p>Violations are correctness bugs.</p>"},{"location":"CORE_QUERY/","title":"Query Engine","text":""},{"location":"CORE_QUERY/#purpose","title":"Purpose","text":"<p>This document defines the query model, syntax, semantics, and enforcement rules for aerodb in Phase 0.</p> <p>Queries in aerodb are: - Explicit - Deterministic - Bounded - Schema-version-specific</p> <p>Any query that violates these properties is rejected before execution.</p>"},{"location":"CORE_QUERY/#query-philosophy","title":"Query Philosophy","text":"<p>aerodb does not attempt to be expressive. It attempts to be predictable.</p> <p>Queries are designed to: - Be statically analyzable - Have provable upper bounds - Produce deterministic results - Never guess user intent</p> <p>If a query cannot be safely reasoned about, it is forbidden.</p>"},{"location":"CORE_QUERY/#query-scope-phase-0","title":"Query Scope (Phase 0)","text":""},{"location":"CORE_QUERY/#supported","title":"Supported","text":"<ul> <li>Single-collection queries</li> <li>Equality and bounded range predicates</li> <li>Explicit sorting</li> <li>Explicit limits</li> <li>Deterministic execution plans</li> </ul>"},{"location":"CORE_QUERY/#explicitly-not-supported","title":"Explicitly Not Supported","text":"<ul> <li>Joins</li> <li>Aggregations</li> <li>Subqueries</li> <li>Cross-collection queries</li> <li>Full-text search</li> <li>Geospatial queries</li> <li>Vector search</li> <li>Ad-hoc projections</li> <li>Server-side functions</li> </ul>"},{"location":"CORE_QUERY/#query-structure","title":"Query Structure","text":"<p>All queries must conform to the following structure:</p> <pre><code>{\n  \"collection\": \"&lt;string&gt;\",\n  \"schema_id\": \"&lt;string&gt;\",\n  \"schema_version\": \"&lt;string&gt;\",\n  \"filter\": { ... },\n  \"sort\": [ ... ],\n  \"limit\": &lt;integer&gt;\n}\n````\n\n### Required Fields\n\n| Field            | Required | Description                     |\n| ---------------- | -------- | ------------------------------- |\n| `collection`     | Yes      | Target collection name          |\n| `schema_id`      | Yes      | Schema identifier               |\n| `schema_version` | Yes      | Explicit schema version         |\n| `filter`         | Yes      | Predicate object (may be empty) |\n| `limit`          | Yes      | Maximum number of documents     |\n\nThere are **no defaults**.\nMissing fields cause query rejection.\n\n---\n\n## Filter Semantics\n\n### Filter Object\n\nThe `filter` field is a JSON object describing predicates.\n\nExample:\n\n```json\n{\n  \"email\": \"user@example.com\",\n  \"age\": { \"$gte\": 18, \"$lte\": 30 }\n}\n</code></pre>"},{"location":"CORE_QUERY/#supported-predicate-types","title":"Supported Predicate Types","text":""},{"location":"CORE_QUERY/#equality-predicate","title":"Equality Predicate","text":"<pre><code>{ \"field\": \"value\" }\n</code></pre> <p>Rules:</p> <ul> <li>Field must be indexed</li> <li>Field must exist in schema</li> <li>Exact type match required</li> </ul>"},{"location":"CORE_QUERY/#range-predicate","title":"Range Predicate","text":"<pre><code>{ \"field\": { \"$gte\": 10, \"$lte\": 20 } }\n</code></pre> <p>Rules:</p> <ul> <li>Field must be indexed</li> <li>At least one bound required</li> <li>Must be paired with an explicit <code>limit</code></li> <li>Only numeric fields allowed</li> </ul>"},{"location":"CORE_QUERY/#predicate-combination-rules","title":"Predicate Combination Rules","text":"<ul> <li>All predicates are combined using logical AND</li> <li>OR conditions are forbidden</li> <li>Nested predicates are forbidden</li> </ul>"},{"location":"CORE_QUERY/#forbidden-filters","title":"Forbidden Filters","text":"<p>The following cause immediate rejection:</p> <ul> <li>Filters on non-indexed fields</li> <li>Empty filter with no primary key</li> <li>OR conditions</li> <li>Regex or pattern matching</li> <li>Functions or expressions</li> <li>Implicit type conversion</li> </ul>"},{"location":"CORE_QUERY/#primary-key-queries","title":"Primary Key Queries","text":""},{"location":"CORE_QUERY/#_id-lookup","title":"<code>_id</code> Lookup","text":"<p>Example:</p> <pre><code>{\n  \"filter\": { \"_id\": \"abc123\" },\n  \"limit\": 1\n}\n</code></pre> <p>Rules:</p> <ul> <li><code>_id</code> equality queries are always bounded</li> <li><code>limit</code> must be <code>1</code></li> <li><code>_id</code> must be indexed (mandatory)</li> </ul>"},{"location":"CORE_QUERY/#sorting-semantics","title":"Sorting Semantics","text":""},{"location":"CORE_QUERY/#sort-structure","title":"Sort Structure","text":"<pre><code>\"sort\": [\n  { \"field\": \"age\", \"order\": \"asc\" }\n]\n</code></pre>"},{"location":"CORE_QUERY/#sort-rules","title":"Sort Rules","text":"<ul> <li>Sort fields must be indexed</li> <li>Sort order must be explicit (<code>asc</code> or <code>desc</code>)</li> <li>Multi-field sort is forbidden in Phase 0</li> <li>Sorting without an index is forbidden</li> </ul>"},{"location":"CORE_QUERY/#limit-semantics","title":"Limit Semantics","text":""},{"location":"CORE_QUERY/#limit-rules","title":"Limit Rules","text":"<ul> <li><code>limit</code> is mandatory</li> <li><code>limit</code> must be a positive integer</li> <li>Maximum allowed limit is implementation-defined</li> <li>Queries without <code>limit</code> are rejected</li> </ul> <p>Limits are part of query safety guarantees.</p>"},{"location":"CORE_QUERY/#query-boundedness-rules","title":"Query Boundedness Rules","text":"<p>A query is considered bounded if:</p> <ol> <li>It uses only indexed fields</li> <li>It includes a mandatory <code>limit</code></li> <li> <p>The planner can compute an upper bound on:</p> </li> <li> <p>Documents scanned</p> </li> <li>Memory usage</li> <li>Execution time</li> </ol> <p>Queries that fail boundedness checks are rejected.</p>"},{"location":"CORE_QUERY/#query-planning-rules","title":"Query Planning Rules","text":""},{"location":"CORE_QUERY/#deterministic-planner-requirements","title":"Deterministic Planner Requirements","text":"<ul> <li>Planner uses rule-based index selection</li> <li>No statistics-driven heuristics</li> <li>No adaptive optimization</li> <li>Same inputs \u2192 same plan</li> </ul>"},{"location":"CORE_QUERY/#index-selection-priority","title":"Index Selection Priority","text":"<ol> <li>Primary key equality</li> <li>Indexed equality</li> <li>Indexed range with limit</li> </ol> <p>If no valid index applies \u2192 reject query.</p>"},{"location":"CORE_QUERY/#execution-semantics","title":"Execution Semantics","text":""},{"location":"CORE_QUERY/#execution-guarantees","title":"Execution Guarantees","text":"<ul> <li>Single-threaded execution</li> <li>Stable iteration order</li> <li>Deterministic result ordering</li> <li>No runtime plan changes</li> </ul>"},{"location":"CORE_QUERY/#result-ordering","title":"Result Ordering","text":"<p>Results are ordered by:</p> <ul> <li>Index traversal order, or</li> <li>Primary key order if applicable</li> </ul> <p>There is no implicit ordering.</p>"},{"location":"CORE_QUERY/#schema-enforcement-during-queries","title":"Schema Enforcement During Queries","text":"<ul> <li> <p>All returned documents must match:</p> </li> <li> <p><code>schema_id</code></p> </li> <li><code>schema_version</code></li> <li>Documents with different versions are excluded</li> <li>Cross-version reads are forbidden</li> </ul> <p>Queries without explicit schema version are rejected.</p>"},{"location":"CORE_QUERY/#error-handling","title":"Error Handling","text":""},{"location":"CORE_QUERY/#query-errors","title":"Query Errors","text":"Error Code Condition <code>QUERY_INVALID</code> Malformed query structure <code>SCHEMA_REQUIRED</code> Missing schema fields <code>UNKNOWN_SCHEMA</code> Schema ID not found <code>UNKNOWN_SCHEMA_VERSION</code> Schema version not found <code>UNBOUNDED_QUERY</code> Cannot prove bounded execution <code>UNINDEXED_FIELD</code> Filter or sort on non-indexed field <code>LIMIT_REQUIRED</code> Missing or invalid limit <code>SORT_NOT_INDEXED</code> Sort field not indexed <p>Errors are deterministic and explicit.</p>"},{"location":"CORE_QUERY/#explain-plan-requirement","title":"Explain Plan Requirement","text":"<p>Every query must support an explain plan.</p> <p>Explain output includes:</p> <ul> <li>Selected index</li> <li>Predicate evaluation order</li> <li>Estimated bounds</li> <li>Rejection reason (if applicable)</li> </ul> <p>Explain plans are human-readable and deterministic.</p>"},{"location":"CORE_QUERY/#forbidden-query-behaviors","title":"Forbidden Query Behaviors","text":"<p>The following are strictly forbidden:</p> <ul> <li>Implicit full scans</li> <li>Implicit sorting</li> <li>Implicit limits</li> <li>Guessing user intent</li> <li>Adaptive re-planning</li> <li>Partial execution</li> </ul> <p>Any such behavior is a bug.</p>"},{"location":"CORE_QUERY/#invariants-enforced-by-query-system","title":"Invariants Enforced by Query System","text":"Invariant Enforcement Q1 Mandatory bounds + limit Q2 No implicit scans Q3 No guessing T1 Deterministic planning T2 Deterministic execution F1 Fail loudly F3 Deterministic errors"},{"location":"CORE_QUERY/#phase-0-trade-offs-intentional","title":"Phase 0 Trade-offs (Intentional)","text":"<ul> <li>Expressiveness is limited</li> <li>Some valid workloads are rejected</li> <li>Clients must structure data carefully</li> <li>Safety &gt; flexibility</li> </ul> <p>These trade-offs are deliberate.</p>"},{"location":"CORE_QUERY/#final-statement","title":"Final Statement","text":"<p>Queries are executable contracts.</p> <p>If aerodb cannot prove a query is safe, it refuses to run it.</p> <p>This is not a limitation. It is the foundation of predictability.</p>"},{"location":"CORE_RELIABILITY/","title":"Reliability","text":""},{"location":"CORE_RELIABILITY/#purpose","title":"Purpose","text":"<p>This document defines the reliability guarantees of aerodb.</p> <p>Reliability is not a feature. It is the foundation upon which all other features depend.</p> <p>aerodb is expected to meet the reliability expectations commonly associated with mature infrastructure platforms such as Supabase, while maintaining its own stricter guarantees around determinism and explicit behavior.</p> <p>These guarantees are mandatory. Any design or implementation that weakens them is rejected.</p>"},{"location":"CORE_RELIABILITY/#reliability-philosophy","title":"Reliability Philosophy","text":"<p>aerodb assumes: - Hardware will fail - Processes will crash - Power will be lost - Humans will make mistakes</p> <p>The system must remain correct and predictable in the presence of these failures.</p> <p>Reliability in aerodb is defined as: - Data safety over availability - Explicit failure over silent degradation - Deterministic recovery over best-effort repair - Operational clarity over hidden resilience</p>"},{"location":"CORE_RELIABILITY/#core-reliability-guarantees","title":"Core Reliability Guarantees","text":""},{"location":"CORE_RELIABILITY/#r0-no-acknowledged-data-loss","title":"R0. No Acknowledged Data Loss","text":"<p>Once aerodb acknowledges a write operation as successful: - That data must survive process crashes - That data must survive power loss - That data must survive system restarts</p> <p>Any violation of this guarantee is considered catastrophic.</p>"},{"location":"CORE_RELIABILITY/#r1-write-ahead-logging-is-mandatory","title":"R1. Write-Ahead Logging Is Mandatory","text":"<ul> <li>All write operations must be recorded in a Write-Ahead Log (WAL)   before being acknowledged.</li> <li>WAL persistence must be enforced with explicit fsync boundaries.</li> <li>There are no modes that bypass WAL for acknowledged writes.</li> </ul> <p>Disabling or weakening WAL durability is forbidden.</p>"},{"location":"CORE_RELIABILITY/#r2-crash-recovery-is-deterministic","title":"R2. Crash Recovery Is Deterministic","text":"<ul> <li>Given the same on-disk data and WAL, recovery must always:</li> <li>Produce the same resulting state</li> <li>Replay the same operations in the same order</li> <li>Recovery behavior must not depend on:</li> <li>Timing</li> <li>Thread scheduling</li> <li>Environment-specific factors</li> </ul> <p>Non-deterministic recovery is unacceptable.</p>"},{"location":"CORE_RELIABILITY/#r3-recovery-completeness-is-explicit","title":"R3. Recovery Completeness Is Explicit","text":"<p>After recovery, aerodb must be able to explicitly report: - Whether recovery completed successfully - Whether any WAL entries were skipped - Whether any data loss occurred</p> <p>Ambiguous recovery states are forbidden.</p>"},{"location":"CORE_RELIABILITY/#consistency-guarantees","title":"Consistency Guarantees","text":""},{"location":"CORE_RELIABILITY/#c1-single-document-atomicity","title":"C1. Single-Document Atomicity","text":"<ul> <li>Writes to a single document are atomic.</li> <li>Partial updates to a document must never be observable.</li> <li>Reads must never return partially written or invalid data.</li> </ul>"},{"location":"CORE_RELIABILITY/#c2-read-after-write-consistency-single-node","title":"C2. Read-After-Write Consistency (Single Node)","text":"<ul> <li>After a successful write acknowledgment:</li> <li>Subsequent reads on the same node must observe the write.</li> <li>Stale reads after acknowledged writes are forbidden.</li> </ul>"},{"location":"CORE_RELIABILITY/#c3-schema-consistent-reads","title":"C3. Schema-Consistent Reads","text":"<ul> <li>Reads must always return data that conforms to the declared schema.</li> <li>Schema-invalid data must never be readable.</li> <li>If schema consistency cannot be guaranteed, the read must fail.</li> </ul>"},{"location":"CORE_RELIABILITY/#failure-handling-guarantees","title":"Failure Handling Guarantees","text":""},{"location":"CORE_RELIABILITY/#f1-fail-fast-fail-loud","title":"F1. Fail Fast, Fail Loud","text":"<ul> <li>Failures must be detected as early as possible.</li> <li>Failures must be surfaced explicitly to the caller.</li> <li>Silent failure, silent retries, or silent degradation are forbidden.</li> </ul>"},{"location":"CORE_RELIABILITY/#f2-no-partial-success-masking","title":"F2. No Partial Success Masking","text":"<ul> <li>Operations must be:</li> <li>Fully successful, or</li> <li>Fully failed</li> <li>aerodb must not report success for operations that only partially completed.</li> </ul>"},{"location":"CORE_RELIABILITY/#f3-deterministic-error-semantics","title":"F3. Deterministic Error Semantics","text":"<ul> <li>The same failure condition must always result in:</li> <li>The same error code</li> <li>The same failure classification</li> <li>Random, timing-dependent, or environment-dependent error behavior is forbidden.</li> </ul>"},{"location":"CORE_RELIABILITY/#corruption-handling-guarantees","title":"Corruption Handling Guarantees","text":""},{"location":"CORE_RELIABILITY/#k1-corruption-detection-is-mandatory","title":"K1. Corruption Detection Is Mandatory","text":"<ul> <li>On-disk data structures must include integrity checks (e.g. checksums).</li> <li>Corruption must be detected deterministically.</li> </ul>"},{"location":"CORE_RELIABILITY/#k2-corruption-is-never-silently-repaired","title":"K2. Corruption Is Never Silently Repaired","text":"<ul> <li>Detected corruption must:</li> <li>Halt affected operations</li> <li>Be reported explicitly</li> <li>Silent repair, skipping, or masking of corruption is forbidden.</li> </ul> <p>Downtime is preferable to silent corruption.</p>"},{"location":"CORE_RELIABILITY/#operational-reliability-guarantees","title":"Operational Reliability Guarantees","text":""},{"location":"CORE_RELIABILITY/#o1-predictable-startup-and-shutdown","title":"O1. Predictable Startup and Shutdown","text":"<ul> <li>Startup behavior must be deterministic and observable.</li> <li>Shutdown must:</li> <li>Complete pending durable operations, or</li> <li>Explicitly fail and report incomplete work</li> </ul>"},{"location":"CORE_RELIABILITY/#o2-minimal-configuration-safe-defaults","title":"O2. Minimal Configuration, Safe Defaults","text":"<ul> <li>Default configuration must be safe and durable.</li> <li>Configuration options must not allow users to:</li> <li>Disable durability guarantees</li> <li>Weaken consistency guarantees</li> <li>Violate invariants</li> </ul> <p>Unsafe configurations must be rejected.</p>"},{"location":"CORE_RELIABILITY/#o3-observable-system-state","title":"O3. Observable System State","text":"<p>At all times, aerodb must be able to explain: - What it is doing - What guarantees are currently upheld - Why an operation failed</p> <p>Opacity is treated as a reliability failure.</p>"},{"location":"CORE_RELIABILITY/#upgrade-and-evolution-guarantees","title":"Upgrade and Evolution Guarantees","text":""},{"location":"CORE_RELIABILITY/#u1-data-safety-across-upgrades","title":"U1. Data Safety Across Upgrades","text":"<ul> <li>Upgrading aerodb must never:</li> <li>Corrupt existing data</li> <li>Silently rewrite data</li> <li>Change semantics without explicit opt-in</li> </ul>"},{"location":"CORE_RELIABILITY/#u2-explicit-compatibility-contracts","title":"U2. Explicit Compatibility Contracts","text":"<ul> <li>Backward compatibility guarantees must be documented.</li> <li>Breaking changes must:</li> <li>Be intentional</li> <li>Be visible</li> <li>Be justified</li> </ul> <p>Accidental breaking changes are unacceptable.</p>"},{"location":"CORE_RELIABILITY/#institutional-responsibility","title":"Institutional Responsibility","text":"<p>aerodb is backed by Tonmoy Infrastructure &amp; Vision.</p> <p>This implies: - Long-term maintenance expectations - Conservative evolution - Reliability over experimentation - Accountability for failures</p> <p>Reliability claims must be defensible through: - Code - Tests - Documentation - Operational behavior</p>"},{"location":"CORE_RELIABILITY/#enforcement","title":"Enforcement","text":"<ul> <li>Reliability guarantees override performance optimizations.</li> <li>Any optimization that weakens reliability is rejected.</li> <li>Reliability-related tests take precedence over feature tests.</li> </ul> <p>If a choice must be made between: - Being fast, or - Being correct and predictable</p> <p>aerodb always chooses correctness and predictability.</p>"},{"location":"CORE_RELIABILITY/#final-statement","title":"Final Statement","text":"<p>Reliability is not something aerodb hopes to achieve. It is something aerodb enforces by design.</p> <p>If these guarantees cannot be upheld, the system must fail explicitly rather than pretend otherwise.</p> <p>Trust is earned only through discipline.</p>"},{"location":"CORE_RESTORE/","title":"RESTORE.md \u2014 AeroDB Restore Specification (Phase 1)","text":"<p>This document defines the authoritative restore behavior for AeroDB Phase 1.</p> <p>Restore reconstructs a complete AeroDB instance from a backup archive.</p> <p>Restore is destructive.</p> <p>Existing data is overwritten.</p> <p>If implementation behavior conflicts with this document, the implementation is wrong.</p>"},{"location":"CORE_RESTORE/#1-principles","title":"1. Principles","text":"<p>Restore must satisfy:</p> <ul> <li>Atomic replacement</li> <li>Full integrity verification</li> <li>Deterministic outcome</li> <li>Zero partial success</li> <li>Explicit failure</li> </ul> <p>Restore never merges data.</p> <p>Restore always replaces.</p>"},{"location":"CORE_RESTORE/#2-restore-command","title":"2. Restore Command","text":"<p>Triggered manually:</p> <pre><code>aerodb restore --config aerodb.json --input backup.tar\n</code></pre> <p>Restore may only run when AeroDB is NOT serving.</p>"},{"location":"CORE_RESTORE/#3-restore-preconditions","title":"3. Restore Preconditions","text":"<p>Before restore:</p> <ul> <li>AeroDB must not be running</li> <li>data_dir must exist</li> <li>backup.tar must exist and be readable</li> </ul> <p>If any fail \u2192 abort.</p>"},{"location":"CORE_RESTORE/#4-restore-contents","title":"4. Restore Contents","text":"<p>Restore expects:</p> <pre><code>backup.tar\n\u251c\u2500\u2500 snapshot/\n\u251c\u2500\u2500 wal/\n\u2514\u2500\u2500 backup_manifest.json\n</code></pre> <p>Missing any \u2192 FATAL.</p>"},{"location":"CORE_RESTORE/#5-restore-algorithm-strict-order","title":"5. Restore Algorithm (Strict Order)","text":"<p>Restore MUST follow:</p> <ol> <li>Verify AeroDB not running</li> <li>Extract backup.tar to temp directory</li> <li>Validate backup_manifest.json</li> <li>Validate snapshot manifest and checksums</li> <li>Validate schema files</li> <li>Validate WAL checksum</li> <li>Move existing data_dir \u2192 data_dir.old</li> <li>Create fresh data_dir</li> <li>Copy snapshot storage \u2192 data_dir/data/</li> <li>Copy schemas \u2192 data_dir/metadata/schemas/</li> <li>Copy WAL \u2192 data_dir/wal/</li> <li>fsync data_dir recursively</li> <li>Delete data_dir.old</li> </ol> <p>Only after all succeed is restore complete.</p> <p>Any failure aborts.</p>"},{"location":"CORE_RESTORE/#6-atomic-replacement","title":"6. Atomic Replacement","text":"<p>Restore uses directory swap:</p> <ul> <li>Original data_dir moved aside</li> <li>New data_dir constructed</li> <li>Only after success is old data deleted</li> </ul> <p>Crash during restore:</p> <ul> <li>Either old or new directory remains</li> <li>Never partial mixed state</li> </ul>"},{"location":"CORE_RESTORE/#7-startup-after-restore","title":"7. Startup After Restore","text":"<p>After restore:</p> <pre><code>aerodb start\n</code></pre> <p>Startup performs:</p> <ul> <li>snapshot loading</li> <li>WAL replay</li> <li>index rebuild</li> <li>verification</li> </ul> <p>Restore does NOT build indexes.</p> <p>Restore prepares data only.</p>"},{"location":"CORE_RESTORE/#8-corruption-policy","title":"8. Corruption Policy","text":"<p>If corruption detected:</p> <ul> <li>abort restore</li> <li>original data_dir preserved</li> <li>operator intervention required</li> </ul> <p>No auto-repair.</p>"},{"location":"CORE_RESTORE/#9-determinism","title":"9. Determinism","text":"<p>Given identical backup.tar:</p> <p>Restore must produce identical data_dir.</p> <p>No timestamps or random IDs introduced.</p>"},{"location":"CORE_RESTORE/#10-phase-1-limitations","title":"10. Phase-1 Limitations","text":"<p>Restore does NOT support:</p> <ul> <li>partial restore</li> <li>namespace restore</li> <li>selective collections</li> <li>live restore</li> </ul> <p>These belong to later phases.</p>"},{"location":"CORE_RESTORE/#11-authority","title":"11. Authority","text":"<p>This document governs:</p> <ul> <li>aerodb restore</li> <li>disaster recovery</li> <li>backup validation</li> </ul> <p>Violations are correctness bugs.</p>"},{"location":"CORE_SCHEMA/","title":"Schema System","text":""},{"location":"CORE_SCHEMA/#purpose","title":"Purpose","text":"<p>This document defines the schema system for aerodb.</p> <p>Schemas in aerodb are not optional validation helpers. They are first-class system artifacts that define what data is allowed to exist.</p> <p>If data does not conform to a schema, it does not exist.</p> <p>This document is authoritative. Any implementation that weakens these rules is incorrect.</p>"},{"location":"CORE_SCHEMA/#schema-philosophy","title":"Schema Philosophy","text":"<p>aerodb treats schemas as:</p> <ul> <li>Mandatory</li> <li>Explicit</li> <li>Versioned</li> <li>Immutable once published</li> <li>Enforced at write time</li> <li>Referenced at read time</li> </ul> <p>Schemas are designed to prevent: - Silent data drift - Implicit coercion - Schema chaos over time - Ambiguous reads</p> <p>Flexibility is intentionally sacrificed for correctness.</p>"},{"location":"CORE_SCHEMA/#schema-scope-phase-0","title":"Schema Scope (Phase 0)","text":""},{"location":"CORE_SCHEMA/#supported","title":"Supported","text":"<ul> <li>Per-collection schemas</li> <li>Strict field typing</li> <li>Required vs optional fields</li> <li>Explicit schema versions</li> <li>Full-document validation</li> </ul>"},{"location":"CORE_SCHEMA/#explicitly-not-supported-phase-0","title":"Explicitly Not Supported (Phase 0)","text":"<ul> <li>Schemaless writes</li> <li>Partial schema enforcement</li> <li>Implicit type coercion</li> <li>Schema evolution automation</li> <li>Cross-version reads</li> <li>Field-level migrations</li> <li>Dynamic or computed fields</li> </ul>"},{"location":"CORE_SCHEMA/#schema-identity","title":"Schema Identity","text":"<p>Each schema is uniquely identified by:</p> <ul> <li><code>schema_id</code> (string, globally unique)</li> <li><code>schema_version</code> (monotonic integer or semantic tag)</li> </ul>"},{"location":"CORE_SCHEMA/#example","title":"Example","text":"<pre><code>schema_id: \"users\"\nschema_version: \"v1\"\n</code></pre> <p>The tuple <code>(schema_id, schema_version)</code> uniquely identifies a schema.</p>"},{"location":"CORE_SCHEMA/#schema-storage","title":"Schema Storage","text":"<p>Schemas are stored on disk at:</p> <pre><code>metadata/schemas/schema_&lt;schema_id&gt;_&lt;version&gt;.json\n\n````\n\n### Rules\n- One file per schema version\n- Schema files are immutable once written\n- Deleting or modifying a schema file is forbidden\n- Missing schema files cause startup failure\n\n---\n\n## Schema File Format\n\nSchemas are defined using a **strict JSON-based DSL**.\n\n### Top-Level Structure\n\n```json\n{\n  \"schema_id\": \"users\",\n  \"schema_version\": \"v1\",\n  \"description\": \"User account records\",\n  \"fields\": {\n    \"_id\": {\n      \"type\": \"string\",\n      \"required\": true\n    },\n    \"email\": {\n      \"type\": \"string\",\n      \"required\": true\n    },\n    \"age\": {\n      \"type\": \"int\",\n      \"required\": false\n    }\n  }\n}\n````\n\n---\n\n## Field Definition Rules\n\nEach field definition must specify:\n\n| Property   | Required | Description                   |\n| ---------- | -------- | ----------------------------- |\n| `type`     | Yes      | Field data type               |\n| `required` | Yes      | Whether field must be present |\n\nNo other properties are allowed in Phase 0.\n\n---\n\n## Supported Field Types (Phase 0)\n\n| Type     | Description                                      |\n| -------- | ------------------------------------------------ |\n| `string` | UTF-8 string                                     |\n| `int`    | 64-bit signed integer                            |\n| `bool`   | Boolean                                          |\n| `float`  | 64-bit floating point                            |\n| `object` | Nested object with its own schema                |\n| `array`  | Homogeneous array (single declared element type) |\n\n### Notes\n\n* Arrays must declare a single element type\n* Objects must declare nested field schemas explicitly\n* No union types\n* No polymorphism\n\n---\n\n## Primary Key Rules\n\n### `_id` Field\n\n* Every schema **must** define an `_id` field\n* `_id` must be:\n\n  * Required\n  * Unique within the collection\n  * Immutable after insertion\n\nThe `_id` field is the primary key.\n\n---\n\n## Schema Validation Rules\n\n### Validation Timing\n\n* Validation occurs **before WAL append**\n* Invalid data must never enter WAL or storage\n\n---\n\n### Validation Semantics\n\nA document is valid if and only if:\n\n1. All required fields are present\n2. No undeclared fields exist\n3. Field types exactly match schema types\n4. `_id` is present and valid\n5. Schema version exists and is known\n\nFailure of any rule causes write rejection.\n\n---\n\n## Forbidden Behaviors\n\nThe following are strictly forbidden:\n\n* Missing required fields\n* Extra undeclared fields\n* Implicit type coercion\n* Default values\n* Null values unless explicitly allowed (Phase 0: null forbidden)\n* Partial validation\n\n---\n\n## Schema Versioning Rules\n\n### Immutability\n\nOnce a schema version is created:\n\n* It must never change\n* It must never be overwritten\n* It must never be deleted\n\nAny change requires a **new schema version**.\n\n---\n\n### Creating a New Version\n\nA new schema version must:\n\n* Have a new `schema_version` identifier\n* Be stored as a new schema file\n* Not affect existing documents\n\nNo automatic migration occurs in Phase 0.\n\n---\n\n## Write-Time Schema Binding\n\nEvery write operation must explicitly specify:\n\n* `schema_id`\n* `schema_version`\n\nExample write payload:\n\n```json\n{\n  \"schema_id\": \"users\",\n  \"schema_version\": \"v1\",\n  \"document\": {\n    \"_id\": \"u123\",\n    \"email\": \"user@example.com\",\n    \"age\": 30\n  }\n}\n</code></pre> <p>Writes without explicit schema version are rejected.</p>"},{"location":"CORE_SCHEMA/#read-time-schema-rules","title":"Read-Time Schema Rules","text":"<p>Phase 0 read rules are strict:</p> <ul> <li>Every query must specify exactly one schema version</li> <li>Documents with other schema versions are excluded</li> <li>Cross-version reads are forbidden</li> </ul> <p>This ensures:</p> <ul> <li>Predictable result shapes</li> <li>Deterministic execution</li> <li>No implicit compatibility assumptions</li> </ul>"},{"location":"CORE_SCHEMA/#schema-and-wal-interaction","title":"Schema and WAL Interaction","text":"<ul> <li> <p>WAL records include:</p> </li> <li> <p><code>schema_id</code></p> </li> <li><code>schema_version</code></li> <li>WAL replay validates schema existence</li> <li>Missing schema during recovery causes startup failure</li> </ul> <p>Schemas are part of durability guarantees.</p>"},{"location":"CORE_SCHEMA/#schema-and-index-interaction","title":"Schema and Index Interaction","text":"<ul> <li>Indexes are defined per <code>(schema_id, schema_version)</code></li> <li>Indexes never span multiple schema versions</li> <li>Index rebuild uses schema to validate stored documents</li> </ul>"},{"location":"CORE_SCHEMA/#error-handling","title":"Error Handling","text":""},{"location":"CORE_SCHEMA/#schema-related-errors","title":"Schema-Related Errors","text":"Error Code Condition <code>SCHEMA_REQUIRED</code> No schema specified <code>UNKNOWN_SCHEMA</code> Schema ID not found <code>UNKNOWN_SCHEMA_VERSION</code> Version not found <code>SCHEMA_VALIDATION_FAILED</code> Document violates schema <code>SCHEMA_IMMUTABLE</code> Attempt to modify existing schema <p>All schema errors are fatal to the operation.</p>"},{"location":"CORE_SCHEMA/#invariants-enforced-by-schema-system","title":"Invariants Enforced by Schema System","text":"Invariant Enforcement S1 Schema mandatory on all writes S2 Validation before WAL S3 Explicit version binding S4 Violations abort writes D3 Reads return schema-valid data Q3 No guessing or coercion"},{"location":"CORE_SCHEMA/#phase-0-trade-offs-intentional","title":"Phase 0 Trade-offs (Intentional)","text":"<ul> <li>No automatic migrations</li> <li>No backward compatibility checks</li> <li>No schema evolution tooling</li> <li>No optional fields defaulting</li> <li>No flexible typing</li> </ul> <p>These are deferred by design.</p>"},{"location":"CORE_SCHEMA/#final-statement","title":"Final Statement","text":"<p>Schemas are the contract between data and trust.</p> <p>aerodb does not attempt to infer intent, repair mistakes, or adapt silently.</p> <p>If data does not match the schema, it is rejected.</p> <p>This strictness is not a limitation. It is the foundation of reliability.</p>"},{"location":"CORE_SCOPE/","title":"Architecture","text":""},{"location":"CORE_SCOPE/#purpose","title":"Purpose","text":"<p>This document strictly defines what aerodb will and will not build.</p> <p>Scope control is mandatory. Any feature, optimization, or design that is not explicitly allowed here is considered out of scope and must not be implemented without revising this document.</p> <p>aerodb is infrastructure software. Uncontrolled scope is a reliability risk.</p>"},{"location":"CORE_SCOPE/#scope-philosophy","title":"Scope Philosophy","text":"<p>aerodb intentionally starts small, strict, and predictable.</p> <p>We do not attempt to: - Match feature parity with existing databases - Solve distributed systems problems prematurely - Optimize for novelty or marketing checklists</p> <p>We only build what is required to deliver correctness, determinism, and reliability at a single-node level.</p> <p>Everything else is deferred by design.</p>"},{"location":"CORE_SCOPE/#phase-0-minimum-viable-infrastructure-mvi","title":"Phase 0: Minimum Viable Infrastructure (MVI)","text":"<p>Note on Terminology: \"Phase 0\" and \"Phase 1\" refer to the same foundational phase in AeroDB's development. Current documentation (e.g., PERF_VISION.md) uses \"Phase 1\" terminology. This document preserves the original \"Phase 0\" naming for historical continuity.</p> <p>Phase 0 defines the first production-credible version of aerodb. This is not a demo phase. This is the smallest system that can be trusted.</p>"},{"location":"CORE_SCOPE/#phase-0-goals","title":"Phase 0 Goals","text":"<ul> <li>Deterministic behavior</li> <li>Strong correctness guarantees</li> <li>Crash-safe persistence</li> <li>Clear operational semantics</li> </ul>"},{"location":"CORE_SCOPE/#explicitly-in-scope-phase-0","title":"Explicitly In-Scope (Phase 0)","text":""},{"location":"CORE_SCOPE/#1-deployment-model","title":"1. Deployment Model","text":"<ul> <li>Single-node database engine</li> <li>Local disk persistence</li> <li>Self-hosted operation only</li> </ul> <p>No clustering assumptions are allowed.</p>"},{"location":"CORE_SCOPE/#2-data-model","title":"2. Data Model","text":"<ul> <li>Typed document model</li> <li>Mandatory schema per collection</li> <li>Schema versioning support</li> <li>Strict validation on write</li> </ul> <p>Schemaless writes are forbidden.</p>"},{"location":"CORE_SCOPE/#3-storage-engine","title":"3. Storage Engine","text":"<ul> <li>Append-only Write-Ahead Log (WAL)</li> <li>On-disk storage format with checksums</li> <li>Deterministic crash recovery</li> <li>Explicit fsync boundaries</li> </ul> <p>All acknowledged writes must be durable.</p>"},{"location":"CORE_SCOPE/#4-indexing","title":"4. Indexing","text":"<ul> <li>One index type only (B-tree or equivalent)</li> <li>Explicit index creation and removal</li> <li>Deterministic index selection</li> </ul> <p>Automatic or adaptive indexing is out of scope.</p>"},{"location":"CORE_SCOPE/#5-query-capabilities","title":"5. Query Capabilities","text":"<p>Supported operations: - find - filter (equality + bounded range only) - sort (indexed fields only) - limit</p> <p>No implicit full scans. No hidden query rewrites.</p>"},{"location":"CORE_SCOPE/#6-query-planning","title":"6. Query Planning","text":"<ul> <li>Cost estimation required before execution</li> <li>Deterministic query planner</li> <li>Query rejection if cost cannot be bounded</li> <li>Stable plan generation</li> </ul> <p>Adaptive or heuristic-based planning is forbidden.</p>"},{"location":"CORE_SCOPE/#7-write-operations","title":"7. Write Operations","text":"<ul> <li>Insert</li> <li>Update (by primary key or indexed field)</li> <li>Delete (explicit and bounded)</li> </ul> <p>Bulk writes are allowed only if fully bounded.</p>"},{"location":"CORE_SCOPE/#8-failure-handling","title":"8. Failure Handling","text":"<ul> <li>Explicit error codes</li> <li>Loud failures</li> <li>No silent retries</li> <li>No partial success masking</li> </ul> <p>Failure behavior must be observable and explainable.</p>"},{"location":"CORE_SCOPE/#9-observability","title":"9. Observability","text":"<ul> <li>Structured logs</li> <li>Deterministic error messages</li> <li>Human-readable explain plans</li> <li>Explicit startup and recovery logs</li> </ul> <p>Metrics are secondary to explainability.</p>"},{"location":"CORE_SCOPE/#10-configuration","title":"10. Configuration","text":"<ul> <li>Minimal configuration surface</li> <li>Safe defaults only</li> <li>Explicit limits for memory and disk usage</li> </ul> <p>Hidden tuning knobs are forbidden.</p>"},{"location":"CORE_SCOPE/#explicitly-out-of-scope-phase-0","title":"Explicitly Out of Scope (Phase 0)","text":"<p>The following are not allowed, regardless of perceived usefulness:</p>"},{"location":"CORE_SCOPE/#architecture-scaling","title":"Architecture &amp; Scaling","text":"<ul> <li>Sharding</li> <li>Replication</li> <li>Clustering</li> <li>Leader election</li> <li>Multi-node coordination</li> <li>Multi-region deployments</li> </ul>"},{"location":"CORE_SCOPE/#performance-features","title":"Performance Features","text":"<ul> <li>Adaptive query optimization</li> <li>Automatic index creation</li> <li>Background query rewriting</li> <li>Speculative execution</li> </ul>"},{"location":"CORE_SCOPE/#data-query-features","title":"Data &amp; Query Features","text":"<ul> <li>Joins</li> <li>Aggregation pipelines</li> <li>Map-reduce</li> <li>Full-text search</li> <li>Geospatial queries</li> <li>Vector search</li> <li>Time-series optimizations</li> </ul>"},{"location":"CORE_SCOPE/#transactions","title":"Transactions","text":"<ul> <li>Multi-document transactions</li> <li>Cross-collection transactions</li> <li>Distributed transactions</li> </ul> <p>Single-document atomicity only.</p>"},{"location":"CORE_SCOPE/#operational-features","title":"Operational Features","text":"<ul> <li>Auto-scaling</li> <li>Serverless execution</li> <li>Managed service assumptions</li> <li>Built-in UI dashboards</li> </ul>"},{"location":"CORE_SCOPE/#developer-convenience","title":"Developer Convenience","text":"<ul> <li>Schemaless modes</li> <li>Implicit coercion</li> <li>\u201cBest effort\u201d writes</li> <li>Magic defaults</li> <li>Silent fallbacks</li> </ul>"},{"location":"CORE_SCOPE/#completed-phases","title":"Completed Phases","text":""},{"location":"CORE_SCOPE/#phase-1-core-storage-correctness","title":"Phase 1: Core Storage &amp; Correctness","text":"<ul> <li>Single-node WAL-backed persistence</li> <li>Deterministic query planning</li> <li>Crash-safe recovery</li> <li>Bounded query execution</li> <li>Status: Frozen</li> </ul>"},{"location":"CORE_SCOPE/#phase-2a-mvcc-multi-version-concurrency-control","title":"Phase 2A: MVCC (Multi-Version Concurrency Control)","text":"<ul> <li>Snapshot isolation</li> <li>CommitId authority model</li> <li>Version chain management</li> <li>Deterministic visibility rules</li> <li>Status: Frozen</li> </ul>"},{"location":"CORE_SCOPE/#phase-2b-replication","title":"Phase 2B: Replication","text":"<ul> <li>Single-writer replication model</li> <li>WAL shipping semantics</li> <li>Snapshot transfer</li> <li>Replica read rules</li> <li>Fail-stop semantics</li> <li>Status: Frozen</li> </ul>"},{"location":"CORE_SCOPE/#phase-3-performance-optimizations-current","title":"Phase 3: Performance Optimizations (Current)","text":"<ul> <li>Group Commit (PERF-01)</li> <li>WAL Batching (PERF-02)</li> <li>Read Path Optimization (PERF-03)</li> <li>Index Acceleration (PERF-04)</li> <li>Checkpoint Pipelining (PERF-05)</li> <li>Replica Read Fast Path (PERF-06)</li> <li>Memory Layout Optimization (PERF-07)</li> <li>Status: Implementation complete, correctness-preserving only</li> </ul>"},{"location":"CORE_SCOPE/#future-considerations-post-phase-3","title":"Future Considerations (Post-Phase 3)","text":"<p>The following may be considered after Phase 3 stabilizes:</p> <ul> <li>Multi-document transactions</li> <li>Backup and restore tooling enhancements</li> <li>Schema migration automation</li> <li>Additional secondary index types</li> <li>CLI and admin tooling improvements</li> <li>Cross-shard operations (if sharding becomes in-scope)</li> </ul> <p>These are explicitly deferred.</p>"},{"location":"CORE_SCOPE/#scope-enforcement-rules","title":"Scope Enforcement Rules","text":"<ul> <li>Any feature not listed as \u201cIn-Scope\u201d is forbidden.</li> <li>Any proposal to expand scope must:</li> <li>Clearly state the problem</li> <li>Demonstrate no violation of VISION.md</li> <li>Show no impact on determinism or reliability</li> <li>Explicitly update this document</li> </ul> <p>If these conditions are not met, the proposal is rejected.</p>"},{"location":"CORE_SCOPE/#final-statement","title":"Final Statement","text":"<p>aerodb does not win by doing more. It wins by doing less, correctly, predictably, and transparently.</p> <p>Scope discipline is a core feature.</p>"},{"location":"CORE_SNAPSHOT/","title":"SNAPSHOT.md \u2014 AeroDB Storage Snapshot Specification (Phase 1)","text":"<p>This document defines the authoritative snapshot format and semantics for AeroDB Phase 1.</p> <p>Snapshots provide a point-in-time, durable copy of database state used for:</p> <ul> <li>checkpointing</li> <li>backups</li> <li>restore</li> <li>accelerated recovery</li> </ul> <p>If implementation behavior conflicts with this document, the implementation is wrong.</p> <p>Snapshots are designed for correctness, not speed.</p>"},{"location":"CORE_SNAPSHOT/#1-principles","title":"1. Principles","text":"<p>Snapshots must obey:</p> <ul> <li>Deterministic creation</li> <li>Atomic visibility</li> <li>Full durability</li> <li>Explicit integrity verification</li> <li>Zero partial success</li> </ul> <p>Snapshots capture:</p> <ul> <li>document storage</li> <li>schema metadata</li> <li>manifest</li> </ul> <p>Indexes are NOT included.</p> <p>Indexes are always rebuilt.</p>"},{"location":"CORE_SNAPSHOT/#2-snapshot-directory-layout","title":"2. Snapshot Directory Layout","text":"<p>Snapshots live under:</p> <pre><code>&lt;data_dir&gt;/snapshots/&lt;snapshot_id&gt;/\n</code></pre> <p>Where:</p> <pre><code>snapshot_id = UTC timestamp in RFC3339 basic format\n</code></pre> <p>Example:</p> <pre><code>20260204T113000Z\n</code></pre>"},{"location":"CORE_SNAPSHOT/#required-files","title":"Required Files","text":"<pre><code>snapshots/&lt;snapshot_id&gt;/\n\u251c\u2500\u2500 storage.dat\n\u251c\u2500\u2500 schemas/\n\u2502   \u2514\u2500\u2500 *.json\n\u2514\u2500\u2500 manifest.json\n</code></pre>"},{"location":"CORE_SNAPSHOT/#3-snapshot-contents","title":"3. Snapshot Contents","text":""},{"location":"CORE_SNAPSHOT/#31-storagedat","title":"3.1 storage.dat","text":"<p>Binary copy of document storage file.</p> <p>Rules:</p> <ul> <li>byte-for-byte copy</li> <li>fsync before manifest creation</li> <li>immutable after creation</li> </ul>"},{"location":"CORE_SNAPSHOT/#32-schemas","title":"3.2 schemas/","text":"<p>Exact copy of:</p> <p><pre><code>&lt;data_dir&gt;/metadata/schemas/\n\n````\n\nRules:\n\n- copied recursively\n- filenames preserved\n- fsync directory\n\n---\n\n### 3.3 manifest.json\n\nAuthoritative snapshot descriptor.\n\nExample:\n\n```json\n{\n  \"snapshot_id\": \"20260204T113000Z\",\n  \"created_at\": \"2026-02-04T11:30:00Z\",\n  \"storage_checksum\": \"crc32:deadbeef\",\n  \"schema_checksums\": {\n    \"user_v1.json\": \"crc32:abcd1234\"\n  },\n  \"format_version\": 1\n}\n````\n\n---\n\n## 4. Snapshot Creation Algorithm\n\nSnapshot creation must follow this exact sequence:\n\n1. Pause writes (acquire global execution lock)\n2. fsync WAL\n3. Copy storage.dat \u2192 snapshot/storage.dat\n4. fsync snapshot/storage.dat\n5. Copy schemas \u2192 snapshot/schemas/\n6. fsync snapshot/schemas directory\n7. Generate manifest.json\n8. fsync manifest.json\n9. fsync snapshot directory\n10. Release global lock\n\nAny failure aborts snapshot.\n\nPartial snapshots are deleted.\n\n---\n\n## 5. Atomic Visibility\n\nSnapshots become visible only after:\n\n* manifest.json written\n* snapshot directory fsynced\n\nIncomplete directories must be ignored on startup.\n\n---\n\n## 6. Integrity Verification\n\nEvery snapshot includes:\n\n* CRC32 of storage.dat\n* CRC32 of every schema file\n\nDuring restore or recovery:\n\n* all checksums verified\n* any mismatch \u2192 FATAL\n\nNo auto-repair.\n\n---\n\n## 7. Snapshot Immutability\n\nOnce created:\n\n* snapshot files are read-only\n* never modified\n* never appended\n\nNew snapshots always create new directories.\n\n---\n\n## 8. Snapshot Discovery\n\nOn startup:\n</code></pre> /snapshots/ ``` <p>is scanned.</p> <p>Valid snapshots:</p> <ul> <li>must contain manifest.json</li> <li>must pass checksum verification</li> </ul> <p>Newest valid snapshot is selected.</p> <p>Others remain untouched.</p>"},{"location":"CORE_SNAPSHOT/#9-corruption-policy","title":"9. Corruption Policy","text":"<p>If snapshot corruption detected:</p> <ul> <li>snapshot ignored</li> <li>previous snapshot attempted</li> <li>if none valid \u2192 fallback to WAL-only recovery</li> </ul> <p>All corruption events logged.</p>"},{"location":"CORE_SNAPSHOT/#10-phase-1-limitations","title":"10. Phase-1 Limitations","text":"<p>Snapshots do NOT include:</p> <ul> <li>indexes</li> <li>WAL tail</li> <li>runtime state</li> </ul> <p>Those are reconstructed.</p>"},{"location":"CORE_SNAPSHOT/#11-determinism-guarantees","title":"11. Determinism Guarantees","text":"<p>Given identical:</p> <ul> <li>snapshot directory</li> <li>WAL tail</li> <li>schemas</li> </ul> <p>AeroDB must recover to identical state.</p>"},{"location":"CORE_SNAPSHOT/#12-authority","title":"12. Authority","text":"<p>This document governs:</p> <ul> <li>snapshot creation</li> <li>snapshot format</li> <li>checkpointing input</li> <li>backup input</li> <li>restore input</li> </ul> <p>Violations are correctness bugs.</p>"},{"location":"CORE_STORAGE/","title":"aerodb \u2014 Storage Engine Layout (Phase 0)","text":""},{"location":"CORE_STORAGE/#1-design-goals","title":"1. Design Goals","text":"<p>The storage engine exists to provide:</p> <ul> <li>Durable persistence (WAL-backed)</li> <li>Deterministic recovery</li> <li>Schema-valid data only</li> <li>Corruption detection, not concealment</li> <li>Simplicity over cleverness</li> </ul> <p>It explicitly does not optimize for:</p> <ul> <li>Space efficiency</li> <li>Write amplification reduction</li> <li>Fast recovery</li> <li>Concurrent access</li> </ul> <p>Those are deferred.</p>"},{"location":"CORE_STORAGE/#2-on-disk-directory-layout","title":"2. On-Disk Directory Layout","text":"<p>Single database instance = single directory.</p> <pre><code>data_dir/\n\u251c\u2500\u2500 MANIFEST\n\u251c\u2500\u2500 LOCK\n\u251c\u2500\u2500 wal/\n\u2502   \u2514\u2500\u2500 wal.log\n\u251c\u2500\u2500 data/\n\u2502   \u2514\u2500\u2500 documents.dat\n\u251c\u2500\u2500 indexes/\n\u2502   \u2514\u2500\u2500 (empty at rest; rebuilt on startup)\n\u2514\u2500\u2500 metadata/\n    \u251c\u2500\u2500 schemas/\n    \u2502   \u2514\u2500\u2500 schema_&lt;id&gt;.json\n    \u2514\u2500\u2500 state.json\n</code></pre>"},{"location":"CORE_STORAGE/#key-rules","title":"Key Rules","text":"<ul> <li>No hidden files</li> <li>No background compaction</li> <li>Indexes are NOT persisted</li> <li>Only WAL + document storage are authoritative</li> </ul>"},{"location":"CORE_STORAGE/#3-manifest-file","title":"3. MANIFEST File","text":""},{"location":"CORE_STORAGE/#purpose","title":"Purpose","text":"<p>Establishes identity and compatibility.</p>"},{"location":"CORE_STORAGE/#contents","title":"Contents","text":"<ul> <li>Database UUID</li> <li>aerodb version</li> <li>Storage format version</li> <li>Creation timestamp</li> </ul>"},{"location":"CORE_STORAGE/#rules","title":"Rules","text":"<ul> <li>Written once at init</li> <li>Immutable</li> <li>Read at every startup</li> <li>Version mismatch = startup failure</li> </ul>"},{"location":"CORE_STORAGE/#4-lock-file","title":"4. LOCK File","text":""},{"location":"CORE_STORAGE/#purpose_1","title":"Purpose","text":"<p>Prevent multiple processes from opening the same data directory.</p>"},{"location":"CORE_STORAGE/#rules_1","title":"Rules","text":"<ul> <li>Acquired exclusively on startup</li> <li>Released only on clean shutdown</li> <li>If lock exists \u2192 startup fails</li> </ul> <p>No \u201cforce unlock\u201d. Operator intervention required.</p>"},{"location":"CORE_STORAGE/#5-write-ahead-log-wal","title":"5. Write-Ahead Log (WAL)","text":""},{"location":"CORE_STORAGE/#location","title":"Location","text":"<pre><code>wal/wal.log\n</code></pre>"},{"location":"CORE_STORAGE/#role","title":"Role","text":"<p>Single source of truth for durability.</p> <p>Every acknowledged write MUST appear here first.</p>"},{"location":"CORE_STORAGE/#51-wal-record-structure","title":"5.1 WAL Record Structure","text":"<p>Each WAL record is append-only and self-describing.</p> <pre><code>+------------------+\n| Record Length    |  (u32)\n+------------------+\n| Record Type      |  (u8)\n+------------------+\n| Sequence Number  |  (u64)\n+------------------+\n| Payload          |  (variable)\n+------------------+\n| Checksum         |  (u32)\n+------------------+\n</code></pre>"},{"location":"CORE_STORAGE/#record-types","title":"Record Types","text":"<ul> <li><code>INSERT</code></li> <li><code>UPDATE</code></li> <li><code>DELETE</code></li> </ul> <p>No schema changes in Phase 0.</p>"},{"location":"CORE_STORAGE/#52-wal-payload","title":"5.2 WAL Payload","text":"<p>Payload contains:</p> <ul> <li>Collection identifier</li> <li>Document primary key</li> <li>Full document body (post-update)</li> <li>Schema version ID</li> </ul> <p>Rule: WAL always logs full document state, not deltas.</p> <p>Reason:</p> <ul> <li>Simpler recovery</li> <li>Deterministic replay</li> <li>No dependency on previous state</li> </ul>"},{"location":"CORE_STORAGE/#53-wal-durability-rules","title":"5.3 WAL Durability Rules","text":"<ul> <li>WAL append \u2192 <code>fsync</code> \u2192 only then acknowledge</li> <li>No batching</li> <li>No group commit</li> <li>No async writes</li> </ul> <p>Violating this breaks <code>D1</code> and is forbidden.</p>"},{"location":"CORE_STORAGE/#6-document-storage-documentsdat","title":"6. Document Storage (<code>documents.dat</code>)","text":""},{"location":"CORE_STORAGE/#role_1","title":"Role","text":"<p>Holds the canonical persistent state of all documents.</p> <p>Indexes derive from this.</p>"},{"location":"CORE_STORAGE/#61-storage-model","title":"6.1 Storage Model","text":"<p>Append-only record file.</p> <p>No in-place updates.</p> <pre><code>documents.dat:\n[ Record ][ Record ][ Record ] ...\n</code></pre> <p>Each record represents the latest version of a document.</p>"},{"location":"CORE_STORAGE/#62-document-record-format","title":"6.2 Document Record Format","text":"<pre><code>+------------------+\n| Record Length    | (u32)\n+------------------+\n| Document ID      | (fixed / variable)\n+------------------+\n| Schema Version   | (u32 or UUID)\n+------------------+\n| Tombstone Flag   | (u8)\n+------------------+\n| Document Payload | (binary / JSON)\n+------------------+\n| Checksum         | (u32)\n+------------------+\n</code></pre>"},{"location":"CORE_STORAGE/#tombstone-rules","title":"Tombstone Rules","text":"<ul> <li>Deletes write a tombstone record</li> <li>Deleted documents remain in storage</li> <li>Compaction is out of scope for Phase 0</li> </ul>"},{"location":"CORE_STORAGE/#63-write-rules","title":"6.3 Write Rules","text":"<ul> <li>Document record is written after WAL fsync</li> <li> <p>Storage write failure after WAL fsync:</p> </li> <li> <p>Startup recovery will reapply WAL</p> </li> <li>Operation must not be acknowledged unless storage write completes</li> </ul>"},{"location":"CORE_STORAGE/#64-read-rules","title":"6.4 Read Rules","text":"<ul> <li>Reads scan via index (not storage)</li> <li> <p>Storage is accessed only by:</p> </li> <li> <p>Primary key lookup</p> </li> <li>Recovery</li> <li>Index rebuild</li> </ul> <p>Every read validates checksum.</p>"},{"location":"CORE_STORAGE/#7-index-storage-strategy","title":"7. Index Storage Strategy","text":""},{"location":"CORE_STORAGE/#phase-0-rule","title":"Phase 0 Rule","text":"<p>Indexes are not persisted.</p>"},{"location":"CORE_STORAGE/#71-index-lifecycle","title":"7.1 Index Lifecycle","text":"<ul> <li>Indexes exist only in memory</li> <li>Built at startup by scanning <code>documents.dat</code></li> <li>Updated during normal operation</li> <li>Rebuilt fully during recovery</li> </ul>"},{"location":"CORE_STORAGE/#72-rationale","title":"7.2 Rationale","text":"<ul> <li>WAL stays simple</li> <li>No dual-write atomicity problems</li> <li>Deterministic recovery</li> <li>Index corruption cannot corrupt data</li> </ul> <p>Trade-off: slower startup. Accepted.</p>"},{"location":"CORE_STORAGE/#8-schema-storage","title":"8. Schema Storage","text":""},{"location":"CORE_STORAGE/#location_1","title":"Location","text":"<pre><code>metadata/schemas/schema_&lt;id&gt;.json\n</code></pre>"},{"location":"CORE_STORAGE/#rules_2","title":"Rules","text":"<ul> <li>One file per schema version</li> <li>Immutable once written</li> <li>Referenced by schema version ID in documents and WAL</li> </ul> <p>If a schema file is missing or corrupted \u2192 startup fails.</p>"},{"location":"CORE_STORAGE/#9-metadata-state-statejson","title":"9. Metadata State (<code>state.json</code>)","text":""},{"location":"CORE_STORAGE/#purpose_2","title":"Purpose","text":"<p>Track minimal runtime metadata.</p> <p>Contents:</p> <ul> <li>Last clean shutdown marker</li> <li>Last WAL sequence number written</li> <li>Engine state flags</li> </ul>"},{"location":"CORE_STORAGE/#rules_3","title":"Rules","text":"<ul> <li>Written only on clean shutdown</li> <li>Never trusted alone</li> <li>WAL + storage are authoritative</li> </ul>"},{"location":"CORE_STORAGE/#10-crash-recovery-interaction","title":"10. Crash Recovery Interaction","text":""},{"location":"CORE_STORAGE/#recovery-reads","title":"Recovery Reads","text":"<ul> <li><code>MANIFEST</code></li> <li><code>state.json</code></li> <li>Entire <code>wal.log</code></li> <li>Entire <code>documents.dat</code></li> </ul>"},{"location":"CORE_STORAGE/#recovery-writes","title":"Recovery Writes","text":"<ul> <li>Rewrites <code>documents.dat</code> state logically</li> <li>Rebuilds all indexes</li> <li>Writes clean shutdown marker only at successful end</li> </ul>"},{"location":"CORE_STORAGE/#11-corruption-handling","title":"11. Corruption Handling","text":""},{"location":"CORE_STORAGE/#wal-corruption","title":"WAL Corruption","text":"<ul> <li>Any checksum failure \u2192 startup abort</li> <li>No partial replay</li> </ul>"},{"location":"CORE_STORAGE/#storage-corruption","title":"Storage Corruption","text":"<ul> <li>Any checksum failure on read \u2192 operation abort</li> <li>During recovery \u2192 startup abort</li> </ul> <p>Downtime &gt; silent corruption</p>"},{"location":"CORE_STORAGE/#12-what-is-explicitly-not-implemented-phase-0","title":"12. What Is Explicitly Not Implemented (Phase 0)","text":"<ul> <li>Compaction</li> <li>Garbage collection</li> <li>WAL truncation</li> <li>Checkpointing</li> <li>Page cache</li> <li>Compression</li> <li>Encryption-at-rest</li> <li>Partial document updates</li> </ul> <p>All intentionally excluded.</p>"},{"location":"CORE_STORAGE/#13-invariant-mapping","title":"13. Invariant Mapping","text":"Invariant Enforced By D1 WAL fsync before ack D2 Checksums everywhere D3 Schema + checksum validation R1 WAL-first writes R2 Sequential replay R3 Explicit recovery outcome C1 Full-document writes K1 Checksums K2 Halt-on-corruption"},{"location":"CORE_STORAGE/#14-summary","title":"14. Summary","text":"<p>The aerodb storage engine is:</p> <ul> <li>Append-only</li> <li>WAL-driven</li> <li>Checksum-verified</li> <li>Index-as-derived-state</li> <li>Deterministic to the bone</li> </ul> <p>It is boring by design.</p> <p>And boring storage engines are the ones that survive.</p>"},{"location":"CORE_VISION/","title":"Vision & Philosophy","text":""},{"location":"CORE_VISION/#aerodb-project-vision","title":"aerodb \u2014 Project Vision","text":"<p>aerodb is a production-grade database system designed to outperform MongoDB in correctness, predictability, and operational clarity, while meeting the reliability expectations associated with platforms like PostgreSQL.</p> <p>aerodb is infrastructure software.</p> <p>It is not a demo, not a prototype, and not an experimental toy. It is built for real production systems, real operational failures, and real long-term responsibility.</p> <p>The project is backed by :contentReference[oaicite:2]{index=2} and is treated as institutional infrastructure from its first release.</p>"},{"location":"CORE_VISION/#one-sentence-goal","title":"One-Sentence Goal","text":"<p>Build a strict, deterministic, self-hostable database that engineers can trust in production without surprises.</p>"},{"location":"CORE_VISION/#core-belief","title":"Core Belief","text":"<p>Databases rarely fail because they are slow. They fail because they are unpredictable, permissive in unsafe ways, and opaque when something goes wrong.</p> <p>aerodb exists to eliminate those failure modes.</p> <p>We deliberately choose: - Trust over flexibility - Predictability over cleverness - Correctness over convenience - Explicit behavior over implicit magic - Long-term operability over short-term adoption</p>"},{"location":"CORE_VISION/#the-problem-we-are-solving","title":"The Problem We Are Solving","text":"<p>Modern databases commonly allow: - Schemas to be optional or weakly enforced - Queries with unbounded or poorly understood cost - Performance characteristics that change unexpectedly - Failures that are silent, delayed, or difficult to explain</p> <p>These properties may be acceptable for rapid prototyping. They are unacceptable for production infrastructure.</p> <p>aerodb addresses this by enforcing strict, explicit contracts at every layer of the system.</p>"},{"location":"CORE_VISION/#non-negotiable-principles","title":"Non-Negotiable Principles","text":"<p>The following principles are absolute. If a design decision or feature conflicts with any of them, it is rejected.</p>"},{"location":"CORE_VISION/#1-determinism-is-mandatory","title":"1. Determinism Is Mandatory","text":"<ul> <li>The same query, schema, and data must always produce the same execution plan.</li> <li>Planner behavior must not change implicitly over time.</li> <li>Any change in planning behavior must be explicit and opt-in.</li> </ul>"},{"location":"CORE_VISION/#2-schemas-are-required-and-first-class","title":"2. Schemas Are Required and First-Class","text":"<ul> <li>All data is written against an explicit schema.</li> <li>Schemas are versioned, auditable, and treated as system artifacts.</li> <li>Schemaless or partially validated writes are forbidden.</li> </ul>"},{"location":"CORE_VISION/#3-unsafe-operations-are-rejected","title":"3. Unsafe Operations Are Rejected","text":"<ul> <li>Queries with unbounded, non-estimable, or dangerous cost are rejected before execution.</li> <li>The system must fail fast rather than degrade silently.</li> <li>Guessing user intent or \u201cdoing something reasonable\u201d is forbidden.</li> </ul>"},{"location":"CORE_VISION/#4-reliability-is-sacred","title":"4. Reliability Is Sacred","text":"<ul> <li>No acknowledged write may ever be lost.</li> <li>All durability guarantees are WAL-backed.</li> <li>Crash recovery must be deterministic and verifiable.</li> <li>Data corruption is treated as a critical failure, not an edge case.</li> </ul>"},{"location":"CORE_VISION/#5-explicitness-over-magic","title":"5. Explicitness Over Magic","text":"<ul> <li>All system behavior must be explainable.</li> <li>There are no hidden retries, silent fallbacks, or implicit coercions.</li> <li>Defaults must be safe, boring, and clearly documented.</li> </ul>"},{"location":"CORE_VISION/#6-self-hosting-is-first-class","title":"6. Self-Hosting Is First-Class","text":"<ul> <li>aerodb must run reliably without any managed cloud dependency.</li> <li>Local, on-prem, and production deployments must share identical semantics.</li> <li>Cloud deployment is optional and must not change system behavior.</li> </ul>"},{"location":"CORE_VISION/#what-aerodb-explicitly-is-not","title":"What aerodb Explicitly Is Not","text":"<p>To prevent ambiguity and scope creep, aerodb explicitly rejects the following:</p> <ul> <li>It is not a schemaless database.</li> <li>It is not a serverless or auto-scaling magic platform.</li> <li>It is not optimized for convenience at the cost of safety.</li> <li>It is not a MongoDB clone with cosmetic differences.</li> <li>It is not a feature playground.</li> </ul> <p>Any feature whose primary purpose is increasing adoption at the cost of predictability or correctness does not belong in aerodb.</p>"},{"location":"CORE_VISION/#target-users","title":"Target Users","text":"<p>aerodb is built for: - Backend and infrastructure engineers - Teams operating long-lived production systems - Organizations that self-host or require strict control - Engineers who have been burned by unpredictable database behavior</p> <p>It is not optimized for beginners, tutorials, or casual experimentation.</p>"},{"location":"CORE_VISION/#definition-of-success","title":"Definition of Success","text":"<p>aerodb is successful only if:</p> <ul> <li>Engineers trust it with critical production data.</li> <li>Query and write behavior remains predictable under load.</li> <li>Failures are explicit, understandable, and actionable.</li> <li>Upgrades do not introduce silent behavioral changes.</li> <li>The system remains operable without deep tribal knowledge.</li> </ul> <p>Popularity without trust is not success.</p>"},{"location":"CORE_VISION/#institutional-responsibility","title":"Institutional Responsibility","text":"<p>Because aerodb is backed by Tonmoy Infrastructure &amp; Vision:</p> <ul> <li>Long-term maintenance is assumed.</li> <li>Backward compatibility rules are enforced.</li> <li>Breaking changes require explicit justification.</li> <li>Reliability claims must be defensible and measurable.</li> </ul> <p>aerodb carries a name and responsibility. It must behave accordingly.</p>"},{"location":"CORE_VISION/#final-statement","title":"Final Statement","text":"<p>aerodb is built with the understanding that engineers will stake their systems, their businesses, and their reputations on it.</p> <p>We do not optimize for novelty. We do not optimize for hype. We optimize for trust earned through discipline.</p> <p>Anything less is unacceptable.</p>"},{"location":"CORE_WAL/","title":"Write-Ahead Log","text":""},{"location":"CORE_WAL/#purpose","title":"Purpose","text":"<p>This document defines the Write-Ahead Log (WAL) design for aerodb.</p> <p>The WAL is the authoritative durability mechanism in Phase 0. No acknowledged write exists unless it is fully persisted in the WAL.</p> <p>This document is binding. Any implementation that violates these rules is incorrect.</p>"},{"location":"CORE_WAL/#wal-design-principles","title":"WAL Design Principles","text":"<p>The WAL in aerodb prioritizes:</p> <ul> <li>Durability over throughput</li> <li>Determinism over optimization</li> <li>Simplicity over cleverness</li> <li>Explicit failure over silent recovery</li> </ul> <p>The WAL is intentionally conservative. Phase 0 does not attempt to optimize write performance.</p>"},{"location":"CORE_WAL/#authoritative-role-of-the-wal","title":"Authoritative Role of the WAL","text":"<p>The WAL is:</p> <ul> <li>The single source of truth for crash recovery</li> <li>Required for every acknowledged write</li> <li>Fully replayed on every startup in Phase 0</li> </ul> <p>The WAL is never bypassed.</p>"},{"location":"CORE_WAL/#wal-scope-phase-0","title":"WAL Scope (Phase 0)","text":""},{"location":"CORE_WAL/#included-in-wal","title":"Included in WAL","text":"<ul> <li>Document INSERT operations</li> <li>Document UPDATE operations</li> <li>Document DELETE operations</li> <li>Schema version reference per document</li> <li>Operation sequence number</li> </ul>"},{"location":"CORE_WAL/#explicitly-excluded-from-wal","title":"Explicitly Excluded from WAL","text":"<ul> <li>Index mutations</li> <li>Schema creation or migration</li> <li>Configuration changes</li> <li>Checkpoints</li> <li>Metadata updates</li> </ul> <p>Indexes are derived state and are rebuilt from storage.</p>"},{"location":"CORE_WAL/#wal-file-layout","title":"WAL File Layout","text":"<pre><code>data_dir/\n\u2514\u2500\u2500 wal/\n\u2514\u2500\u2500 wal.log\n</code></pre>"},{"location":"CORE_WAL/#file-properties","title":"File Properties","text":"<ul> <li>Append-only</li> <li>Single file</li> <li>Never truncated in Phase 0</li> <li>Opened with exclusive write access</li> </ul>"},{"location":"CORE_WAL/#wal-record-ordering","title":"WAL Record Ordering","text":"<ul> <li>WAL records are strictly ordered by a monotonically increasing sequence number</li> <li>Sequence numbers start at <code>1</code></li> <li>Sequence numbers never repeat or rewind</li> </ul> <p>Sequence numbers define the total order of writes.</p>"},{"location":"CORE_WAL/#wal-record-structure","title":"WAL Record Structure","text":"<p>Each WAL record is self-contained and self-describing.</p> <pre><code>+------------------------+\n| Record Length (u32)    |\n+------------------------+\n| Record Type (u8)       |\n+------------------------+\n| Sequence Number (u64)  |\n+------------------------+\n| Payload (variable)     |\n+------------------------+\n| Checksum (u32)         |\n+------------------------+\n</code></pre>"},{"location":"CORE_WAL/#field-definitions","title":"Field Definitions","text":"Field Description Record Length Total byte length of the record Record Type INSERT / UPDATE / DELETE Sequence Number Global monotonic operation ID Payload Operation-specific data Checksum CRC32 or equivalent over entire record except checksum"},{"location":"CORE_WAL/#wal-payload-format","title":"WAL Payload Format","text":""},{"location":"CORE_WAL/#common-payload-fields","title":"Common Payload Fields","text":"<p>Every WAL payload MUST include:</p> <ul> <li>Collection identifier</li> <li>Document primary key</li> <li>Schema version identifier</li> <li>Full document body (post-operation state)</li> </ul>"},{"location":"CORE_WAL/#payload-rules","title":"Payload Rules","text":"<ul> <li>WAL records always store the full document state</li> <li>No delta encoding</li> <li>No partial updates</li> <li>Deletes are represented as tombstone records</li> </ul> <p>This guarantees deterministic replay.</p>"},{"location":"CORE_WAL/#wal-record-types","title":"WAL Record Types","text":""},{"location":"CORE_WAL/#insert","title":"INSERT","text":"<p>Represents insertion of a new document.</p> <p>Rules: - Document must fully conform to schema - Full document body stored in payload</p>"},{"location":"CORE_WAL/#update","title":"UPDATE","text":"<p>Represents replacement of an existing document.</p> <p>Rules: - WAL stores the entire new document - Partial updates are forbidden - Schema version must be explicit</p>"},{"location":"CORE_WAL/#delete","title":"DELETE","text":"<p>Represents deletion of a document.</p> <p>Rules: - WAL stores a tombstone payload - Document primary key remains referenced - Schema version included for validation</p>"},{"location":"CORE_WAL/#write-rules-critical","title":"Write Rules (Critical)","text":""},{"location":"CORE_WAL/#wal-write-sequence","title":"WAL Write Sequence","text":"<p>For every write operation:</p> <ol> <li>Construct WAL record</li> <li>Append record to <code>wal.log</code></li> <li>Flush WAL to disk using <code>fsync</code></li> <li>Only after fsync may the operation proceed</li> <li>Only after storage write completes may the operation be acknowledged</li> </ol> <p>Acknowledgment before fsync is forbidden.</p>"},{"location":"CORE_WAL/#fsync-policy-phase-0","title":"fsync Policy (Phase 0)","text":"<ul> <li>Every WAL append is followed by <code>fsync</code></li> <li>No batching</li> <li>No group commit</li> <li>No async durability</li> </ul> <p>This is intentional.</p>"},{"location":"CORE_WAL/#wal-integrity-guarantees","title":"WAL Integrity Guarantees","text":""},{"location":"CORE_WAL/#checksum-enforcement","title":"Checksum Enforcement","text":"<ul> <li>Every WAL record includes a checksum</li> <li>Checksum covers:</li> <li>Record header</li> <li>Payload</li> <li>Sequence number</li> </ul> <p>Any checksum mismatch is corruption.</p>"},{"location":"CORE_WAL/#wal-corruption-policy","title":"WAL Corruption Policy","text":""},{"location":"CORE_WAL/#phase-0-rule-zero-tolerance","title":"Phase 0 Rule: Zero Tolerance","text":"<p>If any WAL corruption is detected:</p> <ul> <li>Startup halts immediately</li> <li>No partial replay</li> <li>No skipping records</li> <li>No repair attempts</li> </ul> <p>The database refuses to start.</p> <p>This is mandatory.</p>"},{"location":"CORE_WAL/#wal-replay-rules","title":"WAL Replay Rules","text":""},{"location":"CORE_WAL/#replay-order","title":"Replay Order","text":"<ul> <li>WAL records are replayed strictly in sequence number order</li> <li>Replay always starts from the first record</li> <li>Replay is single-threaded</li> </ul>"},{"location":"CORE_WAL/#replay-behavior","title":"Replay Behavior","text":"<p>For each WAL record:</p> <ol> <li>Validate checksum</li> <li>Validate record structure</li> <li>Validate schema version existence</li> <li>Apply document state to document storage</li> <li>If record is DELETE, write tombstone</li> </ol> <p>If any step fails \u2192 recovery halts.</p>"},{"location":"CORE_WAL/#wal-and-idempotency","title":"WAL and Idempotency","text":""},{"location":"CORE_WAL/#replay-idempotency-rule","title":"Replay Idempotency Rule","text":"<p>Applying the same WAL record twice must result in the same final state.</p> <p>This is achieved by: - Full-document replacement - Primary-key-based overwrite semantics</p> <p>No record may depend on previous application state.</p>"},{"location":"CORE_WAL/#wal-and-document-storage-interaction","title":"WAL and Document Storage Interaction","text":"<ul> <li>WAL durability precedes storage mutation</li> <li>Storage writes are considered secondary</li> <li>On crash:</li> <li>WAL is authoritative</li> <li>Storage is reconciled to WAL state</li> </ul> <p>Indexes are rebuilt after replay completes.</p>"},{"location":"CORE_WAL/#wal-and-recovery-determinism","title":"WAL and Recovery Determinism","text":"<p>Recovery must be:</p> <ul> <li>Deterministic</li> <li>Repeatable</li> <li>Independent of timing or environment</li> </ul> <p>Given the same WAL file, recovery must always produce the same storage state.</p>"},{"location":"CORE_WAL/#wal-growth-policy-phase-0","title":"WAL Growth Policy (Phase 0)","text":""},{"location":"CORE_WAL/#phase-0-rule","title":"Phase 0 Rule","text":"<ul> <li>WAL grows without bound</li> <li>WAL is never truncated</li> <li>WAL is never compacted</li> </ul> <p>This is a conscious trade-off.</p>"},{"location":"CORE_WAL/#wal-and-clean-shutdown","title":"WAL and Clean Shutdown","text":""},{"location":"CORE_WAL/#clean-shutdown-marker","title":"Clean Shutdown Marker","text":"<ul> <li>On clean shutdown, aerodb writes a shutdown marker to metadata</li> <li>WAL contents remain unchanged</li> <li>WAL is not truncated</li> </ul> <p>On restart, WAL is still fully replayed.</p>"},{"location":"CORE_WAL/#forbidden-wal-behaviors","title":"Forbidden WAL Behaviors","text":"<p>The following are explicitly forbidden:</p> <ul> <li>Skipping WAL entries</li> <li>Partial WAL replay</li> <li>WAL batching without fsync</li> <li>Delta-based WAL entries</li> <li>WAL-driven index mutation</li> <li>Silent corruption handling</li> </ul> <p>Any of these violate core invariants.</p>"},{"location":"CORE_WAL/#invariants-enforced-by-wal","title":"Invariants Enforced by WAL","text":"Invariant Enforcement D1 fsync before acknowledgment R1 WAL precedes all storage writes R2 Sequential deterministic replay R3 Explicit recovery success/failure K1 Checksums on every record K2 Halt-on-corruption policy C1 Full-document atomicity"},{"location":"CORE_WAL/#phase-0-limitations-intentional","title":"Phase 0 Limitations (Intentional)","text":"<ul> <li>No checkpointing</li> <li>No WAL truncation</li> <li>No WAL compression</li> <li>No encryption-at-rest</li> <li>No replication hooks</li> </ul> <p>All intentionally deferred.</p>"},{"location":"CORE_WAL/#final-statement","title":"Final Statement","text":"<p>The WAL is the foundation of aerodb\u2019s reliability.</p> <p>If WAL correctness is compromised: - Data safety is compromised - Recovery is compromised - Trust is compromised</p> <p>There are no acceptable shortcuts.</p> <p>The WAL must remain boring, strict, and absolute.</p>"},{"location":"CRASH_TESTING/","title":"CRASH_TESTING.md \u2014 AeroDB Crash Injection &amp; Failure Validation (Phase 1)","text":"<p>This document defines the authoritative crash testing methodology for AeroDB Phase 1.</p> <p>Crash testing validates:</p> <ul> <li>WAL durability</li> <li>storage atomicity</li> <li>recovery determinism</li> <li>checkpoint correctness</li> <li>snapshot safety</li> <li>backup/restore survivability</li> </ul> <p>If implementation behavior conflicts with this document, the implementation is wrong.</p> <p>Crash testing is mandatory before production usage.</p>"},{"location":"CRASH_TESTING/#1-principles","title":"1. Principles","text":"<p>Crash testing must obey:</p> <ol> <li>Deterministic reproduction</li> <li>Explicit kill points</li> <li>Zero partial recovery</li> <li>Exact post-crash validation</li> <li>No silent failures</li> </ol> <p>Crashes are intentional and controlled.</p>"},{"location":"CRASH_TESTING/#2-crash-types","title":"2. Crash Types","text":"<p>The following crash modes MUST be tested:</p> Crash Type Description SIGKILL Immediate process termination Power Loss Simulated abrupt filesystem stop Panic Rust panic Disk Error Forced IO failure <p>Each crash type must be validated independently.</p>"},{"location":"CRASH_TESTING/#3-kill-points","title":"3. Kill Points","text":"<p>Crash injection must be supported at the following points:</p>"},{"location":"CRASH_TESTING/#wal","title":"WAL","text":"<ul> <li>after record append</li> <li>before fsync</li> <li>after fsync</li> </ul>"},{"location":"CRASH_TESTING/#storage","title":"Storage","text":"<ul> <li>before document write</li> <li>after write, before checksum</li> <li>after checksum</li> </ul>"},{"location":"CRASH_TESTING/#index","title":"Index","text":"<ul> <li>during rebuild</li> <li>during update</li> </ul>"},{"location":"CRASH_TESTING/#snapshot","title":"Snapshot","text":"<ul> <li>during storage copy</li> <li>before manifest write</li> <li>after manifest write</li> </ul>"},{"location":"CRASH_TESTING/#checkpoint","title":"Checkpoint","text":"<ul> <li>after snapshot</li> <li>before WAL truncation</li> <li>after WAL truncation</li> </ul>"},{"location":"CRASH_TESTING/#restore","title":"Restore","text":"<ul> <li>after extraction</li> <li>before directory swap</li> <li>after directory swap</li> </ul>"},{"location":"CRASH_TESTING/#4-crash-injection-mechanism","title":"4. Crash Injection Mechanism","text":"<p>Testing harness must support:</p> <pre><code>AERODB_CRASH_POINT=&lt;symbolic_name&gt;\n</code></pre> <p>Example:</p> <pre><code>AERODB_CRASH_POINT=wal_after_fsync\n</code></pre> <p>When set:</p> <ul> <li>process terminates immediately at that point</li> </ul> <p>Crash points must be deterministic and reproducible.</p>"},{"location":"CRASH_TESTING/#5-required-test-scenarios","title":"5. Required Test Scenarios","text":""},{"location":"CRASH_TESTING/#51-wal-durability","title":"5.1 WAL Durability","text":"<p>Procedure:</p> <ol> <li>Insert document</li> <li>Crash after WAL fsync</li> <li>Restart</li> </ol> <p>Expected:</p> <ul> <li>document exists</li> </ul>"},{"location":"CRASH_TESTING/#52-wal-pre-fsync-crash","title":"5.2 WAL Pre-Fsync Crash","text":"<ol> <li>Insert document</li> <li>Crash before WAL fsync</li> <li>Restart</li> </ol> <p>Expected:</p> <ul> <li>document does NOT exist</li> </ul>"},{"location":"CRASH_TESTING/#53-storage-crash","title":"5.3 Storage Crash","text":"<ol> <li>Insert document</li> <li>Crash during storage write</li> <li>Restart</li> </ol> <p>Expected:</p> <ul> <li>either old or new document</li> <li>never corrupted state</li> </ul>"},{"location":"CRASH_TESTING/#54-index-rebuild-crash","title":"5.4 Index Rebuild Crash","text":"<ol> <li>Populate data</li> <li>Crash during index rebuild</li> <li>Restart</li> </ol> <p>Expected:</p> <ul> <li>recovery completes</li> <li>indexes rebuilt cleanly</li> </ul>"},{"location":"CRASH_TESTING/#55-snapshot-crash","title":"5.5 Snapshot Crash","text":"<p>Crash during snapshot creation.</p> <p>Expected:</p> <ul> <li>snapshot ignored</li> <li>WAL recovery used</li> </ul>"},{"location":"CRASH_TESTING/#56-checkpoint-crash","title":"5.6 Checkpoint Crash","text":"<p>Crash after snapshot but before WAL truncation.</p> <p>Expected:</p> <ul> <li>snapshot used</li> <li>WAL replayed</li> </ul>"},{"location":"CRASH_TESTING/#57-restore-crash","title":"5.7 Restore Crash","text":"<p>Crash during restore.</p> <p>Expected:</p> <ul> <li>either original or restored data_dir exists</li> <li>never partial mix</li> </ul>"},{"location":"CRASH_TESTING/#6-post-crash-validation","title":"6. Post-Crash Validation","text":"<p>After each crash:</p> <p>Must verify:</p> <ul> <li>storage checksums valid</li> <li>schemas loaded</li> <li>indexes rebuilt</li> <li>queries deterministic</li> <li>no partial documents</li> </ul> <p>All invariants must hold.</p>"},{"location":"CRASH_TESTING/#7-automation","title":"7. Automation","text":"<p>Crash tests must be automated via:</p> <ul> <li>subprocess execution</li> <li>environment variables</li> <li>filesystem inspection</li> </ul> <p>Tests belong in:</p> <pre><code>tests/crash/\n</code></pre>"},{"location":"CRASH_TESTING/#8-failure-criteria","title":"8. Failure Criteria","text":"<p>Any of the following is unacceptable:</p> <ul> <li>corrupted document state</li> <li>missing acknowledged writes</li> <li>partial records</li> <li>inconsistent indexes</li> <li>silent recovery</li> <li>non-deterministic results</li> </ul> <p>Any violation is a blocking defect.</p>"},{"location":"CRASH_TESTING/#9-phase-1-limitations","title":"9. Phase-1 Limitations","text":"<p>Crash testing does NOT include:</p> <ul> <li>network failures</li> <li>distributed faults</li> <li>replica divergence</li> </ul> <p>These belong to Phase 2.</p>"},{"location":"CRASH_TESTING/#10-authority","title":"10. Authority","text":"<p>This document governs:</p> <ul> <li>crash injection</li> <li>recovery validation</li> <li>checkpoint correctness</li> <li>snapshot reliability</li> <li>restore survivability</li> </ul> <p>Violations are correctness bugs.</p>"},{"location":"CRITICAL_PATHS/","title":"CRITICAL PATHS \u2014 PHASE 3","text":""},{"location":"CRITICAL_PATHS/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: Identification-only</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>PERFORMANCE_BASELINE.md</li> </ul> <p>This document defines the canonical critical execution paths in AeroDB. It does not introduce optimizations. It only marks where time is spent and which boundaries are semantically sensitive.</p> <p>If a path is not listed here, it MUST NOT be optimized in Phase 3.</p>"},{"location":"CRITICAL_PATHS/#1-definition-of-critical-path","title":"1. Definition of \u201cCritical Path\u201d","text":"<p>A critical path is an execution sequence where:</p> <ul> <li>End-to-end latency is user-visible, or</li> <li>Throughput is bounded by synchronous steps, or</li> <li>Durability / visibility boundaries exist</li> </ul> <p>Critical paths are semantic fault lines. Optimizing them requires proof that boundaries remain intact.</p>"},{"location":"CRITICAL_PATHS/#2-write-side-critical-paths","title":"2. Write-Side Critical Paths","text":""},{"location":"CRITICAL_PATHS/#21-primary-write-commit-path-single-document","title":"2.1 Primary Write Commit Path (Single Document)","text":"<p>This is the most sensitive path in AeroDB.</p>"},{"location":"CRITICAL_PATHS/#sequence-canonical","title":"Sequence (Canonical)","text":"<ol> <li>Client request accepted</li> <li>Schema validation</li> <li>MVCC uncommitted version creation</li> <li>WAL record construction</li> <li>WAL append</li> <li>WAL checksum write</li> <li>fsync completion</li> <li>CommitId assignment</li> <li>Acknowledgment to client</li> <li>In-memory index update</li> <li>Version visibility transition</li> </ol>"},{"location":"CRITICAL_PATHS/#critical-boundaries","title":"Critical Boundaries","text":"<ul> <li>Durability boundary: between steps 7 and 8</li> <li>Visibility boundary: after step 11</li> <li>Acknowledgment boundary: after step 8</li> </ul> <p>Any optimization touching this path MUST preserve: - Exact acknowledgment point - Exact durability semantics - CommitId monotonicity</p>"},{"location":"CRITICAL_PATHS/#22-wal-append-fsync-path","title":"2.2 WAL Append + fsync Path","text":"<p>This is the primary latency bottleneck.</p>"},{"location":"CRITICAL_PATHS/#characteristics","title":"Characteristics","text":"<ul> <li>Sequential file append</li> <li>Per-record checksum</li> <li>Synchronous fsync</li> <li>No batching in baseline</li> </ul>"},{"location":"CRITICAL_PATHS/#critical-properties","title":"Critical Properties","text":"<ul> <li>Append order == commit order</li> <li>fsync defines durability</li> <li>Partial writes are detectable</li> </ul> <p>This path is eligible for mechanical equivalence optimizations only.</p>"},{"location":"CRITICAL_PATHS/#3-read-side-critical-paths","title":"3. Read-Side Critical Paths","text":""},{"location":"CRITICAL_PATHS/#31-snapshot-based-point-read","title":"3.1 Snapshot-Based Point Read","text":""},{"location":"CRITICAL_PATHS/#sequence","title":"Sequence","text":"<ol> <li>Snapshot acquired</li> <li>Index lookup (if applicable)</li> <li>Version chain traversal</li> <li>Visibility check per version</li> <li>Document materialization</li> <li>Result return</li> </ol>"},{"location":"CRITICAL_PATHS/#critical-boundaries_1","title":"Critical Boundaries","text":"<ul> <li>Visibility decision (step 4)</li> <li>Version chain ordering</li> </ul> <p>Any optimization MUST: - Re-evaluate visibility explicitly - Preserve traversal semantics</p>"},{"location":"CRITICAL_PATHS/#32-range-query-read-execution","title":"3.2 Range / Query Read Execution","text":""},{"location":"CRITICAL_PATHS/#sequence_1","title":"Sequence","text":"<ol> <li>Query parse</li> <li>Plan selection</li> <li>Iterator creation</li> <li>Repeated snapshot-visible reads</li> <li>Result accumulation</li> </ol>"},{"location":"CRITICAL_PATHS/#critical-properties_1","title":"Critical Properties","text":"<ul> <li>Plan is deterministic</li> <li>Execution is bounded</li> <li>No adaptive behavior</li> </ul> <p>Optimizations may not: - Skip visibility checks - Short-circuit evaluation without proof</p>"},{"location":"CRITICAL_PATHS/#4-mvcc-specific-critical-paths","title":"4. MVCC-Specific Critical Paths","text":""},{"location":"CRITICAL_PATHS/#41-commitid-assignment","title":"4.1 CommitId Assignment","text":""},{"location":"CRITICAL_PATHS/#properties","title":"Properties","text":"<ul> <li>Occurs after fsync</li> <li>WAL-governed</li> <li>Single authority</li> </ul> <p>This path MUST remain: - Synchronous - Linear - Non-speculative</p>"},{"location":"CRITICAL_PATHS/#42-version-chain-traversal","title":"4.2 Version Chain Traversal","text":""},{"location":"CRITICAL_PATHS/#properties_1","title":"Properties","text":"<ul> <li>Ordered by CommitId</li> <li>Immutable once committed</li> <li>Deterministic traversal order</li> </ul> <p>Optimizations may reduce traversal cost, but MUST NOT alter traversal logic or visibility semantics.</p>"},{"location":"CRITICAL_PATHS/#5-snapshot-checkpoint-critical-paths","title":"5. Snapshot &amp; Checkpoint Critical Paths","text":""},{"location":"CRITICAL_PATHS/#51-snapshot-creation-path","title":"5.1 Snapshot Creation Path","text":""},{"location":"CRITICAL_PATHS/#sequence_2","title":"Sequence","text":"<ol> <li>Determine consistent CommitId</li> <li>Freeze snapshot visibility</li> <li>Enumerate state</li> <li>Persist snapshot files</li> <li>Write snapshot manifest</li> </ol>"},{"location":"CRITICAL_PATHS/#critical-boundaries_2","title":"Critical Boundaries","text":"<ul> <li>Snapshot CommitId selection</li> <li>Manifest durability</li> </ul>"},{"location":"CRITICAL_PATHS/#52-checkpoint-path","title":"5.2 Checkpoint Path","text":""},{"location":"CRITICAL_PATHS/#sequence_3","title":"Sequence","text":"<ol> <li>Snapshot completion</li> <li>Snapshot fsync</li> <li>Checkpoint marker written</li> <li>WAL truncation</li> </ol>"},{"location":"CRITICAL_PATHS/#critical-properties_2","title":"Critical Properties","text":"<ul> <li>WAL truncation only after snapshot durability</li> <li>No pipelining in baseline</li> </ul> <p>Any optimization MUST preserve this strict ordering.</p>"},{"location":"CRITICAL_PATHS/#6-recovery-critical-paths","title":"6. Recovery Critical Paths","text":""},{"location":"CRITICAL_PATHS/#61-startup-recovery","title":"6.1 Startup Recovery","text":""},{"location":"CRITICAL_PATHS/#sequence_4","title":"Sequence","text":"<ol> <li>Locate last checkpoint</li> <li>Load snapshot</li> <li>Replay WAL forward</li> <li>Validate checksums</li> <li>Rebuild in-memory state</li> </ol>"},{"location":"CRITICAL_PATHS/#critical-properties_3","title":"Critical Properties","text":"<ul> <li>Deterministic replay order</li> <li>Idempotent operations</li> <li>No optimization-dependent branches</li> </ul> <p>Optimizations MUST NOT: - Add replay-time conditionals - Depend on runtime configuration during replay</p>"},{"location":"CRITICAL_PATHS/#7-replication-sensitive-paths","title":"7. Replication-Sensitive Paths","text":"<p>Even before implementation, the following paths are replication-critical:</p>"},{"location":"CRITICAL_PATHS/#71-wal-emission-order","title":"7.1 WAL Emission Order","text":"<ul> <li>WAL is the replication stream</li> <li>Order defines replica state</li> </ul> <p>Any optimization touching WAL emission MUST preserve prefix ordering exactly.</p>"},{"location":"CRITICAL_PATHS/#72-commit-visibility-vs-wal-shipping","title":"7.2 Commit Visibility vs WAL Shipping","text":"<ul> <li>Commit becomes visible only after WAL durability</li> <li>Replica reads depend on MVCC safety</li> </ul> <p>No optimization may: - Make data visible before it is replicable - Introduce transient primary-only visibility</p>"},{"location":"CRITICAL_PATHS/#8-observability-interaction-points","title":"8. Observability Interaction Points","text":""},{"location":"CRITICAL_PATHS/#81-logging","title":"8.1 Logging","text":"<ul> <li>Occurs synchronously on critical paths</li> <li>Must not affect control flow</li> </ul>"},{"location":"CRITICAL_PATHS/#82-metrics","title":"8.2 Metrics","text":"<ul> <li>Emitted at defined boundaries</li> <li>Deterministic order</li> </ul> <p>Metrics MUST NOT be used to gate or adjust behavior.</p>"},{"location":"CRITICAL_PATHS/#9-explicit-non-critical-paths","title":"9. Explicit Non-Critical Paths","text":"<p>The following are not critical paths in Phase 3:</p> <ul> <li>Background maintenance (non-GC)</li> <li>Diagnostics</li> <li>Offline tooling</li> <li>Administrative queries</li> </ul> <p>These paths MUST NOT influence critical-path optimization decisions.</p>"},{"location":"CRITICAL_PATHS/#10-optimization-eligibility-matrix","title":"10. Optimization Eligibility Matrix","text":"Path Eligible for Phase 3 Optimization Write commit Yes (strict proof required) WAL fsync Yes (mechanical equivalence only) Read traversal Yes (MVCC-safe only) Snapshot creation Yes (ordering preserved) Checkpoint Yes (no semantic reordering) Recovery No (must remain baseline-equivalent) Observability No (passive only)"},{"location":"CRITICAL_PATHS/#11-role-of-this-document","title":"11. Role of This Document","text":"<p>This document:</p> <ul> <li>Identifies where optimization may occur</li> <li>Marks which boundaries are sacred</li> <li>Serves as a proof reference</li> </ul> <p>It does NOT: - Propose optimizations - Allow shortcuts - Relax invariants</p>"},{"location":"CRITICAL_PATHS/#12-final-rule","title":"12. Final Rule","text":"<p>If an optimization changes the shape of a critical path, it must prove the path is observationally identical.</p> <p>Otherwise, the optimization is invalid.</p> <p>END OF DOCUMENT</p>"},{"location":"DEV_TOOLS_READINESS/","title":"Phase 16: Developer Tools - Readiness Criteria","text":""},{"location":"DEV_TOOLS_READINESS/#freeze-checklist","title":"Freeze Checklist","text":"<p>Phase 16 is ready to freeze when all items below are complete:</p>"},{"location":"DEV_TOOLS_READINESS/#1-cli-aerodb","title":"1. CLI (<code>aerodb</code>)","text":"<ul> <li> Project Management</li> <li> <code>aerodb init &lt;name&gt;</code> (create project)</li> <li> <code>aerodb start</code> (start local server)</li> <li> <code>aerodb stop</code> (stop local server)</li> <li> <p> <code>aerodb status</code> (check if running)</p> </li> <li> <p> Migrations</p> </li> <li> <code>aerodb migrations new &lt;name&gt;</code> (create migration)</li> <li> <code>aerodb migrations up</code> (apply all pending)</li> <li> <code>aerodb migrations down</code> (rollback last)</li> <li> <code>aerodb migrations status</code> (show applied/pending)</li> <li> <p> <code>aerodb migrations reset</code> (rollback all + reapply)</p> </li> <li> <p> Code Generation</p> </li> <li> <code>aerodb types --lang typescript</code> (generate TS types)</li> <li> <code>aerodb types --lang python</code> (generate Pydantic models)</li> <li> <p> <code>aerodb types --output &lt;file&gt;</code> (write to file)</p> </li> <li> <p> Deployment</p> </li> <li> <code>aerodb deploy --env &lt;name&gt;</code> (apply migrations to remote)</li> <li> <p> <code>aerodb deploy --dry-run</code> (show pending migrations)</p> </li> <li> <p> Utilities</p> </li> <li> <code>aerodb seed &lt;file&gt;</code> (run seed SQL)</li> <li> <code>aerodb dump</code> (export data)</li> <li> <code>aerodb diff --source local --target prod</code> (schema diff)</li> </ul>"},{"location":"DEV_TOOLS_READINESS/#2-migration-system","title":"2. Migration System","text":"<ul> <li> File Format</li> <li> <code>.up.sql</code> and <code>.down.sql</code> files</li> <li> Timestamp prefix (YYYYMMDDHHMMSS_name.up.sql)</li> <li> <p> Stored in <code>migrations/</code> directory</p> </li> <li> <p> Tracking</p> </li> <li> <code>_migrations</code> table (version, name, applied_at)</li> <li> Idempotent up/down (can rerun safely)</li> <li> <p> Transactional (all or nothing)</p> </li> <li> <p> Features</p> </li> <li> Dependency checking (migrations applied in order)</li> <li> Rollback support (down.sql must undo up.sql)</li> <li> Dry-run mode (show SQL without executing)</li> </ul>"},{"location":"DEV_TOOLS_READINESS/#3-code-generation","title":"3. Code Generation","text":"<ul> <li> TypeScript</li> <li> Interface per table</li> <li> Nullable fields use <code>Type | null</code></li> <li> UUID/TIMESTAMPTZ mapped correctly</li> <li> <p> <code>Database</code> type (union of all tables)</p> </li> <li> <p> Python</p> </li> <li> Pydantic BaseModel per table</li> <li> Optional fields use <code>Optional[Type]</code></li> <li> <p> datetime, UUID types imported</p> </li> <li> <p> Schema Introspection</p> </li> <li> Read from <code>_schema</code> REST endpoint</li> <li> Parse columns, types, nullability</li> <li> Handle foreign keys (references)</li> </ul>"},{"location":"DEV_TOOLS_READINESS/#4-configuration","title":"4. Configuration","text":"<ul> <li> aerodb.toml</li> <li> <code>[project]</code> section (name, schema)</li> <li> <code>[database]</code> section (url)</li> <li> <code>[database.&lt;env&gt;]</code> sections (production, staging)</li> <li> <code>[migrations]</code> section (directory)</li> <li> <p> <code>[codegen]</code> section (output, lang)</p> </li> <li> <p> Environment Variables</p> </li> <li> <code>AERODB_URL</code> override</li> <li> <code>AERODB_KEY</code> for auth</li> <li> <code>.env</code> file support</li> </ul>"},{"location":"DEV_TOOLS_READINESS/#5-vs-code-extension","title":"5. VS Code Extension","text":"<ul> <li> Features</li> <li> SQL syntax highlighting</li> <li> Schema explorer (sidebar)</li> <li> Run SQL inline (Cmd+Enter)</li> <li> Autocomplete for table/column names</li> <li> <p> Migration snippets</p> </li> <li> <p> Installation</p> </li> <li> Published to VS Code Marketplace</li> <li> Search \"AeroDB\" in extensions</li> </ul>"},{"location":"DEV_TOOLS_READINESS/#6-testing","title":"6. Testing","text":"<ul> <li> CLI Tests</li> <li> <code>aerodb init</code> creates correct files</li> <li> <code>aerodb migrations up</code> applies migrations</li> <li> <code>aerodb types</code> generates valid TypeScript</li> <li> <p> <code>aerodb deploy</code> fails gracefully on error</p> </li> <li> <p> Code Gen Tests</p> </li> <li> Generated TS types compile without errors</li> <li> <p> Generated Python models validate with mypy</p> </li> <li> <p> Integration Tests</p> </li> <li> Full workflow: init \u2192 migrate \u2192 codegen \u2192 deploy</li> </ul>"},{"location":"DEV_TOOLS_READINESS/#7-documentation","title":"7. Documentation","text":"<ul> <li> CLI Reference</li> <li> All commands documented</li> <li> Examples for each command</li> <li> <p> Flag descriptions</p> </li> <li> <p> Migration Guide</p> </li> <li> How to create first migration</li> <li> Best practices (naming, rollbacks)</li> <li> <p> Common patterns (add column, drop table)</p> </li> <li> <p> Code Gen Guide</p> </li> <li> Using generated types in app</li> <li> <p> Customizing output (exclude tables)</p> </li> <li> <p> aerodb.toml Reference</p> </li> <li> All sections explained</li> <li> Example configurations</li> </ul>"},{"location":"DEV_TOOLS_READINESS/#8-platform-support","title":"8. Platform Support","text":"<ul> <li> Operating Systems</li> <li> macOS (Intel + Apple Silicon)</li> <li> Linux (x86_64, aarch64)</li> <li> <p> Windows (x86_64)</p> </li> <li> <p> Installation</p> </li> <li> Homebrew (macOS/Linux): <code>brew install aerodb</code></li> <li> Cargo (Rust): <code>cargo install aerodb-cli</code></li> <li> npm (global): <code>npm install -g @aerodb/cli</code> (wrapper)</li> <li> Binary release (GitHub Releases)</li> </ul>"},{"location":"DEV_TOOLS_READINESS/#9-cicd-integration","title":"9. CI/CD Integration","text":"<ul> <li> GitHub Actions</li> <li> <code>aerodb/setup-cli</code> action</li> <li> <p> Example workflow (migrate on push)</p> </li> <li> <p> GitLab CI</p> </li> <li> Docker image with <code>aerodb</code> CLI</li> <li> <p> Example <code>.gitlab-ci.yml</code></p> </li> <li> <p> Vercel/Netlify</p> </li> <li> Run migrations via webhook</li> <li> Example integrations</li> </ul>"},{"location":"DEV_TOOLS_READINESS/#10-performance","title":"10. Performance","text":"<ul> <li> Startup Time</li> <li> <code>aerodb start</code> &lt; 2 seconds</li> <li> <p> <code>aerodb types</code> &lt; 1 second</p> </li> <li> <p> Binary Size</p> </li> <li> &lt; 20MB (release build)</li> </ul>"},{"location":"DEV_TOOLS_READINESS/#sign-off","title":"Sign-Off","text":"<p>Phase 16 is frozen when:</p> <ol> <li>All checklist items complete</li> <li>CLI published to Homebrew, Cargo, npm</li> <li>VS Code extension published</li> <li>Full workflow tested (init \u2192 migrate \u2192 deploy)</li> <li>Documentation complete</li> </ol> <p>Frozen on: [DATE]</p> <p>Approved by: [NAME]</p>"},{"location":"DEV_TOOLS_VISION/","title":"Phase 16: Developer Tools - Vision","text":""},{"location":"DEV_TOOLS_VISION/#purpose","title":"Purpose","text":"<p>Provide CLI, migration tools, and code generators to streamline AeroDB development workflows.</p>"},{"location":"DEV_TOOLS_VISION/#philosophy","title":"Philosophy","text":""},{"location":"DEV_TOOLS_VISION/#local-first-development","title":"Local-First Development","text":"<p>Developers should be able to: - Run AeroDB locally (single binary, no Docker required) - Develop offline (local DB, no network) - Deploy easily (single command)</p>"},{"location":"DEV_TOOLS_VISION/#git-like-workflow","title":"Git-Like Workflow","text":"<p>Database changes are treated like code: - Migrations are commits - Branches for schema experimentation - Merge conflicts are schema conflicts</p>"},{"location":"DEV_TOOLS_VISION/#core-tools","title":"Core Tools","text":""},{"location":"DEV_TOOLS_VISION/#1-cli-aerodb","title":"1. CLI (<code>aerodb</code>)","text":"<p>Command-line interface for all operations:</p> <pre><code># Initialize project\naerodb init my-project\n\n# Start local database\naerodb start\n\n# Create migration\naerodb migrations new add_users_table\n\n# Apply migrations\naerodb migrations up\n\n# Generate TypeScript types\naerodb types &gt; src/database.types.ts\n\n# Deploy to production\naerodb deploy --env production\n</code></pre>"},{"location":"DEV_TOOLS_VISION/#2-migration-system","title":"2. Migration System","text":"<p>SQL-based migrations with version control:</p> <pre><code># Create migration\naerodb migrations new add_posts_table\n# Creates: migrations/20240815120000_add_posts_table.up.sql\n#         migrations/20240815120000_add_posts_table.down.sql\n\n# Apply all pending\naerodb migrations up\n\n# Rollback last\naerodb migrations down\n\n# Show status\naerodb migrations status\n</code></pre> <p>Example migration: <pre><code>-- migrations/20240815120000_add_posts_table.up.sql\nCREATE TABLE posts (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  title TEXT NOT NULL,\n  content TEXT,\n  author_id UUID REFERENCES users(id),\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE INDEX idx_posts_author ON posts(author_id);\n</code></pre></p>"},{"location":"DEV_TOOLS_VISION/#3-code-generation","title":"3. Code Generation","text":"<p>Generate types from database schema:</p> <pre><code># TypeScript types\naerodb types --lang typescript &gt; types.ts\n\n# Python Pydantic models\naerodb types --lang python &gt; models.py\n</code></pre> <p>Output (TypeScript): <pre><code>export interface User {\n  id: string;\n  email: string;\n  created_at: string;\n}\n\nexport interface Post {\n  id: string;\n  title: string;\n  content: string | null;\n  author_id: string;\n  created_at: string;\n}\n\nexport interface Database {\n  users: User;\n  posts: Post;\n}\n</code></pre></p>"},{"location":"DEV_TOOLS_VISION/#4-vs-code-extension","title":"4. VS Code Extension","text":"<p>Features: - SQL syntax highlighting with AeroDB-specific extensions - Schema explorer (sidebar panel) - Query execution (Run SQL inline) - Autocomplete for table/column names - Migration snippets</p>"},{"location":"DEV_TOOLS_VISION/#5-schema-diff-tool","title":"5. Schema Diff Tool","text":"<p>Compare local and remote schemas:</p> <pre><code>aerodb diff --source local --target production\n</code></pre> <p>Output: <pre><code>+ CREATE TABLE posts (...)\n- DROP TABLE old_logs\n~ ALTER TABLE users ADD COLUMN last_login TIMESTAMPTZ\n</code></pre></p>"},{"location":"DEV_TOOLS_VISION/#6-seed-data-management","title":"6. Seed Data Management","text":"<p>Populate dev/test databases:</p> <pre><code># Run seed file\naerodb seed data/seed.sql\n\n# Export current data\naerodb dump --data-only &gt; data/seed.sql\n</code></pre> <p>Example seed: <pre><code>-- data/seed.sql\nINSERT INTO users (email, name) VALUES\n  ('alice@example.com', 'Alice'),\n  ('bob@example.com', 'Bob');\n\nINSERT INTO posts (title, author_id) VALUES\n  ('First Post', (SELECT id FROM users WHERE email = 'alice@example.com'));\n</code></pre></p>"},{"location":"DEV_TOOLS_VISION/#cli-architecture","title":"CLI Architecture","text":"<pre><code>aerodb (Rust binary)\n\u251c\u2500\u2500 commands/\n\u2502   \u251c\u2500\u2500 init.rs          # Project initialization\n\u2502   \u251c\u2500\u2500 start.rs         # Start local server\n\u2502   \u251c\u2500\u2500 migrations.rs    # Migration commands\n\u2502   \u251c\u2500\u2500 types.rs         # Code generation\n\u2502   \u251c\u2500\u2500 deploy.rs        # Deployment\n\u2502   \u2514\u2500\u2500 seed.rs          # Data seeding\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 config.rs        # Parse aerodb.toml\n\u2502   \u251c\u2500\u2500 client.rs        # HTTP client for API\n\u2502   \u2514\u2500\u2500 schema.rs        # Schema introspection\n\u2514\u2500\u2500 main.rs\n</code></pre>"},{"location":"DEV_TOOLS_VISION/#configuration-file","title":"Configuration File","text":"<pre><code># aerodb.toml\n[project]\nname = \"my-app\"\nschema = \"public\"\n\n[database]\nurl = \"http://localhost:54321\"\n\n[database.production]\nurl = \"https://my-app.aerodb.com\"\nkey = \"${AERODB_KEY}\"\n\n[migrations]\ndirectory = \"migrations\"\n\n[codegen]\noutput = \"src/types/database.types.ts\"\nlang = \"typescript\"\n</code></pre>"},{"location":"DEV_TOOLS_VISION/#developer-workflow","title":"Developer Workflow","text":""},{"location":"DEV_TOOLS_VISION/#step-1-initialize-project","title":"Step 1: Initialize Project","text":"<pre><code>aerodb init my-app\ncd my-app\n</code></pre> <p>Creates: <pre><code>my-app/\n\u251c\u2500\u2500 aerodb.toml\n\u251c\u2500\u2500 migrations/\n\u2514\u2500\u2500 .gitignore\n</code></pre></p>"},{"location":"DEV_TOOLS_VISION/#step-2-start-local-database","title":"Step 2: Start Local Database","text":"<pre><code>aerodb start\n# Runs local AeroDB on http://localhost:54321\n</code></pre>"},{"location":"DEV_TOOLS_VISION/#step-3-create-schema","title":"Step 3: Create Schema","text":"<pre><code>aerodb migrations new create_users\n# Edit migrations/...create_users.up.sql\naerodb migrations up\n</code></pre>"},{"location":"DEV_TOOLS_VISION/#step-4-generate-types","title":"Step 4: Generate Types","text":"<pre><code>aerodb types &gt; src/database.types.ts\n</code></pre>"},{"location":"DEV_TOOLS_VISION/#step-5-develop-application","title":"Step 5: Develop Application","text":"<p>Use generated types in application code:</p> <pre><code>import { AeroDBClient } from '@aerodb/client';\nimport type { Database } from './database.types';\n\nconst client = new AeroDBClient&lt;Database&gt;({ url: 'http://localhost:54321' });\n\nconst { data } = await client.from('users').select('*');\n// `data` is typed as User[]\n</code></pre>"},{"location":"DEV_TOOLS_VISION/#step-6-deploy","title":"Step 6: Deploy","text":"<pre><code>aerodb deploy --env production\n# Applies pending migrations to production\n</code></pre>"},{"location":"DEV_TOOLS_VISION/#integration-with-other-tools","title":"Integration with Other Tools","text":""},{"location":"DEV_TOOLS_VISION/#github-actions","title":"GitHub Actions","text":"<pre><code>name: Deploy\non: push\n\njobs:\n  migrate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: aerodb/setup-cli@v1\n      - run: aerodb migrations up --env production\n        env:\n          AERODB_KEY: ${{ secrets.AERODB_KEY }}\n</code></pre>"},{"location":"DEV_TOOLS_VISION/#docker","title":"Docker","text":"<pre><code>FROM aerodb/aerodb:latest\n\nCOPY migrations /migrations\nRUN aerodb migrations up\n</code></pre>"},{"location":"DEV_TOOLS_VISION/#success-criteria","title":"Success Criteria","text":"<p>Developer tools are successful if:</p> <ol> <li>Setup time &lt; 5 minutes: <code>aerodb init</code> \u2192 local DB running</li> <li>Type safety: Zero runtime errors from schema mismatches</li> <li>Fast migrations: &lt; 10s to apply migrations to empty DB</li> </ol>"},{"location":"DEV_TOOLS_VISION/#non-goals","title":"Non-Goals","text":"<ul> <li>GUI migration tool: Migrations are code (SQL files)</li> <li>ORM features: CLI focuses on schema, not query building</li> <li>Database browser: Use Admin Dashboard (Phase 13)</li> </ul>"},{"location":"DEV_TOOLS_VISION/#prior-art","title":"Prior Art","text":"<p>Inspired by: - Prisma: <code>prisma migrate</code>, <code>prisma generate</code> - Supabase CLI: <code>supabase init</code>, <code>supabase start</code> - Rails migrations: <code>rails db:migrate</code>, <code>db:rollback</code> - Flyway: SQL-based migrations with version control</p> <p>Differentiator: Integrated with AeroDB control plane - deployment, types, migrations all use same config.</p>"},{"location":"DX_ADMIN_UI_ARCH/","title":"ADMIN UI ARCHITECTURE \u2014 PHASE 4","text":""},{"location":"DX_ADMIN_UI_ARCH/#status","title":"Status","text":"<ul> <li>Phase: 4</li> <li>Authority: Normative</li> <li>Scope: Read-only developer UI for observability and explanation</li> <li>Depends on:</li> <li>PHASE4_VISION.md</li> <li>PHASE4_INVARIANTS.md</li> <li>OBSERVABILITY_API.md</li> <li>PERFORMANCE_OBSERVABILITY.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> </ul> <p>This document defines the architecture, boundaries, and obligations of the AeroDB Admin UI.</p> <p>If the UI violates any rule in this document, it MUST NOT ship.</p>"},{"location":"DX_ADMIN_UI_ARCH/#1-purpose","title":"1. Purpose","text":"<p>The Admin UI exists to make AeroDB:</p> <ul> <li>Inspectable</li> <li>Explainable</li> <li>Trustworthy</li> </ul> <p>It exists to reveal internal truth, not to simplify or abstract it away.</p> <p>The UI is not: - A database client - An admin console - A management plane - A production dashboard</p> <p>It is a local inspection instrument.</p>"},{"location":"DX_ADMIN_UI_ARCH/#2-core-ui-principle","title":"2. Core UI Principle","text":""},{"location":"DX_ADMIN_UI_ARCH/#the-glass-box-ui-principle","title":"The Glass Box UI Principle","text":"<p>The Admin UI must show AeroDB as it actually is, not as users might wish it to be.</p> <p>This means: - Internal identifiers are shown, not hidden - Raw state is preferred over summaries - Complexity is not collapsed into \u201cgreen lights\u201d</p> <p>If something is complicated, the UI must show that complication honestly.</p>"},{"location":"DX_ADMIN_UI_ARCH/#3-architectural-boundaries","title":"3. Architectural Boundaries","text":""},{"location":"DX_ADMIN_UI_ARCH/#ui-1-strict-read-only-boundary","title":"UI-1: Strict Read-Only Boundary","text":"<p>The UI MUST:</p> <ul> <li>Consume only <code>OBSERVABILITY_API.md</code></li> <li>Perform no writes</li> <li>Perform no control actions</li> <li>Trigger no background work</li> </ul> <p>The UI is incapable of changing AeroDB state.</p>"},{"location":"DX_ADMIN_UI_ARCH/#ui-2-api-fidelity","title":"UI-2: API Fidelity","text":"<p>For every UI element:</p> <ul> <li>There must be a direct API source</li> <li>UI labels must match API semantics</li> <li>No inferred or derived state is allowed unless explicitly labeled</li> </ul> <p>If the API cannot explain it, the UI must not invent it.</p>"},{"location":"DX_ADMIN_UI_ARCH/#ui-3-removability","title":"UI-3: Removability","text":"<p>The UI MUST be:</p> <ul> <li>Optional</li> <li>Fully removable</li> <li>Isolated from core runtime</li> </ul> <p>Removing the UI must leave AeroDB behavior unchanged.</p>"},{"location":"DX_ADMIN_UI_ARCH/#4-deployment-model","title":"4. Deployment Model","text":""},{"location":"DX_ADMIN_UI_ARCH/#41-local-only-assumption","title":"4.1 Local-Only Assumption","text":"<p>The Admin UI assumes:</p> <ul> <li>Local developer environment</li> <li>Trusted user</li> <li>Debug / inspection usage</li> </ul> <p>The UI MUST NOT: - Advertise production readiness - Imply security hardening - Support multi-user access</p>"},{"location":"DX_ADMIN_UI_ARCH/#42-ui-runtime-separation","title":"4.2 UI Runtime Separation","text":"<p>The UI MUST:</p> <ul> <li>Run as a separate process or static frontend</li> <li>Communicate via HTTP to Observability API</li> <li>Never link directly against storage or MVCC code</li> </ul> <p>This preserves isolation and passivity.</p>"},{"location":"DX_ADMIN_UI_ARCH/#5-information-architecture-mandatory-views","title":"5. Information Architecture (Mandatory Views)","text":"<p>The UI MUST implement the following views.</p>"},{"location":"DX_ADMIN_UI_ARCH/#51-overview-status-view","title":"5.1 Overview / Status View","text":"<p>Purpose: High-level orientation</p> <p>Displays: - Lifecycle state (booting / running / recovering) - Current CommitId high-water mark - WAL durability boundary - Phase enablement flags</p> <p>Rules: - No health scores - No \u201cOK / WARN / ERROR\u201d simplifications - Raw state first, explanation second</p>"},{"location":"DX_ADMIN_UI_ARCH/#52-wal-inspector","title":"5.2 WAL Inspector","text":"<p>Purpose: Durability and ordering transparency</p> <p>Displays: - WAL files and segments - Append offsets - Durable offsets - Truncation points - Checksum status</p> <p>Rules: - No hiding of offsets - Explicit durability boundaries - Visual separation of \u201cwritten\u201d vs \u201cdurable\u201d</p>"},{"location":"DX_ADMIN_UI_ARCH/#53-mvcc-inspector","title":"5.3 MVCC Inspector","text":"<p>Purpose: Visibility and isolation clarity</p> <p>Displays: - CommitId ranges - Active snapshots - Snapshot CommitIds - GC watermark (if applicable)</p> <p>Rules: - Show numeric CommitIds - No abstract \u201ctime\u201d metaphors - Snapshot identity must be explicit</p>"},{"location":"DX_ADMIN_UI_ARCH/#54-snapshot-checkpoint-view","title":"5.4 Snapshot &amp; Checkpoint View","text":"<p>Purpose: Persistence safety inspection</p> <p>Displays: - Active snapshots - Last completed checkpoint - WAL coverage per checkpoint - Pending / aborted checkpoints</p> <p>Rules: - Clear distinction between \u201cprepared\u201d and \u201cdurable\u201d - No implied safety before fsync</p>"},{"location":"DX_ADMIN_UI_ARCH/#55-index-inspector","title":"5.5 Index Inspector","text":"<p>Purpose: Query acceleration transparency</p> <p>Displays: - Index identifiers - Index type - Build status - Entry counts - Rebuild state</p> <p>Rules: - Indexes clearly labeled as advisory - No claims of completeness or authority</p>"},{"location":"DX_ADMIN_UI_ARCH/#56-replication-view-conditional","title":"5.6 Replication View (Conditional)","text":"<p>Purpose: Replica safety inspection</p> <p>Displays: - Node role (primary / replica) - WAL prefix position - Replica lag (CommitId-based) - Snapshot bootstrap status</p> <p>Rules: - No heuristic \u201clag OK\u201d indicators - No peer reachability assumptions</p>"},{"location":"DX_ADMIN_UI_ARCH/#57-query-explanation-view","title":"5.7 Query Explanation View","text":"<p>Purpose: Deterministic reasoning</p> <p>Displays: - Query text - Execution plan - Index usage - Snapshot used - Bounds applied</p> <p>Rules: - Explanation must match <code>/v1/explain/query</code> - No speculative reasoning - No performance promises</p>"},{"location":"DX_ADMIN_UI_ARCH/#58-read-visibility-explanation-view","title":"5.8 Read Visibility Explanation View","text":"<p>Purpose: MVCC trust</p> <p>Displays: - Document identifier - Version chain - CommitId comparisons - Visibility decision</p> <p>Rules: - Step-by-step visibility logic - Exact CommitId comparisons - No narrative shortcuts</p>"},{"location":"DX_ADMIN_UI_ARCH/#59-recovery-explanation-view","title":"5.9 Recovery Explanation View","text":"<p>Purpose: Failure trust</p> <p>Displays: - Last crash point - Recovery start point - Snapshot selected - WAL replay range - Validation steps</p> <p>Rules: - Must reflect real recovery - No \u201csuccessful recovery\u201d banners - Raw steps first, summary last</p>"},{"location":"DX_ADMIN_UI_ARCH/#6-ui-interaction-rules","title":"6. UI Interaction Rules","text":""},{"location":"DX_ADMIN_UI_ARCH/#ui-4-no-control-interactions","title":"UI-4: No Control Interactions","text":"<p>The UI MUST NOT include:</p> <ul> <li>Buttons that trigger actions</li> <li>Forms that submit mutations</li> <li>Toggles that affect runtime behavior</li> </ul> <p>If an interaction changes state, the UI is invalid.</p>"},{"location":"DX_ADMIN_UI_ARCH/#ui-5-explicit-cost-visibility","title":"UI-5: Explicit Cost Visibility","text":"<p>If an API call is expensive:</p> <ul> <li>The UI MUST show that cost</li> <li>The UI MUST not auto-refresh aggressively</li> <li>Polling intervals must be explicit</li> </ul> <p>Hidden cost is forbidden.</p>"},{"location":"DX_ADMIN_UI_ARCH/#7-determinism-stability","title":"7. Determinism &amp; Stability","text":""},{"location":"DX_ADMIN_UI_ARCH/#ui-6-stable-rendering","title":"UI-6: Stable Rendering","text":"<p>Given identical API responses:</p> <ul> <li>UI output MUST be identical</li> <li>Ordering MUST be stable</li> <li>No random IDs or animations</li> </ul> <p>The UI must be diff-friendly.</p>"},{"location":"DX_ADMIN_UI_ARCH/#8-error-handling","title":"8. Error Handling","text":""},{"location":"DX_ADMIN_UI_ARCH/#ui-7-error-transparency","title":"UI-7: Error Transparency","text":"<p>Errors MUST be shown:</p> <ul> <li>With raw error codes</li> <li>With invariant references</li> <li>Without user-friendly dilution</li> </ul> <p>The UI explains errors; it does not soften them.</p>"},{"location":"DX_ADMIN_UI_ARCH/#9-forbidden-ui-patterns","title":"9. Forbidden UI Patterns","text":"<p>The following are explicitly forbidden:</p> <ul> <li>\u201cTraffic light\u201d health indicators</li> <li>Auto-healing messaging</li> <li>Hidden state aggregation</li> <li>Collapsing failures into \u201cunknown\u201d</li> <li>Pretty timelines that imply causality</li> <li>Marketing language</li> </ul> <p>If it looks like a dashboard, it is wrong.</p>"},{"location":"DX_ADMIN_UI_ARCH/#10-testing-requirements","title":"10. Testing Requirements","text":"<p>The Admin UI MUST be tested for:</p> <ul> <li>Read-only enforcement</li> <li>API fidelity</li> <li>Deterministic rendering</li> <li>Disablement safety</li> <li>Error surface correctness</li> </ul> <p>UI tests must assume: - Partial data - Failure states - Mid-recovery visibility</p>"},{"location":"DX_ADMIN_UI_ARCH/#11-phase-4-completion-criteria-ui","title":"11. Phase 4 Completion Criteria (UI)","text":"<p>Phase 4 UI is complete when:</p> <ul> <li>A developer can explain any read result</li> <li>A crash can be understood without logs</li> <li>WAL durability boundaries are visible</li> <li>MVCC behavior is inspectable</li> <li>Replication safety can be reasoned about</li> </ul> <p>Without reading source code.</p>"},{"location":"DX_ADMIN_UI_ARCH/#12-final-rule","title":"12. Final Rule","text":"<p>The Admin UI must never reassure. It must only reveal.</p> <p>If the UI makes AeroDB feel \u201csafe\u201d without evidence, it has already failed.</p> <p>END OF DOCUMENT</p>"},{"location":"DX_EXPLANATION_MODEL/","title":"EXPLANATION MODEL \u2014 PHASE 4","text":""},{"location":"DX_EXPLANATION_MODEL/#status","title":"Status","text":"<ul> <li>Phase: 4</li> <li>Authority: Normative</li> <li>Scope: All explanations exposed via API or UI</li> <li>Depends on:</li> <li>PHASE4_VISION.md</li> <li>PHASE4_INVARIANTS.md</li> <li>OBSERVABILITY_API.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> <li>FAILURE_MODEL_PHASE3.md</li> </ul> <p>This document defines the formal model for explanations in AeroDB. If an explanation cannot be expressed using this model, it MUST NOT be exposed.</p>"},{"location":"DX_EXPLANATION_MODEL/#1-purpose","title":"1. Purpose","text":"<p>AeroDB does not merely report outcomes. It must be able to explain why those outcomes occurred.</p> <p>This document ensures that explanations are:</p> <ul> <li>Exact</li> <li>Verifiable</li> <li>Deterministic</li> <li>Evidence-based</li> </ul> <p>Explanations are not summaries, guesses, or narratives. They are structured proofs over observed state.</p>"},{"location":"DX_EXPLANATION_MODEL/#2-core-principle","title":"2. Core Principle","text":""},{"location":"DX_EXPLANATION_MODEL/#explanation-as-evidence-principle","title":"Explanation-as-Evidence Principle","text":"<p>Every explanation in AeroDB must be reducible to concrete system state and explicit rules.</p> <p>An explanation is valid only if: - It references real identifiers - It applies explicit rules - It can be independently re-derived</p> <p>If an explanation cannot be proven, it must not exist.</p>"},{"location":"DX_EXPLANATION_MODEL/#3-what-an-explanation-is-and-is-not","title":"3. What an Explanation Is (and Is Not)","text":""},{"location":"DX_EXPLANATION_MODEL/#31-an-explanation-is","title":"3.1 An Explanation IS","text":"<ul> <li>A structured record</li> <li>A sequence of evaluated facts</li> <li>A traceable reasoning path</li> <li>A deterministic artifact</li> </ul>"},{"location":"DX_EXPLANATION_MODEL/#32-an-explanation-is-not","title":"3.2 An Explanation IS NOT","text":"<ul> <li>A human-friendly story</li> <li>A heuristic guess</li> <li>A performance hint</li> <li>A visualization-driven inference</li> <li>A simplification for convenience</li> </ul> <p>If an explanation reads like prose, it is probably wrong.</p>"},{"location":"DX_EXPLANATION_MODEL/#4-explanation-object-model","title":"4. Explanation Object Model","text":"<p>All explanations MUST conform to the following structure:</p> <pre><code>{\n  \"explanation_type\": \"&lt;type&gt;\",\n  \"observed_snapshot\": {\n    \"snapshot_id\": \"&lt;id&gt;\",\n    \"commit_id\": &lt;number&gt;\n  },\n  \"inputs\": { ... },\n  \"rules_applied\": [\n    {\n      \"rule_id\": \"&lt;stable identifier&gt;\",\n      \"description\": \"&lt;exact rule reference&gt;\",\n      \"evaluation\": \"true | false\",\n      \"evidence\": { ... }\n    }\n  ],\n  \"conclusion\": { ... }\n}\n````\n\nRules:\n\n* `rule_id` MUST map to a documented invariant or rule\n* `evaluation` MUST be explicit\n* `evidence` MUST be raw state, not interpretation\n\n---\n\n## 5. Rule References\n\n### 5.1 Rule Identity\n\nEvery rule referenced in explanations MUST:\n\n* Have a stable identifier\n* Map to one of:\n\n  * INVARIANTS.md\n  * PHASE*_INVARIANTS.md\n  * MVCC rules\n  * Replication rules\n  * Failure model rules\n\nFree-form rules are forbidden.\n\n---\n\n### 5.2 Rule Application Semantics\n\nRules MUST be applied:\n\n* In a defined order\n* Explicitly\n* Without short-circuiting unless documented\n\nSkipping a rule is a correctness violation.\n\n---\n\n## 6. Explanation Types (Mandatory)\n\nThe following explanation types MUST be supported.\n\n---\n\n### 6.1 Read Visibility Explanation\n\n**Type:** `mvcc.read_visibility`\n\nExplains:\n\n* Why a specific document version is visible or invisible\n\nInputs:\n\n* Document ID\n* Snapshot CommitId\n\nRules Applied:\n\n* MVCC visibility rules\n* CommitId comparisons\n* Tombstone handling\n\nConclusion:\n\n* Visible version ID OR\n* Explicit \u201cno visible version\u201d result\n\n---\n\n### 6.2 Query Execution Explanation\n\n**Type:** `query.execution`\n\nExplains:\n\n* How a query was executed\n\nInputs:\n\n* Query\n* Snapshot CommitId\n\nRules Applied:\n\n* Query planning rules\n* Bounds enforcement\n* Index advisory usage\n\nConclusion:\n\n* Deterministic execution plan\n* Guarantees enforced\n\n---\n\n### 6.3 Recovery Explanation\n\n**Type:** `recovery.process`\n\nExplains:\n\n* How recovery proceeded after a crash\n\nInputs:\n\n* Last known durable state\n\nRules Applied:\n\n* Checkpoint selection rules\n* WAL replay rules\n* Checksum validation rules\n\nConclusion:\n\n* Final recovered CommitId\n* State validity result\n\n---\n\n### 6.4 Checkpoint Safety Explanation\n\n**Type:** `checkpoint.safety`\n\nExplains:\n\n* Why a checkpoint is valid or not\n\nInputs:\n\n* Checkpoint marker\n* Snapshot metadata\n* WAL offsets\n\nRules Applied:\n\n* Durability ordering rules\n* Snapshot completeness rules\n\nConclusion:\n\n* Checkpoint accepted or rejected\n\n---\n\n### 6.5 Replication Safety Explanation (Conditional)\n\n**Type:** `replication.safety`\n\nExplains:\n\n* Why a replica is safe to serve reads\n\nInputs:\n\n* Replica WAL prefix\n* Snapshot CommitId\n\nRules Applied:\n\n* WAL prefix rule\n* MVCC snapshot safety rule\n\nConclusion:\n\n* Read-safe or not read-safe\n\n---\n\n## 7. Determinism Requirements\n\nExplanations MUST be:\n\n* Deterministic\n* Stable across restarts\n* Independent of timing\n* Independent of UI context\n\nIf two identical states produce different explanations,\nthat is a correctness bug.\n\n---\n\n## 8. Failure and Partial-State Handling\n\n### 8.1 Incomplete Evidence\n\nIf evidence is missing:\n\n* The explanation MUST say so explicitly\n* No inferred conclusion is allowed\n\nExample:\n\n```json\n{\n  \"conclusion\": {\n    \"status\": \"undetermined\",\n    \"reason\": \"WAL segment missing\"\n  }\n}\n</code></pre>"},{"location":"DX_EXPLANATION_MODEL/#82-failure-during-explanation","title":"8.2 Failure During Explanation","text":"<p>If explanation generation fails:</p> <ul> <li>The failure MUST be surfaced</li> <li>Partial explanations MUST be marked incomplete</li> </ul> <p>Silently dropping explanations is forbidden.</p>"},{"location":"DX_EXPLANATION_MODEL/#9-relationship-to-ui","title":"9. Relationship to UI","text":"<p>The UI:</p> <ul> <li>Renders explanations</li> <li>Does not generate explanations</li> <li>Does not reorder rules</li> <li>Does not simplify conclusions</li> </ul> <p>All explanation logic lives in the core system or API layer.</p>"},{"location":"DX_EXPLANATION_MODEL/#10-relationship-to-observability-api","title":"10. Relationship to Observability API","text":"<ul> <li>Explanations are delivered via <code>/v1/explain/*</code></li> <li>API responses MUST embed explanation objects verbatim</li> <li>UI consumes explanations as immutable artifacts</li> </ul> <p>No UI-side interpretation allowed.</p>"},{"location":"DX_EXPLANATION_MODEL/#11-testing-requirements","title":"11. Testing Requirements","text":"<p>Each explanation type MUST have tests that:</p> <ul> <li>Verify rule completeness</li> <li>Verify evidence accuracy</li> <li>Verify determinism</li> <li>Verify failure transparency</li> </ul> <p>Golden-file tests are recommended.</p>"},{"location":"DX_EXPLANATION_MODEL/#12-explicit-non-goals","title":"12. Explicit Non-Goals","text":"<p>The Explanation Model does NOT aim to:</p> <ul> <li>Teach database theory</li> <li>Optimize readability</li> <li>Provide debugging shortcuts</li> <li>Replace documentation</li> </ul> <p>It exists to provide proof artifacts, not tutorials.</p>"},{"location":"DX_EXPLANATION_MODEL/#13-final-rule","title":"13. Final Rule","text":"<p>An explanation that cannot be proven is worse than no explanation at all.</p> <p>AeroDB earns trust by refusing to guess.</p> <p>END OF DOCUMENT</p>"},{"location":"DX_INVARIANTS/","title":"PHASE 4 \u2014 INVARIANTS (DEVELOPER EXPERIENCE &amp; VISIBILITY)","text":""},{"location":"DX_INVARIANTS/#status","title":"Status","text":"<ul> <li>Phase: 4</li> <li>Authority: Normative</li> <li>Scope: All Phase 4 observability, APIs, and UI</li> <li>Depends on:</li> <li>INVARIANTS.md (global)</li> <li>PERF_INVARIANTS.md</li> <li>PERFORMANCE_OBSERVABILITY.md</li> </ul> <p>This document defines the non-negotiable invariants governing Phase 4. Any Phase 4 component that violates these invariants is invalid and must be removed.</p>"},{"location":"DX_INVARIANTS/#1-purpose","title":"1. Purpose","text":"<p>Phase 4 exists to make AeroDB observable and explainable.</p> <p>This document ensures that: - Visibility never alters behavior - Explanation never diverges from reality - UI never becomes a control surface - Trust is increased, not compromised</p> <p>Phase 4 invariants are additive constraints on top of all earlier-phase invariants.</p>"},{"location":"DX_INVARIANTS/#2-phase-4-scope-invariant","title":"2. Phase 4 Scope Invariant","text":""},{"location":"DX_INVARIANTS/#p4-1-zero-semantic-authority","title":"P4-1: Zero Semantic Authority","text":"<p>Phase 4 components: - Have no semantic authority - Cannot create, modify, or influence database state - Cannot affect execution order, timing, or decisions</p> <p>All authoritative behavior remains in Phases 1\u20133.</p>"},{"location":"DX_INVARIANTS/#3-read-only-invariants","title":"3. Read-Only Invariants","text":""},{"location":"DX_INVARIANTS/#p4-2-strict-read-only-surfaces","title":"P4-2: Strict Read-Only Surfaces","text":"<p>All Phase 4 interfaces (APIs, UI, tools):</p> <ul> <li>MUST be read-only</li> <li>MUST reject any mutation attempt</li> <li>MUST NOT expose write, admin, or control endpoints</li> </ul> <p>There is no \u201csafe write\u201d exception.</p>"},{"location":"DX_INVARIANTS/#p4-3-no-side-effect-reads","title":"P4-3: No Side-Effect Reads","text":"<p>Observability reads MUST NOT: - Allocate unbounded memory - Trigger background work - Trigger lazy computation that persists state - Trigger compaction, cleanup, or refresh logic</p> <p>If a read causes work, it must be explicitly visible and discardable.</p>"},{"location":"DX_INVARIANTS/#4-passivity-invariants","title":"4. Passivity Invariants","text":""},{"location":"DX_INVARIANTS/#p4-4-observability-passivity","title":"P4-4: Observability Passivity","text":"<p>Phase 4 components MUST NOT: - Influence scheduling - Influence batching - Influence WAL behavior - Influence MVCC visibility - Influence replication flow</p> <p>Removing all Phase 4 code must produce bit-for-bit identical behavior.</p>"},{"location":"DX_INVARIANTS/#p4-5-no-feedback-loops","title":"P4-5: No Feedback Loops","text":"<p>Phase 4 MUST NOT: - Use metrics to tune behavior - Use UI state to gate execution - Use access patterns to optimize internals</p> <p>There are no adaptive or reactive systems in Phase 4.</p>"},{"location":"DX_INVARIANTS/#5-determinism-invariants","title":"5. Determinism Invariants","text":""},{"location":"DX_INVARIANTS/#p4-6-deterministic-observation","title":"P4-6: Deterministic Observation","text":"<p>Given identical database state:</p> <ul> <li>Observability outputs MUST be identical</li> <li>Explanation outputs MUST be identical</li> <li>UI representations MUST be stable</li> </ul> <p>Non-deterministic output is a correctness bug.</p>"},{"location":"DX_INVARIANTS/#p4-7-snapshot-bound-observation","title":"P4-7: Snapshot-Bound Observation","text":"<p>All Phase 4 reads MUST: - Be explicitly snapshot-bound - Declare which CommitId or snapshot they observe - Never mix state across snapshots implicitly</p> <p>If state is mixed, it must be explicit.</p>"},{"location":"DX_INVARIANTS/#6-explanation-integrity-invariants","title":"6. Explanation Integrity Invariants","text":""},{"location":"DX_INVARIANTS/#p4-8-no-heuristic-explanations","title":"P4-8: No Heuristic Explanations","text":"<p>Explanations MUST: - Reflect real execution - Be derived from actual data - Avoid summaries that infer intent</p> <p>Forbidden: - \u201cLikely because\u2026\u201d - \u201cProbably due to\u2026\u201d - \u201cOptimized path chosen\u2026\u201d</p> <p>If an explanation cannot be exact, it must say:</p> <p>\u201cThis cannot be explained precisely.\u201d</p>"},{"location":"DX_INVARIANTS/#p4-9-explanation-evidence","title":"P4-9: Explanation = Evidence","text":"<p>Every explanation MUST: - Reference concrete state (CommitId, WAL offset, snapshot id) - Be traceable to internal structures - Be verifiable by re-running the system</p> <p>Explanations are evidence, not documentation.</p>"},{"location":"DX_INVARIANTS/#7-failure-visibility-invariants","title":"7. Failure Visibility Invariants","text":""},{"location":"DX_INVARIANTS/#p4-10-failure-transparency","title":"P4-10: Failure Transparency","text":"<p>When failures occur:</p> <ul> <li>Phase 4 MUST expose:</li> <li>Where the failure occurred</li> <li>Which invariant was violated</li> <li>What state was preserved</li> <li>Phase 4 MUST NOT:</li> <li>Mask failures</li> <li>Collapse error categories</li> <li>Replace errors with generic messages</li> </ul> <p>Failure visibility is mandatory.</p>"},{"location":"DX_INVARIANTS/#p4-11-recovery-explainability","title":"P4-11: Recovery Explainability","text":"<p>After recovery:</p> <ul> <li>Phase 4 MUST show:</li> <li>Recovery start point</li> <li>WAL replay range</li> <li>Snapshot or checkpoint used</li> <li>Final consistency result</li> </ul> <p>If recovery cannot be explained, Phase 4 is incomplete.</p>"},{"location":"DX_INVARIANTS/#8-ui-specific-invariants","title":"8. UI-Specific Invariants","text":""},{"location":"DX_INVARIANTS/#p4-12-ui-is-not-a-control-plane","title":"P4-12: UI Is Not a Control Plane","text":"<p>The UI MUST NOT: - Trigger operations - Start checkpoints - Trigger backups - Modify configuration - Influence runtime behavior</p> <p>The UI is a viewer, not an operator.</p>"},{"location":"DX_INVARIANTS/#p4-13-ui-fidelity-over-friendliness","title":"P4-13: UI Fidelity Over Friendliness","text":"<p>The UI MUST: - Prefer accuracy over simplicity - Show raw identifiers (CommitId, WAL seq) - Avoid hiding complexity</p> <p>If something is complex, it should look complex.</p>"},{"location":"DX_INVARIANTS/#9-security-trust-invariants","title":"9. Security &amp; Trust Invariants","text":""},{"location":"DX_INVARIANTS/#p4-14-no-false-sense-of-safety","title":"P4-14: No False Sense of Safety","text":"<p>Phase 4 MUST NOT: - Imply production readiness - Imply security guarantees - Hide dangerous states</p> <p>If something is unsafe, Phase 4 must show it plainly.</p>"},{"location":"DX_INVARIANTS/#10-performance-invariants","title":"10. Performance Invariants","text":""},{"location":"DX_INVARIANTS/#p4-15-observability-overhead-is-explicit","title":"P4-15: Observability Overhead Is Explicit","text":"<p>Any performance overhead introduced by Phase 4 MUST: - Be measurable - Be attributable - Be bounded</p> <p>Hidden overhead is forbidden.</p>"},{"location":"DX_INVARIANTS/#11-disablement-invariants","title":"11. Disablement Invariants","text":""},{"location":"DX_INVARIANTS/#p4-16-complete-removability","title":"P4-16: Complete Removability","text":"<p>Phase 4 MUST be fully disableable:</p> <ul> <li>At compile time, or</li> <li>At startup</li> </ul> <p>Disabling Phase 4 MUST: - Require no migration - Require no data changes - Require no behavior changes</p>"},{"location":"DX_INVARIANTS/#12-invariant-enforcement","title":"12. Invariant Enforcement","text":"<p>Every Phase 4 component MUST:</p> <ul> <li>Explicitly list which Phase 4 invariants it touches</li> <li>Prove compliance</li> <li>Include tests that verify passivity</li> </ul> <p>Violation of any Phase 4 invariant is a blocking defect.</p>"},{"location":"DX_INVARIANTS/#13-invariant-precedence","title":"13. Invariant Precedence","text":"<p>If Phase 4 invariants conflict with:</p> <ul> <li>Phase 1\u20133 invariants \u2192 Phase 4 loses</li> <li>Performance goals \u2192 Phase 4 loses</li> <li>UI convenience \u2192 Phase 4 loses</li> </ul> <p>Visibility never outranks correctness.</p>"},{"location":"DX_INVARIANTS/#14-final-rule","title":"14. Final Rule","text":"<p>Phase 4 may explain everything \u2014 but it may change nothing.</p> <p>If Phase 4 alters behavior, it has already failed.</p> <p>END OF DOCUMENT</p>"},{"location":"DX_OBSERVABILITY_API/","title":"OBSERVABILITY API \u2014 PHASE 4","text":""},{"location":"DX_OBSERVABILITY_API/#status","title":"Status","text":"<ul> <li>Phase: 4</li> <li>Authority: Normative</li> <li>Scope: Read-only observability and explanation APIs</li> <li>Depends on:</li> <li>PHASE4_VISION.md</li> <li>PHASE4_INVARIANTS.md</li> <li>INVARIANTS.md</li> <li>PERFORMANCE_OBSERVABILITY.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> </ul> <p>This document defines the only permitted external observability surface for AeroDB in Phase 4.</p> <p>If a state is not exposed here, it MUST NOT be exposed elsewhere.</p>"},{"location":"DX_OBSERVABILITY_API/#1-purpose","title":"1. Purpose","text":"<p>The Observability API exists to:</p> <ul> <li>Expose internal state truthfully</li> <li>Allow developers to inspect correctness</li> <li>Enable explanation of behavior and failures</li> <li>Support a read-only admin UI</li> </ul> <p>The API is not: - A control plane - A management interface - A mutation surface - A production admin API</p>"},{"location":"DX_OBSERVABILITY_API/#2-core-principles","title":"2. Core Principles","text":""},{"location":"DX_OBSERVABILITY_API/#oapi-1-read-only-absoluteness","title":"OAPI-1: Read-Only Absoluteness","text":"<ul> <li>All endpoints are strictly read-only</li> <li>No endpoint may cause mutation</li> <li>No endpoint may trigger background work</li> <li>No endpoint may influence scheduling</li> </ul> <p>If an endpoint cannot be implemented without side effects, it is invalid.</p>"},{"location":"DX_OBSERVABILITY_API/#oapi-2-snapshot-explicit-semantics","title":"OAPI-2: Snapshot-Explicit Semantics","text":"<p>Every response MUST clearly state: - Which snapshot it observes - The CommitId boundary - Whether the snapshot is stable or live</p> <p>No implicit snapshot context is allowed.</p>"},{"location":"DX_OBSERVABILITY_API/#oapi-3-deterministic-responses","title":"OAPI-3: Deterministic Responses","text":"<p>Given identical database state and identical request parameters:</p> <ul> <li>Responses MUST be identical</li> <li>Ordering MUST be stable</li> <li>Output MUST be reproducible</li> </ul> <p>Non-determinism is a correctness violation.</p>"},{"location":"DX_OBSERVABILITY_API/#3-api-shape-transport","title":"3. API Shape &amp; Transport","text":""},{"location":"DX_OBSERVABILITY_API/#31-transport","title":"3.1 Transport","text":"<ul> <li>HTTP (local only)</li> <li>JSON responses</li> <li>UTF-8 encoding</li> </ul> <p>Transport choice is non-authoritative. Semantics are authoritative.</p>"},{"location":"DX_OBSERVABILITY_API/#32-versioning","title":"3.2 Versioning","text":"<ul> <li>API is versioned explicitly: <code>/v1/...</code></li> <li>Version changes require explicit spec update</li> <li>No silent backward-incompatible changes</li> </ul>"},{"location":"DX_OBSERVABILITY_API/#4-global-response-envelope","title":"4. Global Response Envelope","text":"<p>All responses MUST follow this structure:</p> <pre><code>{\n  \"api_version\": \"v1\",\n  \"observed_at\": {\n    \"snapshot\": \"explicit | live\",\n    \"commit_id\": 12345\n  },\n  \"data\": { ... },\n  \"notes\": [ \"optional explanatory strings\" ]\n}\n````\n\nRules:\n\n* `observed_at` is mandatory\n* `notes` MUST NOT include heuristics\n* All numeric identifiers are raw, not prettified\n\n---\n\n## 5. Core Endpoints (Mandatory)\n\n### 5.1 `/v1/status`\n\n**Purpose:** Overall database state\n\nReturns:\n\n* Lifecycle state (booting, running, recovering)\n* Current CommitId high-water mark\n* WAL durability boundary\n* Phase enablement flags (Phase 4 enabled/disabled)\n\nMust NOT:\n\n* Trigger refresh\n* Probe liveness indirectly\n\n---\n\n### 5.2 `/v1/wal`\n\n**Purpose:** Inspect WAL state\n\nReturns:\n\n* WAL file identifiers\n* Current append offset\n* Last durable offset\n* Checksum status\n* Truncation point (if any)\n\nAll offsets are raw integers.\n\n---\n\n### 5.3 `/v1/mvcc`\n\n**Purpose:** Inspect MVCC state\n\nReturns:\n\n* Oldest retained CommitId\n* Latest committed CommitId\n* Active snapshots (count + IDs)\n* GC watermark (if applicable)\n\nMust NOT:\n\n* Trigger GC\n* Trigger snapshot creation\n\n---\n\n### 5.4 `/v1/snapshots`\n\n**Purpose:** Snapshot visibility\n\nReturns:\n\n* List of active snapshots\n* CommitId each snapshot observes\n* Snapshot source (user, internal, recovery)\n\nSnapshots are informational only.\n\n---\n\n### 5.5 `/v1/checkpoints`\n\n**Purpose:** Checkpoint state\n\nReturns:\n\n* Last completed checkpoint CommitId\n* Checkpoint durability status\n* WAL range covered\n* Pending or aborted checkpoint info (if any)\n\n---\n\n### 5.6 `/v1/indexes`\n\n**Purpose:** Index health and coverage\n\nReturns:\n\n* Index identifiers\n* Index type\n* Build status\n* Entry counts\n* Rebuild progress (if rebuilding)\n\nIndexes remain advisory.\n\n---\n\n### 5.7 `/v1/replication` (Conditional)\n\n**Purpose:** Replication state (if enabled)\n\nReturns:\n\n* Role (primary / replica)\n* WAL prefix position\n* Replica lag (CommitId-based)\n* Snapshot bootstrap state\n\nMust NOT:\n\n* Attempt to contact peers\n* Infer health heuristically\n\n---\n\n## 6. Explanation Endpoints (Derived, Mandatory)\n\n### 6.1 `/v1/explain/query`\n\n**Purpose:** Explain query execution\n\nInput:\n\n* Query (read-only)\n* Optional snapshot CommitId\n\nReturns:\n\n* Deterministic execution plan\n* Index usage (if any)\n* Snapshot used\n* Bounds applied\n\nNo execution is performed unless explicitly allowed.\n\n---\n\n### 6.2 `/v1/explain/read`\n\n**Purpose:** Explain why a document version is visible\n\nInput:\n\n* Document identifier\n* Snapshot CommitId\n\nReturns:\n\n* Version chain\n* CommitId comparisons\n* Visibility decision\n\nThis endpoint is critical for MVCC trust.\n\n---\n\n### 6.3 `/v1/explain/recovery`\n\n**Purpose:** Explain last recovery\n\nReturns:\n\n* Crash detection point\n* Snapshot chosen\n* WAL replay range\n* Validation steps\n* Final state summary\n\nIf recovery has not occurred, return empty explanation.\n\n---\n\n## 7. Forbidden Endpoints\n\nThe following are explicitly forbidden:\n\n* `/write`\n* `/admin`\n* `/config/set`\n* `/gc/run`\n* `/checkpoint/run`\n* `/backup/start`\n* Any endpoint that mutates state\n\nIf a UI needs it, Phase 4 design is wrong.\n\n---\n\n## 8. Error Model\n\nErrors MUST:\n\n* Be explicit\n* Reference internal error codes\n* Include invariant identifiers where applicable\n\nExample:\n\n```json\n{\n  \"error\": {\n    \"code\": \"MVCC_VISIBILITY_VIOLATION\",\n    \"invariant\": \"MVCC-1\",\n    \"message\": \"Requested snapshot observes uncommitted version\"\n  }\n}\n</code></pre> <p>No generic errors allowed.</p>"},{"location":"DX_OBSERVABILITY_API/#9-performance-safety-guarantees","title":"9. Performance &amp; Safety Guarantees","text":"<ul> <li>All endpoints are bounded</li> <li>Large responses must be explicitly paginated</li> <li>No endpoint may scan unbounded state implicitly</li> </ul> <p>If inspection is expensive, that cost must be visible.</p>"},{"location":"DX_OBSERVABILITY_API/#10-disablement-rules","title":"10. Disablement Rules","text":"<ul> <li>Entire Observability API MUST be disableable</li> <li> <p>Disablement MUST:</p> </li> <li> <p>Remove HTTP listeners</p> </li> <li>Remove handlers</li> <li>Leave core system untouched</li> </ul> <p>API disablement MUST NOT affect behavior.</p>"},{"location":"DX_OBSERVABILITY_API/#11-testing-requirements","title":"11. Testing Requirements","text":"<p>The Observability API MUST be tested for:</p> <ul> <li>Read-only enforcement</li> <li>Snapshot correctness</li> <li>Deterministic output</li> <li>Disablement equivalence</li> <li>Crash and recovery transparency</li> </ul> <p>Any test requiring state mutation invalidates the endpoint.</p>"},{"location":"DX_OBSERVABILITY_API/#12-final-rule","title":"12. Final Rule","text":"<p>If the Observability API can change the system, it is not observability \u2014 it is control.</p> <p>Phase 4 succeeds only if every endpoint can be removed without changing AeroDB\u2019s behavior.</p> <p>END OF DOCUMENT</p>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/","title":"DX_OBSERVABILITY_PRINCIPLES.md \u2014 Phase 4 Observability Principles","text":"<p>This document defines the authoritative observability surface of AeroDB Phase 1.</p> <p>Observability exists to ensure that:</p> <ul> <li>operators can understand system state</li> <li>failures are diagnosable</li> <li>recovery is auditable</li> <li>performance regressions are visible</li> </ul> <p>If implementation behavior conflicts with this document, the implementation is wrong.</p> <p>Observability is explicit and synchronous.</p> <p>No background telemetry.</p> <p>No opaque metrics.</p>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#1-principles","title":"1. Principles","text":"<p>AeroDB observability follows strict rules:</p> <ol> <li>Explicit over implicit</li> <li>Deterministic over heuristic</li> <li>Operator-visible over internal-only</li> <li>Failures are loud</li> <li>No hidden background reporting</li> <li>No sampling</li> <li>No aggregation that hides raw values</li> </ol> <p>All metrics are exact.</p> <p>All events are logged.</p>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#2-observability-surfaces","title":"2. Observability Surfaces","text":"<p>Phase 1 exposes observability through:</p> <ol> <li>Startup logs (stdout/stderr)</li> <li>Runtime event logs (stdout)</li> <li><code>aerodb stats</code> command</li> <li>Exit codes</li> <li>Explicit corruption messages</li> </ol> <p>There is no HTTP metrics endpoint in Phase 1.</p>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#3-startup-logging","title":"3. Startup Logging","text":"<p>On every startup, AeroDB MUST log:</p> <pre><code>AERODB_STARTUP_BEGIN\n</code></pre> <p>Followed by:</p>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#configuration","title":"Configuration","text":"<pre><code>CONFIG_LOADED\ndata_dir=&lt;path&gt;\nwal_sync_mode=fsync\nmax_wal_size_bytes=&lt;value&gt;\nmax_memory_bytes=&lt;value&gt;\n</code></pre>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#schema-load","title":"Schema Load","text":"<pre><code>SCHEMAS_LOADED\nschema_count=&lt;n&gt;\n</code></pre>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#recovery","title":"Recovery","text":"<pre><code>RECOVERY_BEGIN\n</code></pre> <p>Then:</p> <pre><code>WAL_REPLAY_BEGIN\nwal_records=&lt;count&gt;\n</code></pre> <p>After replay:</p> <pre><code>WAL_REPLAY_COMPLETE\n</code></pre>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#index-rebuild","title":"Index Rebuild","text":"<pre><code>INDEX_REBUILD_BEGIN\n</code></pre> <p>Then:</p> <pre><code>INDEX_REBUILD_COMPLETE\nindex_count=&lt;n&gt;\n</code></pre>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#verification","title":"Verification","text":"<pre><code>VERIFICATION_BEGIN\n</code></pre> <p>Then:</p> <pre><code>VERIFICATION_COMPLETE\n</code></pre>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#serving","title":"Serving","text":"<pre><code>AERODB_SERVING\n</code></pre> <p>Only after this log may the system accept requests.</p>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#4-runtime-event-logging","title":"4. Runtime Event Logging","text":"<p>Each operation MUST log:</p>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#writes","title":"Writes","text":"<pre><code>WRITE_BEGIN op=insert|update|delete id=&lt;doc_id&gt;\nWRITE_COMMIT\n</code></pre>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#queries","title":"Queries","text":"<pre><code>QUERY_BEGIN\nQUERY_COMPLETE rows=&lt;n&gt;\n</code></pre>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#explain","title":"Explain","text":"<pre><code>EXPLAIN_BEGIN\nEXPLAIN_COMPLETE\n</code></pre> <p>Logs are synchronous.</p> <p>No buffering.</p>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#5-stats-command","title":"5. Stats Command","text":"<p>Operators may query live state:</p> <p><pre><code>aerodb stats --config aerodb.json\n\n````\n\nReturns JSON:\n\n```json\n{\n  \"documents\": 1234,\n  \"schemas\": 2,\n  \"indexes\": 3,\n  \"wal_bytes\": 45678,\n  \"snapshot_count\": 1,\n  \"last_checkpoint\": \"2026-02-04T11:30:00Z\",\n  \"recovery_duration_ms\": 812,\n  \"uptime_seconds\": 120\n}\n````\n\n---\n\n### Metric Definitions\n\n| Field                | Meaning             |\n| -------------------- | ------------------- |\n| documents            | Live document count |\n| schemas              | Registered schemas  |\n| indexes              | Active indexes      |\n| wal_bytes            | Current WAL size    |\n| snapshot_count       | Valid snapshots     |\n| last_checkpoint      | Timestamp           |\n| recovery_duration_ms | Last boot recovery  |\n| uptime_seconds       | Since last start    |\n\nAll values are exact.\n\n---\n\n## 6. Corruption Visibility\n\nOn any corruption:\n\n* explicit log printed\n* error code returned\n* process exits\n\nExample:\n</code></pre> FATAL AERO_DATA_CORRUPTION wal_entry=128 checksum_expected=abcd checksum_found=dead <pre><code>No retry.\n\nNo masking.\n\n---\n\n## 7. Checkpoint Observability\n\nCheckpoint emits:\n</code></pre> CHECKPOINT_BEGIN SNAPSHOT_CREATED id= WAL_TRUNCATED CHECKPOINT_COMPLETE <pre><code>Any failure emits:\n</code></pre> CHECKPOINT_FAILED reason= <pre><code>---\n\n## 8. Backup Observability\n\nBackup emits:\n</code></pre> BACKUP_BEGIN BACKUP_COMPLETE output= <pre><code>Failure:\n</code></pre> BACKUP_FAILED <pre><code>---\n\n## 9. Restore Observability\n\nRestore emits:\n</code></pre> RESTORE_BEGIN RESTORE_COMPLETE <pre><code>Failure:\n</code></pre> RESTORE_FAILED ```"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#10-determinism","title":"10. Determinism","text":"<p>Observability must not introduce:</p> <ul> <li>timestamps inside internal state</li> <li>nondeterministic ordering</li> <li>randomness</li> </ul> <p>Logs may include wall-clock timestamps, but never affect execution.</p>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#11-phase-1-limitations","title":"11. Phase-1 Limitations","text":"<p>Phase 1 does NOT include:</p> <ul> <li>Prometheus</li> <li>OpenTelemetry</li> <li>structured logging frameworks</li> <li>tracing</li> </ul> <p>These belong to Phase 2+.</p>"},{"location":"DX_OBSERVABILITY_PRINCIPLES/#12-authority","title":"12. Authority","text":"<p>This document governs:</p> <ul> <li>startup logging</li> <li>runtime logs</li> <li>stats output</li> <li>corruption visibility</li> <li>checkpoint reporting</li> <li>backup reporting</li> <li>restore reporting</li> </ul> <p>Violations are correctness bugs.</p>"},{"location":"DX_VISION/","title":"PHASE 4 \u2014 DEVELOPER EXPERIENCE &amp; VISIBILITY","text":""},{"location":"DX_VISION/#status","title":"Status","text":"<ul> <li>Phase: 4</li> <li>State: Design-first</li> <li>Authority: Normative</li> <li>Depends on:</li> <li>Phase 1 \u2014 Core Storage (Frozen)</li> <li>Phase 2 \u2014 MVCC &amp; Replication Semantics (Frozen)</li> <li>Phase 3 \u2014 Performance (Frozen)</li> </ul> <p>Phase 4 introduces no new database semantics. It exists to make AeroDB observable, explorable, and trustworthy.</p>"},{"location":"DX_VISION/#1-purpose-of-phase-4","title":"1. Purpose of Phase 4","text":"<p>Phase 4 exists to solve a single problem:</p> <p>AeroDB is correct \u2014 but invisible.</p> <p>This phase makes AeroDB: - Understandable - Inspectable - Auditable - Demonstrable</p> <p>Without making it: - Less correct - Less deterministic - Less explicit</p> <p>Phase 4 is about developer trust, not features.</p>"},{"location":"DX_VISION/#2-core-principle","title":"2. Core Principle","text":""},{"location":"DX_VISION/#the-glass-box-principle","title":"The Glass Box Principle","text":"<p>AeroDB must behave like a glass box, not a black box.</p> <p>This means: - Every decision can be observed - Every invariant can be inspected - Every recovery can be explained - Every failure has a visible reason</p> <p>Phase 4 does not simplify the system. It makes the system legible.</p>"},{"location":"DX_VISION/#3-explicit-non-goals","title":"3. Explicit Non-Goals","text":"<p>Phase 4 does NOT include:</p> <ul> <li>New query capabilities</li> <li>New storage features</li> <li>New consistency levels</li> <li>New performance optimizations</li> <li>New replication semantics</li> <li>Production authentication or authorization</li> <li>Multi-tenant UI</li> <li>Hosted or cloud features</li> </ul> <p>If it changes data behavior, it does not belong in Phase 4.</p>"},{"location":"DX_VISION/#4-what-phase-4-introduces","title":"4. What Phase 4 Introduces","text":"<p>Phase 4 introduces read-only introspection surfaces.</p>"},{"location":"DX_VISION/#41-observability-apis-read-only","title":"4.1 Observability APIs (Read-Only)","text":"<p>AeroDB exposes internal state via explicit, deterministic APIs.</p> <p>These APIs allow inspection of: - WAL state - MVCC state - Snapshot and checkpoint state - Index state - Replication state (if enabled) - Lifecycle and recovery events</p> <p>These APIs: - Never mutate state - Never influence execution - Never alter scheduling - Never bypass invariants</p> <p>Observability remains passive.</p>"},{"location":"DX_VISION/#42-developer-ui-local-read-only","title":"4.2 Developer UI (Local, Read-Only)","text":"<p>A minimal UI that: - Runs locally - Connects to observability APIs - Visualizes internal state</p> <p>The UI exists to: - Teach how AeroDB works - Prove correctness properties - Make failures understandable</p> <p>The UI is not a database client. It is an inspection tool.</p>"},{"location":"DX_VISION/#43-deterministic-explanation-surfaces","title":"4.3 Deterministic Explanation Surfaces","text":"<p>Phase 4 introduces explanation artifacts, such as: - Query execution plans - MVCC visibility explanations - Recovery step traces - Checkpoint and WAL progression</p> <p>These explanations: - Are deterministic - Are derived from real execution - Are not heuristic summaries</p>"},{"location":"DX_VISION/#5-phase-4-trust-model","title":"5. Phase 4 Trust Model","text":"<p>Phase 4 assumes: - Single-node usage - Local developer environment - Trusted user - Debug / inspection context</p> <p>Security hardening is out of scope for this phase.</p>"},{"location":"DX_VISION/#6-phase-4-architecture-boundaries","title":"6. Phase 4 Architecture Boundaries","text":"<p>Phase 4 components MUST obey:</p> <ul> <li>No background tasks that affect correctness</li> <li>No polling loops that alter timing</li> <li>No UI-driven behavior changes</li> <li>No conditional logic based on observability</li> </ul> <p>Removing Phase 4 must leave AeroDB behavior unchanged.</p>"},{"location":"DX_VISION/#7-phase-4-deliverables","title":"7. Phase 4 Deliverables","text":""},{"location":"DX_VISION/#71-required-documents","title":"7.1 Required Documents","text":"<p>Phase 4 will introduce:</p> <ul> <li><code>PHASE4_VISION.md</code> (this document)</li> <li><code>PHASE4_INVARIANTS.md</code></li> <li><code>OBSERVABILITY_API.md</code></li> <li><code>ADMIN_UI_ARCHITECTURE.md</code></li> <li><code>EXPLANATION_MODEL.md</code></li> </ul> <p>No implementation begins without these.</p>"},{"location":"DX_VISION/#72-required-capabilities","title":"7.2 Required Capabilities","text":"<p>By the end of Phase 4, a developer must be able to:</p> <ul> <li>See current WAL position and durability boundary</li> <li>Inspect MVCC commit ranges and snapshots</li> <li>Understand why a read sees a given version</li> <li>See recovery steps after a crash</li> <li>Verify checkpoint safety</li> <li>Observe replica safety (if enabled)</li> </ul> <p>Without reading the code.</p>"},{"location":"DX_VISION/#8-phase-4-invariants","title":"8. Phase 4 Invariants","text":"<p>Phase 4 MUST preserve:</p> <ul> <li>All Phase 1 invariants</li> <li>All MVCC invariants</li> <li>All replication invariants</li> <li>All Phase 3 performance invariants</li> </ul> <p>Additionally:</p> <ul> <li>Observability MUST be passive</li> <li>UI MUST be read-only</li> <li>Explanations MUST reflect reality</li> <li>No synthetic or inferred state is allowed</li> </ul> <p>If something cannot be explained truthfully, it must not be shown.</p>"},{"location":"DX_VISION/#9-phase-4-success-criteria","title":"9. Phase 4 Success Criteria","text":"<p>Phase 4 is successful if:</p> <ul> <li>A new developer can understand AeroDB by exploring it</li> <li>A crash can be explained visually and textually</li> <li>MVCC behavior can be reasoned about without reading code</li> <li>Trust is earned through transparency, not claims</li> </ul> <p>Performance impact is irrelevant. Correctness visibility is everything.</p>"},{"location":"DX_VISION/#10-phase-4-failure-modes","title":"10. Phase 4 Failure Modes","text":"<p>Phase 4 fails if:</p> <ul> <li>UI hides complexity instead of exposing it</li> <li>Observability changes execution behavior</li> <li>Explanations are approximate or heuristic</li> <li>The system becomes harder to reason about</li> </ul> <p>If visibility introduces ambiguity, Phase 4 must be rolled back.</p>"},{"location":"DX_VISION/#11-guiding-statement","title":"11. Guiding Statement","text":"<p>Phase 4 does not make AeroDB easier by hiding reality. It makes AeroDB usable by revealing reality.</p> <p>AeroDB\u2019s advantage is not speed. It is explainability under failure.</p> <p>Phase 4 exists to prove that.</p> <p>END OF DOCUMENT</p>"},{"location":"FAILOVER_ARCHITECTURE/","title":"FAILOVER_ARCHITECTURE.md \u2014 Failover &amp; Promotion","text":""},{"location":"FAILOVER_ARCHITECTURE/#status","title":"Status","text":"<ul> <li>Phase: 6</li> <li>Authority: Normative</li> <li>Depends on:</li> <li>FAILOVER_VISION.md</li> <li>FAILOVER_SCOPE.md</li> <li>FAILOVER_INVARIANTS.md</li> <li>Frozen Dependencies: Phases 0\u20135</li> </ul>"},{"location":"FAILOVER_ARCHITECTURE/#1-purpose","title":"1. Purpose","text":"<p>This document defines the logical architecture for Phase 6.</p> <p>It specifies: - New logical components - Authority boundaries - Interaction points with frozen subsystems</p> <p>It does not define: - Concrete data structures - Algorithms - APIs - Performance optimizations</p> <p>Architecture here is descriptive, not prescriptive.</p>"},{"location":"FAILOVER_ARCHITECTURE/#2-architectural-principle","title":"2. Architectural Principle","text":"<p>Phase 6 architecture follows one rule:</p> <p>Failover logic observes and validates existing state; it does not create new authority sources.</p> <p>All authoritative state remains governed by: - WAL - Replication state (Phase 5) - Recovery logic (Phase 0\u20135)</p> <p>Phase 6 introduces decision logic, not new truth.</p>"},{"location":"FAILOVER_ARCHITECTURE/#3-new-logical-components","title":"3. New Logical Components","text":"<p>Phase 6 introduces the following logical-only components.</p>"},{"location":"FAILOVER_ARCHITECTURE/#31-promotion-controller","title":"3.1 Promotion Controller","text":"<p>Responsibility - Coordinates promotion attempts - Orchestrates validation and decision flow - Emits observability and explanation data</p> <p>Non-Responsibilities - Does not write WAL - Does not modify replication protocol - Does not infer liveness - Does not retry automatically</p> <p>The Promotion Controller is purely coordinating.</p>"},{"location":"FAILOVER_ARCHITECTURE/#32-promotion-validator","title":"3.2 Promotion Validator","text":"<p>Responsibility - Evaluates whether promotion is allowed - Validates all Phase 6 safety invariants - Produces an explicit allow/deny decision</p> <p>Inputs - Replica replication state - WAL position and metadata - Known primary authority state</p> <p>Outputs - Deterministic validation result - Explicit failure reasons if denied</p> <p>Validator logic MUST be: - Deterministic - Side-effect free - Fully explainable</p>"},{"location":"FAILOVER_ARCHITECTURE/#33-authority-transition-manager","title":"3.3 Authority Transition Manager","text":"<p>Responsibility - Applies an approved authority transition - Ensures atomicity of authority change - Integrates with existing replication state</p> <p>Constraints - Must not overlap authority - Must be crash-safe - Must leave recovery unambiguous</p> <p>This component performs state transition only after validation succeeds.</p>"},{"location":"FAILOVER_ARCHITECTURE/#4-interaction-with-existing-subsystems","title":"4. Interaction with Existing Subsystems","text":""},{"location":"FAILOVER_ARCHITECTURE/#41-replication-subsystem-phase-5","title":"4.1 Replication Subsystem (Phase 5)","text":"<p>Phase 6: - Reads replication role and state - Validates replica readiness - Updates replication role only through allowed transitions</p> <p>Phase 6 MUST NOT: - Modify replication protocol - Introduce new replication states without explicit definition - Alter Phase 5 authority checks</p>"},{"location":"FAILOVER_ARCHITECTURE/#42-wal-recovery-phases-03","title":"4.2 WAL &amp; Recovery (Phases 0\u20133)","text":"<p>Phase 6: - Treats WAL as the sole durability authority - Uses WAL metadata to validate safety - Relies on existing recovery semantics</p> <p>Phase 6 MUST NOT modify WAL: - Add WAL records - Change WAL formats</p> <p>Phase 6 MAY use non-WAL durability for authority transition: - A single fsynced marker file (<code>metadata/authority_transition.marker</code>) - This marker is atomic: present = new authority, absent = old authority - The marker file is the SOLE authority state durability mechanism - This does NOT constitute a new WAL record or format change</p> <p>Phase 6 MUST NOT: - Add recovery-time heuristics</p>"},{"location":"FAILOVER_ARCHITECTURE/#43-mvcc-visibility-phase-2","title":"4.3 MVCC &amp; Visibility (Phase 2)","text":"<p>Phase 6: - Preserves all MVCC visibility rules - Ensures promotion does not alter snapshot semantics</p> <p>Phase 6 MUST NOT: - Reinterpret commit identities - Adjust visibility boundaries - Introduce new MVCC states</p>"},{"location":"FAILOVER_ARCHITECTURE/#44-observability-explanation-phase-4","title":"4.4 Observability &amp; Explanation (Phase 4)","text":"<p>Phase 6: - Emits observability events for promotion attempts - Produces explanation artifacts for decisions</p> <p>Phase 6 MUST NOT: - Use observability data to guide decisions - Introduce feedback loops</p> <p>Observability remains passive.</p>"},{"location":"FAILOVER_ARCHITECTURE/#5-authority-boundaries","title":"5. Authority Boundaries","text":""},{"location":"FAILOVER_ARCHITECTURE/#51-authority-sources-unchanged","title":"5.1 Authority Sources (Unchanged)","text":"<p>The only authoritative sources remain: - WAL - Replication state - Recovery state</p> <p>Phase 6 does not add authority; it rebinds authority explicitly.</p>"},{"location":"FAILOVER_ARCHITECTURE/#52-decision-vs-authority","title":"5.2 Decision vs Authority","text":"<p>Important separation:</p> <ul> <li>Decision: Phase 6 logic (can approve or deny)</li> <li>Authority: Existing core systems (can commit or reject)</li> </ul> <p>Phase 6 decisions are advisory until applied atomically.</p>"},{"location":"FAILOVER_ARCHITECTURE/#6-crash-recovery-integration","title":"6. Crash &amp; Recovery Integration","text":"<p>Phase 6 architecture MUST ensure:</p> <ul> <li>No partial authority transition is durable</li> <li>Recovery always reconstructs a single authority state</li> <li>Promotion outcomes are unambiguous after restart</li> </ul> <p>All crash safety relies on existing recovery guarantees.</p>"},{"location":"FAILOVER_ARCHITECTURE/#7-explicitly-forbidden-architectural-patterns","title":"7. Explicitly Forbidden Architectural Patterns","text":"<p>Phase 6 MUST NOT introduce:</p> <ul> <li>Background promotion threads</li> <li>Heartbeat-driven logic</li> <li>Time-based transitions</li> <li>Distributed consensus subsystems</li> <li>Hidden shared state between nodes</li> </ul> <p>Any such pattern violates Phase 6 scope.</p>"},{"location":"FAILOVER_ARCHITECTURE/#8-architectural-completeness-criteria","title":"8. Architectural Completeness Criteria","text":"<p>This architecture is complete when:</p> <ul> <li>Every promotion path maps to components above</li> <li>Every failure path has a single handling point</li> <li>No component has mixed authority roles</li> <li>All interactions with frozen phases are read-only or explicit</li> </ul>"},{"location":"FAILOVER_ARCHITECTURE/#9-architectural-stability-rule","title":"9. Architectural Stability Rule","text":"<p>Once Phase 6 is frozen:</p> <p>No new architectural component may be added without a new phase.</p> <p>END OF DOCUMENT</p>"},{"location":"FAILOVER_FAILURE_MODEL/","title":"FAILOVER_FAILURE_MODEL.md \u2014 Failover &amp; Promotion","text":""},{"location":"FAILOVER_FAILURE_MODEL/#status","title":"Status","text":"<ul> <li>Phase: 6</li> <li>Authority: Normative</li> <li>Depends on:</li> <li>FAILOVER_VISION.md</li> <li>FAILOVER_SCOPE.md</li> <li>FAILOVER_INVARIANTS.md</li> <li>FAILOVER_ARCHITECTURE.md</li> <li>Frozen Dependencies: Phases 0\u20135</li> </ul>"},{"location":"FAILOVER_FAILURE_MODEL/#1-purpose","title":"1. Purpose","text":"<p>This document defines the failure model for Phase 6.</p> <p>It specifies: - What failures are assumed possible - Where failures may occur - What outcomes are required - How promotion must behave under failure</p> <p>Phase 6 inherits all failure assumptions from Phases 0\u20135. No assumptions are weakened, removed, or narrowed.</p>"},{"location":"FAILOVER_FAILURE_MODEL/#2-failure-model-continuity","title":"2. Failure Model Continuity","text":"<p>Phase 6 assumes exactly the same failure surface as earlier phases:</p> <ul> <li>Process may crash at any instruction</li> <li>Power loss may occur at any time</li> <li>Disk writes may be partial or reordered</li> <li>fsync is the only durability boundary</li> <li>Memory state is volatile</li> <li>Time is not monotonic across crashes</li> <li>No graceful shutdown is assumed</li> </ul> <p>Phase 6 introduces no new reliability assumptions.</p>"},{"location":"FAILOVER_FAILURE_MODEL/#3-promotion-specific-failure-points","title":"3. Promotion-Specific Failure Points","text":"<p>Promotion introduces new logical failure boundaries.</p> <p>These boundaries must be explicitly handled.</p>"},{"location":"FAILOVER_FAILURE_MODEL/#31-failure-before-promotion-validation","title":"3.1 Failure Before Promotion Validation","text":"<p>Examples - Crash before validation begins - Validation request rejected immediately - Operator aborts request</p> <p>Required Outcome - No authority change - System remains in pre-promotion state - No recovery ambiguity</p>"},{"location":"FAILOVER_FAILURE_MODEL/#32-failure-during-promotion-validation","title":"3.2 Failure During Promotion Validation","text":"<p>Examples - Crash while evaluating WAL position - Crash while checking replica safety - Partial validation execution</p> <p>Required Outcome - Promotion is considered not attempted - No authority transition occurs - On recovery, system behaves as if promotion never started</p> <p>Validation has no durable effect.</p>"},{"location":"FAILOVER_FAILURE_MODEL/#33-failure-after-validation-before-authority-transition","title":"3.3 Failure After Validation, Before Authority Transition","text":"<p>Examples - Crash after validation succeeds - Crash before authority transition is applied</p> <p>Required Outcome - Promotion is not applied - Authority remains unchanged - Validation must be re-run on retry</p> <p>There is no \u201cvalidated but pending\u201d state after recovery.</p>"},{"location":"FAILOVER_FAILURE_MODEL/#34-failure-during-authority-transition","title":"3.4 Failure During Authority Transition","text":"<p>Examples - Crash while updating replication role - Crash while rebinding authority - Crash during atomic transition</p> <p>Required Outcome - Authority transition MUST be atomic - Recovery MUST observe:   - Either the old authority state   - Or the new authority state - Never a mixed or ambiguous state</p> <p>Partial authority transitions are forbidden.</p>"},{"location":"FAILOVER_FAILURE_MODEL/#35-failure-after-authority-transition-completes","title":"3.5 Failure After Authority Transition Completes","text":"<p>Examples - Crash immediately after promotion completes - Crash before observability events are flushed</p> <p>Required Outcome - New authority state is authoritative - Recovery MUST reestablish the promoted primary - Observability gaps are acceptable; authority gaps are not</p>"},{"location":"FAILOVER_FAILURE_MODEL/#4-primary-failure-scenarios","title":"4. Primary Failure Scenarios","text":""},{"location":"FAILOVER_FAILURE_MODEL/#41-primary-crash-before-promotion","title":"4.1 Primary Crash Before Promotion","text":"<p>Scenario - Primary crashes - No promotion attempted yet</p> <p>Required Outcome - System has no writable primary - Replicas remain replicas - Reads obey replica read rules - Writes are rejected</p> <p>Availability loss is acceptable; unsafe promotion is not.</p>"},{"location":"FAILOVER_FAILURE_MODEL/#42-primary-crash-during-promotion-attempt","title":"4.2 Primary Crash During Promotion Attempt","text":"<p>Scenario - Promotion is attempted - Primary crashes mid-process</p> <p>Required Outcome - Promotion outcome depends solely on authority transition completion - No reliance on primary liveness - No automatic retry</p> <p>Promotion safety must be provable without the primary.</p>"},{"location":"FAILOVER_FAILURE_MODEL/#5-replica-failure-scenarios","title":"5. Replica Failure Scenarios","text":""},{"location":"FAILOVER_FAILURE_MODEL/#51-replica-crash-before-promotion","title":"5.1 Replica Crash Before Promotion","text":"<p>Required Outcome - Promotion request fails explicitly - No authority change - No recovery ambiguity</p>"},{"location":"FAILOVER_FAILURE_MODEL/#52-replica-crash-during-promotion","title":"5.2 Replica Crash During Promotion","text":"<p>Required Outcome - Promotion fails or is rolled back - Authority remains unchanged - Recovery is deterministic</p>"},{"location":"FAILOVER_FAILURE_MODEL/#6-split-brain-risk-handling","title":"6. Split-Brain Risk Handling","text":"<p>Phase 6 explicitly does not tolerate split-brain.</p> <p>If: - Authority safety cannot be proven - Primary liveness is ambiguous - Replica divergence is suspected</p> <p>Required Outcome - Promotion MUST be rejected - System MUST fail closed</p> <p>No best-effort behavior is allowed.</p>"},{"location":"FAILOVER_FAILURE_MODEL/#7-network-failure-considerations","title":"7. Network Failure Considerations","text":"<p>Phase 6 assumes: - Network partitions are possible - Messages may be delayed or lost - No reliable membership service exists</p> <p>Phase 6 MUST NOT: - Infer authority from network reachability - Infer primary death from timeouts - Use network health as a promotion signal</p>"},{"location":"FAILOVER_FAILURE_MODEL/#8-deterministic-failure-outcomes","title":"8. Deterministic Failure Outcomes","text":"<p>For any failure scenario: - Outcome MUST be deterministic - Outcome MUST be explainable - Outcome MUST map to Phase 6 invariants</p> <p>Failure handling MUST NOT depend on: - Timing - Retry count - Environmental factors</p>"},{"location":"FAILOVER_FAILURE_MODEL/#9-forbidden-failure-handling","title":"9. Forbidden Failure Handling","text":"<p>Phase 6 MUST NOT: - Retry promotion automatically - Mask failures - Escalate privileges implicitly - Enter degraded authority modes - \u201cGuess\u201d the safest outcome</p> <p>Explicit failure is always preferred.</p>"},{"location":"FAILOVER_FAILURE_MODEL/#10-testing-obligations","title":"10. Testing Obligations","text":"<p>Phase 6 failure handling MUST be validated by:</p> <ul> <li>Crash tests at every promotion boundary</li> <li>Recovery tests for each failure scenario</li> <li>Deterministic replay verification</li> <li>Invariant enforcement tests</li> </ul> <p>All Phase 0\u20135 tests MUST pass unmodified.</p>"},{"location":"FAILOVER_FAILURE_MODEL/#11-failure-model-completeness-rule","title":"11. Failure Model Completeness Rule","text":"<p>The failure model is complete when:</p> <ul> <li>Every promotion boundary is a failure boundary</li> <li>Every failure produces a single valid outcome</li> <li>No recovery ambiguity exists</li> <li>No silent behavior exists</li> </ul> <p>END OF DOCUMENT</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/","title":"FAILOVER_IMPLEMENTATION_ORDER.md \u2014 Failover &amp; Promotion","text":""},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#status","title":"Status","text":"<ul> <li>Phase: 6</li> <li>Authority: Normative</li> <li>Depends on:</li> <li>FAILOVER_VISION.md</li> <li>FAILOVER_SCOPE.md</li> <li>FAILOVER_INVARIANTS.md</li> <li>FAILOVER_ARCHITECTURE.md</li> <li>FAILOVER_FAILURE_MODEL.md</li> <li>FAILOVER_STATE_MACHINE.md</li> <li>FAILOVER_OBSERVABILITY_MAPPING.md</li> <li>FAILOVER_TESTING_STRATEGY.md</li> <li>Frozen Dependencies: Phases 0\u20135</li> </ul>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#1-purpose","title":"1. Purpose","text":"<p>This document defines the strict, linear implementation order for Phase 6.</p> <p>The order exists to: - Preserve correctness - Prevent partial semantics - Ensure testability at every step - Avoid speculative or coupled implementation</p> <p>Stages MUST be completed in order. Skipping, reordering, or merging stages is forbidden.</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#2-global-rules","title":"2. Global Rules","text":"<p>Phase 6 implementation MUST obey:</p> <ol> <li>One stage at a time</li> <li>Each stage ends with tests</li> <li>No stage may weaken a frozen phase</li> <li>No later stage may compensate for an earlier shortcut</li> <li>Failure to complete a stage blocks all subsequent work</li> </ol>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#3-stage-breakdown-authoritative","title":"3. Stage Breakdown (Authoritative)","text":""},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#stage-61-promotion-state-definitions","title":"Stage 6.1 \u2014 Promotion State Definitions","text":"<p>Goal - Introduce Phase 6 promotion states - Integrate them as a distinct, orthogonal state machine</p> <p>Requirements - States exactly as defined in <code>FAILOVER_STATE_MACHINE.md</code> - No implicit transitions - No persistence of transient promotion states</p> <p>Exit Criteria - State machine compiles - State transitions enumerated - Unit tests validate allowed/forbidden transitions</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#stage-62-promotion-request-interface","title":"Stage 6.2 \u2014 Promotion Request Interface","text":"<p>Goal - Define explicit entry point for promotion attempts</p> <p>Requirements - Promotion requests are explicit - No background triggers - No retries - Clear rejection on invalid input</p> <p>Exit Criteria - Promotion request can be issued - Invalid requests rejected deterministically - Unit tests for request validation</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#stage-63-promotion-validation-logic","title":"Stage 6.3 \u2014 Promotion Validation Logic","text":"<p>Goal - Implement Promotion Validator</p> <p>Requirements - Validate all Phase 6 safety invariants - Read-only interaction with replication, WAL, MVCC - Deterministic decision-making</p> <p>Exit Criteria - Validator produces allow/deny decision - Failure reasons map to invariants - Unit tests cover all validation branches</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#stage-64-authority-transition-mechanism","title":"Stage 6.4 \u2014 Authority Transition Mechanism","text":"<p>Goal - Implement atomic authority rebinding</p> <p>Requirements - Single-writer authority preserved - No dual-primary state possible - Crash-safe transition</p> <p>Exit Criteria - Authority transition is atomic - Recovery yields unambiguous authority - Crash tests pass for transition boundaries</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#stage-65-integration-with-replication-state-phase-5","title":"Stage 6.5 \u2014 Integration with Replication State (Phase 5)","text":"<p>Goal - Wire promotion outcomes to replication roles</p> <p>Requirements - Use existing Phase 5 role transitions - No new replication semantics - Explicit role rebinding only</p> <p>Exit Criteria - Promoted replica becomes primary - Old primary loses authority - Phase 5 invariants preserved</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#stage-66-observability-explanation-wiring","title":"Stage 6.6 \u2014 Observability &amp; Explanation Wiring","text":"<p>Goal - Emit Phase 6 observability signals - Generate explanation artifacts</p> <p>Requirements - Events emitted for all promotion states - Explanations deterministic - No observability-driven behavior</p> <p>Exit Criteria - Observability tests pass - Explanation outputs validated</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#stage-67-crash-recovery-validation","title":"Stage 6.7 \u2014 Crash &amp; Recovery Validation","text":"<p>Goal - Validate Phase 6 under crash conditions</p> <p>Requirements - Crash injection at all promotion boundaries - Deterministic recovery - No ambiguous authority state</p> <p>Exit Criteria - All crash tests pass - Recovery behavior audited</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#stage-68-end-to-end-promotion-tests","title":"Stage 6.8 \u2014 End-to-End Promotion Tests","text":"<p>Goal - Validate full promotion lifecycle</p> <p>Requirements - Successful promotion path - Rejected promotion path - Repeated promotion attempts - Disablement behavior</p> <p>Exit Criteria - End-to-end tests pass - No regression in Phases 0\u20135</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#4-stage-completion-rule","title":"4. Stage Completion Rule","text":"<p>A stage is complete only when:</p> <ul> <li>Code compiles</li> <li>Tests pass</li> <li>Invariants are enforced</li> <li>No TODOs remain</li> <li>Behavior is explainable</li> </ul> <p>Incomplete stages MUST NOT be merged.</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#5-implementation-freeze-rule","title":"5. Implementation Freeze Rule","text":"<p>Once all stages are complete:</p> <ul> <li>Phase 6 enters audit</li> <li>No new behavior may be added</li> <li>Only defect fixes allowed</li> </ul> <p>After audit: - Phase 6 is frozen</p>"},{"location":"FAILOVER_IMPLEMENTATION_ORDER/#6-implementation-order-completeness","title":"6. Implementation Order Completeness","text":"<p>This document is complete when: - Every Phase 6 capability maps to a stage - Every stage has exit criteria - No circular dependencies exist</p> <p>END OF DOCUMENT</p>"},{"location":"FAILOVER_INVARIANTS/","title":"FAILOVER_INVARIANTS.md \u2014 Failover &amp; Promotion","text":""},{"location":"FAILOVER_INVARIANTS/#status","title":"Status","text":"<ul> <li>Phase: 6</li> <li>Authority: Normative</li> <li>Depends on:</li> <li>FAILOVER_VISION.md</li> <li>FAILOVER_SCOPE.md</li> <li>Frozen Dependencies: Phases 0\u20135</li> </ul>"},{"location":"FAILOVER_INVARIANTS/#1-purpose","title":"1. Purpose","text":"<p>This document defines the new invariants introduced by Phase 6.</p> <p>These invariants: - Are additive only - Apply only to failover &amp; promotion - MUST NOT weaken, reinterpret, or bypass any invariant from Phases 0\u20135</p> <p>If any Phase 6 behavior violates a Phase 0\u20135 invariant, the behavior is forbidden.</p>"},{"location":"FAILOVER_INVARIANTS/#2-invariant-hierarchy","title":"2. Invariant Hierarchy","text":"<p>Invariant authority order remains unchanged:</p> <ol> <li>Phase 0\u20135 Invariants (Absolute, Frozen)</li> <li>Phase 6 Invariants (Additive, Subordinate)</li> </ol> <p>Phase 6 invariants exist to constrain promotion, not to enable availability.</p>"},{"location":"FAILOVER_INVARIANTS/#3-authority-invariants-phase-6","title":"3. Authority Invariants (Phase 6)","text":""},{"location":"FAILOVER_INVARIANTS/#p6-a1-single-write-authority","title":"P6-A1 \u2014 Single Write Authority","text":"<p>At any point in time: - At most one node may hold write authority - Write authority MUST be explicit and observable</p> <p>No promotion may result in overlapping write authority.</p>"},{"location":"FAILOVER_INVARIANTS/#p6-a1a-force-override-semantics","title":"P6-A1a \u2014 Force Override Semantics","text":"<p>The <code>force</code> flag allows promotion when: - Operator has external confirmation that primary is unavailable - Normal detection mechanisms have failed</p> <p>When <code>force = true</code>: - P6-A1 (single-writer) is NOT bypassed - Operator EXPLICITLY ASSERTS that primary is down - System trusts operator assertion over detection failure - This is NOT an invariant violation but an operator override</p> <p>Misuse of <code>force</code> is an operator error, not a system defect. Audit logs MUST record force flag usage.</p>"},{"location":"FAILOVER_INVARIANTS/#p6-a2-authority-transfer-is-atomic","title":"P6-A2 \u2014 Authority Transfer Is Atomic","text":"<p>Promotion MUST be: - Atomic with respect to authority - All-or-nothing</p> <p>There is no intermediate state where: - Two nodes are writable - Or no node is authoritative after a successful promotion</p>"},{"location":"FAILOVER_INVARIANTS/#p6-a3-no-implicit-authority-claim","title":"P6-A3 \u2014 No Implicit Authority Claim","text":"<p>A node MUST NOT: - Assume primary authority automatically - Infer authority from liveness - Infer authority from timeouts - Infer authority from replica position</p> <p>Authority is granted only via explicit promotion.</p>"},{"location":"FAILOVER_INVARIANTS/#4-safety-invariants-phase-6","title":"4. Safety Invariants (Phase 6)","text":""},{"location":"FAILOVER_INVARIANTS/#p6-s1-no-acknowledged-write-loss","title":"P6-S1 \u2014 No Acknowledged Write Loss","text":"<p>Promotion MUST NOT be allowed if: - Any acknowledged write could be lost - Replica state is provably behind committed WAL</p> <p>This invariant inherits and strengthens: - Phase-1 durability guarantees - Phase-5 replication guarantees</p>"},{"location":"FAILOVER_INVARIANTS/#p6-s2-wal-prefix-rule-preservation","title":"P6-S2 \u2014 WAL Prefix Rule Preservation","text":"<p>A promoted replica MUST: - Have a WAL state that is a prefix-compatible continuation - Preserve commit ordering and identity</p> <p>Promotion MUST NOT introduce: - WAL divergence - Reordered commits - Gaps in committed history</p>"},{"location":"FAILOVER_INVARIANTS/#p6-s3-mvcc-visibility-preservation","title":"P6-S3 \u2014 MVCC Visibility Preservation","text":"<p>After promotion: - All MVCC visibility rules MUST remain valid - No read may observe:   - Partially committed data   - Reordered versions   - Phantom commits</p> <p>Promotion MUST NOT alter snapshot semantics.</p>"},{"location":"FAILOVER_INVARIANTS/#5-failure-invariants-phase-6","title":"5. Failure Invariants (Phase 6)","text":""},{"location":"FAILOVER_INVARIANTS/#p6-f1-fail-closed-not-open","title":"P6-F1 \u2014 Fail Closed, Not Open","text":"<p>If promotion safety cannot be proven: - Promotion MUST be rejected - System MUST NOT guess - System MUST NOT degrade into unsafe availability</p> <p>Explicit failure is preferred over unsafe success.</p>"},{"location":"FAILOVER_INVARIANTS/#p6-f2-promotion-is-crash-safe","title":"P6-F2 \u2014 Promotion Is Crash-Safe","text":"<p>If a crash occurs: - Before promotion completes \u2192 no authority change - After promotion completes \u2192 new authority is authoritative</p> <p>There MUST be no ambiguous authority state after recovery.</p>"},{"location":"FAILOVER_INVARIANTS/#p6-f3-no-automatic-retry","title":"P6-F3 \u2014 No Automatic Retry","text":"<p>Promotion failures: - MUST NOT be retried automatically - MUST require explicit re-attempt</p> <p>This prevents hidden behavior and repeated unsafe attempts.</p>"},{"location":"FAILOVER_INVARIANTS/#6-determinism-invariants-phase-6","title":"6. Determinism Invariants (Phase 6)","text":""},{"location":"FAILOVER_INVARIANTS/#p6-d1-deterministic-promotion-outcome","title":"P6-D1 \u2014 Deterministic Promotion Outcome","text":"<p>Given identical: - Replica state - WAL state - Promotion request</p> <p>The promotion decision MUST be identical.</p> <p>No randomness, timing, or environment influence is allowed.</p>"},{"location":"FAILOVER_INVARIANTS/#p6-d2-deterministic-recovery-outcome","title":"P6-D2 \u2014 Deterministic Recovery Outcome","text":"<p>After crash and recovery: - Authority state MUST be unambiguous - Promotion result MUST be identical to pre-crash intent</p> <p>Recovery MUST NOT \u201cdecide\u201d promotion outcomes.</p>"},{"location":"FAILOVER_INVARIANTS/#7-observability-invariants-phase-6","title":"7. Observability Invariants (Phase 6)","text":""},{"location":"FAILOVER_INVARIANTS/#p6-o1-promotion-is-observable","title":"P6-O1 \u2014 Promotion Is Observable","text":"<p>Every promotion attempt MUST emit: - Start event - Validation result - Final decision (success or failure)</p> <p>Silent promotion is forbidden.</p>"},{"location":"FAILOVER_INVARIANTS/#p6-o2-promotion-is-explainable","title":"P6-O2 \u2014 Promotion Is Explainable","text":"<p>For every promotion decision, the system MUST be able to explain: - Why promotion was allowed or denied - Which invariant permitted or blocked it</p> <p>Explanation is mandatory, not optional.</p>"},{"location":"FAILOVER_INVARIANTS/#8-forbidden-invariant-violations","title":"8. Forbidden Invariant Violations","text":"<p>Phase 6 MUST NOT: - Trade safety for availability - Introduce heuristics - Introduce timing-based decisions - Introduce background authority changes - Override operator intent silently</p> <p>Any such behavior is a correctness violation.</p>"},{"location":"FAILOVER_INVARIANTS/#9-invariant-enforcement-rule","title":"9. Invariant Enforcement Rule","text":"<p>All Phase 6 logic MUST: - Explicitly reference applicable invariants - Fail if invariants cannot be proven - Be covered by tests validating invariant preservation</p> <p>If an invariant cannot be tested, it is incomplete.</p>"},{"location":"FAILOVER_INVARIANTS/#10-exit-condition","title":"10. Exit Condition","text":"<p>Phase 6 invariants are considered complete when: - Every promotion path maps to invariants - Every failure path maps to invariants - No ambiguity exists in authority transitions - All Phase 0\u20135 invariants remain untouched</p> <p>END OF DOCUMENT</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/","title":"FAILOVER_OBSERVABILITY_MAPPING.md \u2014 Failover &amp; Promotion","text":""},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#status","title":"Status","text":"<ul> <li>Phase: 6</li> <li>Authority: Normative</li> <li>Depends on:</li> <li>FAILOVER_VISION.md</li> <li>FAILOVER_SCOPE.md</li> <li>FAILOVER_INVARIANTS.md</li> <li>FAILOVER_ARCHITECTURE.md</li> <li>FAILOVER_FAILURE_MODEL.md</li> <li>FAILOVER_STATE_MACHINE.md</li> <li>Frozen Dependencies: Phase 4 Observability (Frozen)</li> </ul>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#1-purpose","title":"1. Purpose","text":"<p>This document maps Phase 6 behavior to the existing observability and explanation infrastructure.</p> <p>It defines: - What events are emitted - What metrics are exposed - What explanations are available</p> <p>Observability in Phase 6 is passive only. It must never influence control flow or decisions.</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#2-observability-principles-inherited","title":"2. Observability Principles (Inherited)","text":"<p>Phase 6 observability MUST obey all Phase 4 rules:</p> <ul> <li>Side-effect free</li> <li>Deterministic ordering</li> <li>Non-authoritative</li> <li>No feedback loops</li> <li>No gating behavior</li> </ul> <p>Observability describes what happened; it never decides what happens.</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#3-event-emission-mapping","title":"3. Event Emission Mapping","text":"<p>Phase 6 introduces the following new event types.</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#31-promotion-lifecycle-events","title":"3.1 Promotion Lifecycle Events","text":""},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#replicationpromotionrequested","title":"<code>replication.promotion.requested</code>","text":"<p>Emitted when: - A promotion request is accepted for processing</p> <p>Fields: - <code>requested_replica_id</code> - <code>current_primary_id</code> (if known) - <code>reason</code> (operator-provided, optional)</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#replicationpromotionvalidation_started","title":"<code>replication.promotion.validation_started</code>","text":"<p>Emitted when: - Transition to <code>PromotionValidating</code> occurs</p> <p>Fields: - <code>requested_replica_id</code></p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#replicationpromotionvalidation_failed","title":"<code>replication.promotion.validation_failed</code>","text":"<p>Emitted when: - Promotion is denied during validation</p> <p>Fields: - <code>requested_replica_id</code> - <code>failed_invariant</code> - <code>failure_reason</code></p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#replicationpromotionvalidation_succeeded","title":"<code>replication.promotion.validation_succeeded</code>","text":"<p>Emitted when: - Promotion validation completes successfully</p> <p>Fields: - <code>requested_replica_id</code></p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#replicationpromotiontransition_started","title":"<code>replication.promotion.transition_started</code>","text":"<p>Emitted when: - Authority transition begins</p> <p>Fields: - <code>requested_replica_id</code></p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#replicationpromotiontransition_completed","title":"<code>replication.promotion.transition_completed</code>","text":"<p>Emitted when: - Authority transition completes successfully</p> <p>Fields: - <code>new_primary_id</code></p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#32-crash-related-promotion-events","title":"3.2 Crash-Related Promotion Events","text":""},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#replicationpromotionaborted_on_crash","title":"<code>replication.promotion.aborted_on_crash</code>","text":"<p>Emitted on recovery if: - A promotion was in progress but not completed</p> <p>Fields: - <code>last_known_state</code> - <code>requested_replica_id</code> (if known)</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#4-metrics-mapping","title":"4. Metrics Mapping","text":"<p>Phase 6 may expose the following passive metrics.</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#41-counters","title":"4.1 Counters","text":"<ul> <li><code>replication_promotion_requests_total</code></li> <li><code>replication_promotion_success_total</code></li> <li><code>replication_promotion_denied_total</code></li> <li><code>replication_promotion_crash_abort_total</code></li> </ul>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#42-gauges","title":"4.2 Gauges","text":"<ul> <li><code>replication_current_primary</code> (labelled by replica_id)</li> <li><code>replication_promotion_in_progress</code> (0 or 1)</li> </ul>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#43-histograms-optional","title":"4.3 Histograms (Optional)","text":"<ul> <li><code>replication_promotion_validation_duration_ms</code></li> <li><code>replication_promotion_transition_duration_ms</code></li> </ul> <p>Metrics MUST: - Be monotonic where applicable - Never influence behavior - Never be required for correctness</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#5-explanation-engine-integration","title":"5. Explanation Engine Integration","text":"<p>Every promotion attempt MUST produce an explanation artifact.</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#51-explanation-on-success","title":"5.1 Explanation on Success","text":"<p>Explanation MUST include: - Promotion request parameters - Validation checks performed - Invariants satisfied - Authority transition result</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#52-explanation-on-failure","title":"5.2 Explanation on Failure","text":"<p>Explanation MUST include: - Promotion request parameters - Exact invariant violated - Deterministic reason for denial - No speculative or heuristic language</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#53-explanation-stability","title":"5.3 Explanation Stability","text":"<p>Given identical inputs: - Explanation output MUST be identical - Ordering MUST be deterministic - Language MUST be stable</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#6-observability-during-failure","title":"6. Observability During Failure","text":"<p>If observability emission fails: - Promotion behavior MUST NOT change - Promotion MUST NOT be retried - Failure MUST be logged as best-effort only</p> <p>Observability failure is never fatal to correctness.</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#7-forbidden-observability-behavior","title":"7. Forbidden Observability Behavior","text":"<p>Phase 6 MUST NOT: - Block promotion on logging failure - Retry promotion due to metrics - Adapt behavior based on telemetry - Hide or compress failure details</p>"},{"location":"FAILOVER_OBSERVABILITY_MAPPING/#8-completeness-criteria","title":"8. Completeness Criteria","text":"<p>Observability mapping is complete when: - Every Phase 6 state transition emits at least one event - Every promotion attempt is explainable - No observability signal affects decisions - All signals are deterministic and auditable</p> <p>END OF DOCUMENT</p>"},{"location":"FAILOVER_READINESS/","title":"FAILOVER_READINESS.md \u2014 Failover &amp; Promotion","text":""},{"location":"FAILOVER_READINESS/#status","title":"Status","text":"<ul> <li>Phase: 6</li> <li>Authority: Normative</li> <li>Depends on:</li> <li>FAILOVER_VISION.md</li> <li>FAILOVER_SCOPE.md</li> <li>FAILOVER_INVARIANTS.md</li> <li>FAILOVER_ARCHITECTURE.md</li> <li>FAILOVER_FAILURE_MODEL.md</li> <li>FAILOVER_STATE_MACHINE.md</li> <li>FAILOVER_OBSERVABILITY_MAPPING.md</li> <li>FAILOVER_TESTING_STRATEGY.md</li> <li>FAILOVER_IMPLEMENTATION_ORDER.md</li> <li>Frozen Dependencies: Phases 0\u20135</li> </ul>"},{"location":"FAILOVER_READINESS/#1-purpose","title":"1. Purpose","text":"<p>This document defines when Phase 6 is considered complete, auditable, and ready to be frozen.</p> <p>It also defines the launch readiness bar for AeroDB after Phase 6.</p> <p>No implementation may be considered finished without satisfying this document.</p>"},{"location":"FAILOVER_READINESS/#2-definition-of-ready","title":"2. Definition of \u201cReady\u201d","text":"<p>Phase 6 is ready when:</p> <ul> <li>All specified behavior exists</li> <li>All forbidden behavior is absent</li> <li>All invariants are enforced</li> <li>All failures are deterministic</li> <li>All behavior is observable and explainable</li> <li>All frozen-phase guarantees remain intact</li> </ul> <p>\u201cMostly correct\u201d is insufficient.</p>"},{"location":"FAILOVER_READINESS/#3-functional-readiness-criteria","title":"3. Functional Readiness Criteria","text":"<p>Phase 6 MUST provide:</p> <ul> <li>Explicit promotion request capability</li> <li>Deterministic promotion validation</li> <li>Atomic authority transition</li> <li>Explicit promotion denial with explanation</li> <li>Crash-safe recovery with unambiguous authority</li> <li>No automatic or background failover</li> </ul> <p>Every capability must map to: - A spec section - A code path - One or more tests</p>"},{"location":"FAILOVER_READINESS/#4-invariant-readiness-criteria","title":"4. Invariant Readiness Criteria","text":"<p>All Phase 6 invariants MUST be:</p> <ul> <li>Enforced in code</li> <li>Explicitly referenced in validation logic</li> <li>Covered by tests</li> <li>Observable on violation</li> </ul> <p>Additionally: - No Phase 0\u20135 invariant may be weakened - No invariant may be conditionally enforced</p> <p>If any invariant is unverifiable, Phase 6 is not ready.</p>"},{"location":"FAILOVER_READINESS/#5-failure-crash-readiness-criteria","title":"5. Failure &amp; Crash Readiness Criteria","text":"<p>Phase 6 MUST be correct under:</p> <ul> <li>Crash at every promotion boundary</li> <li>Crash during authority transition</li> <li>Crash immediately after promotion success</li> <li>Crash with stale or partial observability data</li> </ul> <p>Required properties: - No dual-primary state - No loss of acknowledged writes - No ambiguous authority after recovery</p> <p>Crash matrices MUST be exhaustive and audited.</p>"},{"location":"FAILOVER_READINESS/#6-determinism-readiness-criteria","title":"6. Determinism Readiness Criteria","text":"<p>Given identical: - WAL state - Replication state - Promotion request parameters</p> <p>The system MUST: - Make the same decision - Produce the same explanation - Recover to the same authority state</p> <p>Any nondeterminism is a blocking defect.</p>"},{"location":"FAILOVER_READINESS/#7-observability-explanation-readiness","title":"7. Observability &amp; Explanation Readiness","text":"<p>Phase 6 MUST:</p> <ul> <li>Emit events for every promotion state transition</li> <li>Produce explanations for every allow/deny outcome</li> <li>Reference violated or satisfied invariants explicitly</li> <li>Preserve deterministic ordering of observability output</li> </ul> <p>Observability gaps are acceptable; authority gaps are not.</p>"},{"location":"FAILOVER_READINESS/#8-testing-audit-readiness","title":"8. Testing &amp; Audit Readiness","text":"<p>Phase 6 is NOT ready unless:</p> <ul> <li>All Phase 6 tests pass</li> <li>All Phase 0\u20135 tests pass unchanged</li> <li>Crash tests cover all promotion boundaries</li> <li>Negative tests prove rejection paths</li> <li>Disablement behavior is verified</li> </ul> <p>An audit checklist MUST be completed covering: - Invariant mapping - Failure coverage - Recovery determinism - Forbidden behavior absence</p>"},{"location":"FAILOVER_READINESS/#9-performance-neutrality-requirement","title":"9. Performance Neutrality Requirement","text":"<p>Phase 6 MUST NOT:</p> <ul> <li>Introduce overhead on normal steady-state operation</li> <li>Add background threads or timers</li> <li>Affect write or read paths outside promotion attempts</li> </ul> <p>Promotion is rare; steady state must remain unchanged.</p>"},{"location":"FAILOVER_READINESS/#10-freeze-criteria","title":"10. Freeze Criteria","text":"<p>Phase 6 may be frozen only when:</p> <ul> <li>All readiness criteria are met</li> <li>Audit is complete</li> <li>No TODOs or speculative hooks remain</li> <li>All behavior is explainable to an operator</li> </ul> <p>Once frozen: - Phase 6 semantics are immutable - No new behavior may be added - Only correctness defects may be fixed</p>"},{"location":"FAILOVER_READINESS/#11-launch-declaration","title":"11. Launch Declaration","text":"<p>Upon freezing Phase 6:</p> <p>AeroDB is launch-ready as a correctness-first, replicated database with explicit failover and promotion.</p> <p>Admin UI, operator tooling, and security enhancements are explicitly deferred to later phases.</p>"},{"location":"FAILOVER_READINESS/#12-final-rule","title":"12. Final Rule","text":"<p>If Phase 6 is not provably correct under failure, AeroDB must refuse to promote rather than risk safety.</p> <p>Correctness remains the product.</p> <p>END OF DOCUMENT</p>"},{"location":"FAILOVER_SCOPE/","title":"FAILOVER_SCOPE.md \u2014 Failover &amp; Promotion","text":""},{"location":"FAILOVER_SCOPE/#status","title":"Status","text":"<ul> <li>Phase: 6</li> <li>Authority: Normative</li> <li>Depends on: FAILOVER_VISION.md</li> <li>Frozen Dependencies: Phases 0\u20135</li> </ul>"},{"location":"FAILOVER_SCOPE/#1-purpose-of-this-document","title":"1. Purpose of This Document","text":"<p>This document defines the exact scope boundaries of Phase 6.</p> <p>Its role is to make Phase 6: - Explicit - Finite - Non-expanding - Immune to scope creep</p> <p>Anything not explicitly allowed here is forbidden.</p>"},{"location":"FAILOVER_SCOPE/#2-in-scope-capabilities-allowed","title":"2. In-Scope Capabilities (Allowed)","text":"<p>Phase 6 is limited to the following capabilities.</p>"},{"location":"FAILOVER_SCOPE/#21-explicit-replica-promotion","title":"2.1 Explicit Replica Promotion","text":"<p>Phase 6 defines: - When a replica may be promoted - What conditions must be satisfied - How promotion is validated - How authority is transferred</p> <p>Promotion is: - Explicitly triggered - Deterministically evaluated - Either accepted or rejected atomically</p>"},{"location":"FAILOVER_SCOPE/#22-promotion-safety-validation","title":"2.2 Promotion Safety Validation","text":"<p>Before promotion, the system MUST be able to prove:</p> <ul> <li>Replica WAL position is sufficient</li> <li>No acknowledged writes would be lost</li> <li>No dual-primary condition can arise</li> <li>MVCC visibility rules remain intact</li> <li>Replication invariants from Phase 5 are preserved</li> </ul> <p>If proof fails, promotion MUST be rejected.</p>"},{"location":"FAILOVER_SCOPE/#23-failover-state-modeling","title":"2.3 Failover State Modeling","text":"<p>Phase 6 introduces: - A formal failover-related state model - Explicit state transitions - Explicit forbidden transitions</p> <p>No implicit or inferred transitions are allowed.</p>"},{"location":"FAILOVER_SCOPE/#24-authority-rebinding","title":"2.4 Authority Rebinding","text":"<p>Phase 6 defines: - How write authority is transferred - When the old primary is considered invalid - How the new primary assumes authority</p> <p>Authority rebinding is: - Single-writer - Non-overlapping - Explicitly observable</p>"},{"location":"FAILOVER_SCOPE/#25-observability-explanation-additive-only","title":"2.5 Observability &amp; Explanation (Additive Only)","text":"<p>Phase 6 may add: - New observability events - New explanation surfaces</p> <p>But: - Must reuse existing observability infrastructure - Must remain passive - Must not influence control flow</p>"},{"location":"FAILOVER_SCOPE/#3-explicit-non-goals-forbidden","title":"3. Explicit Non-Goals (Forbidden)","text":"<p>Phase 6 MUST NOT introduce any of the following.</p>"},{"location":"FAILOVER_SCOPE/#31-automatic-failover","title":"3.1 Automatic Failover","text":"<p>Forbidden: - Automatic leader election - Background promotion - Health-check-driven failover - Time-based decisions</p> <p>All promotion is explicit.</p>"},{"location":"FAILOVER_SCOPE/#32-consensus-protocols","title":"3.2 Consensus Protocols","text":"<p>Phase 6 MUST NOT: - Introduce Raft, Paxos, Zab, etc. - Add quorum voting - Add majority-based authority</p> <p>Single-writer authority remains absolute.</p>"},{"location":"FAILOVER_SCOPE/#33-multi-primary-or-split-brain-handling","title":"3.3 Multi-Primary or Split-Brain Handling","text":"<p>Phase 6 does NOT: - Allow dual primaries - Tolerate split brain - Attempt conflict resolution</p> <p>If safety cannot be proven, the system must halt or reject.</p>"},{"location":"FAILOVER_SCOPE/#34-replication-redesign","title":"3.4 Replication Redesign","text":"<p>Phase 6 MUST NOT: - Change WAL semantics - Change replication protocol - Change snapshot behavior - Change recovery logic</p> <p>Replication from Phase 5 is frozen.</p>"},{"location":"FAILOVER_SCOPE/#35-admin-ui-or-operator-tooling","title":"3.5 Admin UI or Operator Tooling","text":"<p>Phase 6 does NOT include: - Admin dashboards - Web UI - CLI convenience tooling - Operator workflows</p> <p>These belong to a later phase.</p>"},{"location":"FAILOVER_SCOPE/#4-scope-boundaries-with-frozen-phases","title":"4. Scope Boundaries with Frozen Phases","text":""},{"location":"FAILOVER_SCOPE/#41-phase-5-boundary","title":"4.1 Phase 5 Boundary","text":"<p>Phase 6 may: - Read Phase 5 replication state - Validate Phase 5 invariants - React to Phase 5 states</p> <p>Phase 6 may NOT: - Modify Phase 5 state machines - Add hidden transitions - Alter replication correctness rules</p>"},{"location":"FAILOVER_SCOPE/#42-phase-04-boundary","title":"4.2 Phase 0\u20134 Boundary","text":"<p>Phase 6 MUST NOT: - Affect WAL durability semantics - Affect MVCC visibility - Affect recovery determinism - Affect observability guarantees</p>"},{"location":"FAILOVER_SCOPE/#5-failure-handling-scope","title":"5. Failure Handling Scope","text":"<p>Phase 6 is responsible for: - Defining promotion failure cases - Making failures explicit - Explaining why promotion failed</p> <p>Phase 6 is NOT responsible for: - Repairing failures - Masking failures - Retrying promotion automatically</p>"},{"location":"FAILOVER_SCOPE/#6-completeness-criteria","title":"6. Completeness Criteria","text":"<p>Phase 6 scope is considered complete when:</p> <ul> <li>All allowed behaviors are specified</li> <li>All forbidden behaviors are explicitly excluded</li> <li>No ambiguity exists about system behavior</li> <li>No frozen phase semantics are touched</li> </ul>"},{"location":"FAILOVER_SCOPE/#7-scope-lock-rule","title":"7. Scope Lock Rule","text":"<p>Once FAILOVER_SCOPE.md is approved:</p> <p>Any request not covered by this document MUST be deferred to a later phase.</p> <p>END OF DOCUMENT</p>"},{"location":"FAILOVER_STATE_MACHINE/","title":"FAILOVER_STATE_MACHINE.md \u2014 Failover &amp; Promotion","text":""},{"location":"FAILOVER_STATE_MACHINE/#status","title":"Status","text":"<ul> <li>Phase: 6</li> <li>Authority: Normative</li> <li>Depends on:</li> <li>FAILOVER_VISION.md</li> <li>FAILOVER_SCOPE.md</li> <li>FAILOVER_INVARIANTS.md</li> <li>FAILOVER_ARCHITECTURE.md</li> <li>FAILOVER_FAILURE_MODEL.md</li> <li>Frozen Dependencies: Phases 0\u20135</li> </ul>"},{"location":"FAILOVER_STATE_MACHINE/#1-purpose","title":"1. Purpose","text":"<p>This document defines the explicit state machine governing failover and promotion in Phase 6.</p> <p>It specifies: - States - Transitions - Entry and exit conditions - Forbidden transitions</p> <p>This state machine is authoritative for Phase 6 behavior.</p>"},{"location":"FAILOVER_STATE_MACHINE/#2-design-rules","title":"2. Design Rules","text":"<p>The Phase 6 state machine obeys the following rules:</p> <ol> <li>States are explicit and enumerable</li> <li>Transitions are event-driven, never inferred</li> <li>All transitions are deterministic</li> <li>No background or time-based transitions exist</li> <li>All authority changes are atomic</li> <li>All failures are explicit</li> </ol> <p>If a transition is not listed here, it is forbidden.</p>"},{"location":"FAILOVER_STATE_MACHINE/#3-relationship-to-phase-5-state-machine","title":"3. Relationship to Phase 5 State Machine","text":"<p>Phase 6 does not replace the Phase 5 replication state machine.</p> <p>Instead: - Phase 5 defines replication role - Phase 6 defines promotion lifecycle</p> <p>Phase 6 states observe and constrain Phase 5 transitions; they do not add hidden paths.</p>"},{"location":"FAILOVER_STATE_MACHINE/#4-phase-6-states","title":"4. Phase 6 States","text":""},{"location":"FAILOVER_STATE_MACHINE/#41-steady","title":"4.1 <code>Steady</code>","text":"<p>Meaning - System is operating normally - No promotion attempt in progress - Replication roles are stable</p> <p>Entry Conditions - System startup after successful recovery - Completion of a promotion attempt (success or failure)</p> <p>Exit Conditions - Explicit promotion request received</p>"},{"location":"FAILOVER_STATE_MACHINE/#42-promotionrequested","title":"4.2 <code>PromotionRequested</code>","text":"<p>Meaning - An explicit promotion request has been issued - No validation has begun yet</p> <p>Entry Conditions - Operator or control-plane requests promotion</p> <p>Exit Conditions - Transition to <code>PromotionValidating</code> - Transition to <code>Steady</code> (request rejected immediately)</p>"},{"location":"FAILOVER_STATE_MACHINE/#43-promotionvalidating","title":"4.3 <code>PromotionValidating</code>","text":"<p>Meaning - System is validating whether promotion is allowed - No authority change has occurred</p> <p>Actions - Validate WAL safety - Validate replication invariants - Validate single-writer guarantees - Validate crash safety</p> <p>Exit Conditions - Transition to <code>PromotionApproved</code> - Transition to <code>PromotionDenied</code></p>"},{"location":"FAILOVER_STATE_MACHINE/#44-promotionapproved","title":"4.4 <code>PromotionApproved</code>","text":"<p>Meaning - Promotion has been fully validated - Authority transition is permitted but not yet applied</p> <p>Properties - Approval has no durable effect - Approval may be invalidated by crash</p> <p>Exit Conditions - Transition to <code>AuthorityTransitioning</code></p>"},{"location":"FAILOVER_STATE_MACHINE/#45-authoritytransitioning","title":"4.5 <code>AuthorityTransitioning</code>","text":"<p>Meaning - Atomic authority transfer is in progress</p> <p>Actions - Apply authority rebinding - Update replication role explicitly - Ensure atomicity</p> <p>Exit Conditions - Transition to <code>PromotionSucceeded</code> - System crash (handled by recovery rules)</p>"},{"location":"FAILOVER_STATE_MACHINE/#46-promotionsucceeded","title":"4.6 <code>PromotionSucceeded</code>","text":"<p>Meaning - Promotion completed successfully - New primary is authoritative</p> <p>Entry Conditions - Authority transition completed atomically</p> <p>Exit Conditions - Transition to <code>Steady</code></p>"},{"location":"FAILOVER_STATE_MACHINE/#47-promotiondenied","title":"4.7 <code>PromotionDenied</code>","text":"<p>Meaning - Promotion validation failed</p> <p>Properties - Failure reasons are explicit - No authority change occurred</p> <p>Exit Conditions - Transition to <code>Steady</code></p>"},{"location":"FAILOVER_STATE_MACHINE/#5-terminal-and-recovery-behavior","title":"5. Terminal and Recovery Behavior","text":"<p>There are no terminal states in Phase 6.</p> <p>On crash and recovery: - System MUST re-enter <code>Steady</code> - Authority state MUST be reconstructed deterministically - No partial promotion state may persist</p>"},{"location":"FAILOVER_STATE_MACHINE/#6-allowed-transitions-complete-list","title":"6. Allowed Transitions (Complete List)","text":"<pre><code>Steady\n\u2192 PromotionRequested\n\nPromotionRequested\n\u2192 PromotionValidating\n\u2192 Steady\n\nPromotionValidating\n\u2192 PromotionApproved\n\u2192 PromotionDenied\n\nPromotionApproved\n\u2192 AuthorityTransitioning\n\nAuthorityTransitioning\n\u2192 PromotionSucceeded\n\nPromotionSucceeded\n\u2192 Steady\n\nPromotionDenied\n\u2192 Steady\n</code></pre> <p>No other transitions are permitted.</p>"},{"location":"FAILOVER_STATE_MACHINE/#7-forbidden-transitions-explicit","title":"7. Forbidden Transitions (Explicit)","text":"<p>The following transitions are forbidden:</p> <ul> <li><code>Steady \u2192 AuthorityTransitioning</code></li> <li><code>PromotionRequested \u2192 PromotionApproved</code></li> <li><code>PromotionValidating \u2192 AuthorityTransitioning</code></li> <li><code>PromotionDenied \u2192 AuthorityTransitioning</code></li> <li>Any transition driven by timeouts or retries</li> <li>Any implicit re-entry into <code>PromotionApproved</code> after crash</li> </ul>"},{"location":"FAILOVER_STATE_MACHINE/#8-crash-semantics-per-state","title":"8. Crash Semantics per State","text":"State Crash Outcome Steady No effect PromotionRequested Promotion forgotten PromotionValidating Promotion forgotten PromotionApproved Promotion forgotten AuthorityTransitioning Atomic outcome enforced PromotionSucceeded Authority preserved PromotionDenied Promotion forgotten <p>Crash behavior is deterministic and invariant-preserving.</p>"},{"location":"FAILOVER_STATE_MACHINE/#9-observability-requirements","title":"9. Observability Requirements","text":"<p>Each state transition MUST emit: - State entry event - Transition reason - Relevant invariant references</p> <p>Silent transitions are forbidden.</p>"},{"location":"FAILOVER_STATE_MACHINE/#10-state-machine-completeness-rule","title":"10. State Machine Completeness Rule","text":"<p>This state machine is complete when: - Every promotion attempt follows exactly one path - No ambiguity exists after crash - All invariant violations result in <code>PromotionDenied</code> - All success paths converge to <code>Steady</code></p> <p>END OF DOCUMENT</p>"},{"location":"FAILOVER_TESTING_STRATEGY/","title":"FAILOVER_TESTING_STRATEGY.md \u2014 Failover &amp; Promotion","text":""},{"location":"FAILOVER_TESTING_STRATEGY/#status","title":"Status","text":"<ul> <li>Phase: 6</li> <li>Authority: Normative</li> <li>Depends on:</li> <li>FAILOVER_VISION.md</li> <li>FAILOVER_SCOPE.md</li> <li>FAILOVER_INVARIANTS.md</li> <li>FAILOVER_ARCHITECTURE.md</li> <li>FAILOVER_FAILURE_MODEL.md</li> <li>FAILOVER_STATE_MACHINE.md</li> <li>FAILOVER_OBSERVABILITY_MAPPING.md</li> <li>Frozen Dependencies: Phases 0\u20135 Test Suites</li> </ul>"},{"location":"FAILOVER_TESTING_STRATEGY/#1-purpose","title":"1. Purpose","text":"<p>This document defines the mandatory testing requirements for Phase 6.</p> <p>Its goals are to: - Prove correctness of failover &amp; promotion - Enforce Phase 6 invariants - Preserve all frozen-phase guarantees - Eliminate ambiguity under failure and crash</p> <p>If a behavior is not tested, it is not considered correct.</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#2-testing-principles-non-negotiable","title":"2. Testing Principles (Non-Negotiable)","text":"<p>Phase 6 testing MUST obey:</p> <ol> <li>Invariant-first testing</li> <li>Crash-before-optimization</li> <li>No test weakening</li> <li>Deterministic reproduction</li> <li>Explicit failure validation</li> </ol> <p>All Phase 0\u20135 tests MUST pass unchanged.</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#3-test-categories","title":"3. Test Categories","text":"<p>Phase 6 introduces tests in the following categories.</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#31-unit-tests-promotion-logic","title":"3.1 Unit Tests \u2014 Promotion Logic","text":"<p>Scope - Promotion Controller - Promotion Validator - Authority Transition Manager (logic-level)</p> <p>Required Coverage - Single-writer enforcement - WAL prefix validation - MVCC visibility preservation - Deterministic decision-making - Explicit rejection paths</p> <p>Examples - Promotion denied when replica WAL lags - Promotion denied when authority ambiguity exists - Promotion allowed only when all invariants are satisfied</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#32-state-machine-tests","title":"3.2 State Machine Tests","text":"<p>Scope - Phase 6 state transitions</p> <p>Required Coverage - All allowed transitions - All forbidden transitions - No implicit or skipped states - Correct reset to <code>Steady</code> after completion</p> <p>Examples - <code>PromotionRequested \u2192 PromotionValidating</code> - Rejection paths return to <code>Steady</code> - Crash causes re-entry into <code>Steady</code></p>"},{"location":"FAILOVER_TESTING_STRATEGY/#33-integration-tests-replication-interaction","title":"3.3 Integration Tests \u2014 Replication Interaction","text":"<p>Scope - Phase 6 + Phase 5 integration</p> <p>Required Coverage - Promotion of a fully synced replica - Promotion denial when replication invariants fail - No Phase 5 state machine corruption</p> <p>Constraints - Replication behavior MUST remain unchanged - Promotion logic MUST only read or explicitly transition roles</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#34-crash-tests-promotion-boundaries","title":"3.4 Crash Tests \u2014 Promotion Boundaries","text":"<p>Scope - All Phase 6 failure boundaries</p> <p>Required Crash Points - Before validation - During validation - After validation, before authority transition - During authority transition - Immediately after authority transition</p> <p>Required Outcomes - No dual-primary state - No lost acknowledged writes - Deterministic recovery - Explicit abort or completion</p> <p>Crash tests are mandatory, not optional.</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#35-recovery-determinism-tests","title":"3.5 Recovery Determinism Tests","text":"<p>Scope - Restart behavior after crashes during promotion</p> <p>Required Coverage - Recovery from every Phase 6 state - Authority state unambiguous after restart - Promotion outcome deterministic</p> <p>Recovery MUST never infer intent.</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#36-observability-explanation-tests","title":"3.6 Observability &amp; Explanation Tests","text":"<p>Scope - Event emission - Metrics stability - Explanation artifacts</p> <p>Required Coverage - All promotion attempts emit events - Failure explanations map to invariants - Explanation output deterministic</p> <p>Observability MUST NOT affect behavior.</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#4-negative-testing-required","title":"4. Negative Testing (Required)","text":"<p>Phase 6 MUST include tests that verify rejection:</p> <ul> <li>Promotion with stale replica</li> <li>Promotion under ambiguous authority</li> <li>Promotion with missing replication metadata</li> <li>Promotion under simulated split-brain conditions</li> </ul> <p>Failure must be explicit and explainable.</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#5-regression-protection","title":"5. Regression Protection","text":"<p>Phase 6 test suite MUST assert:</p> <ul> <li>No new warnings in Phase 0\u20135 tests</li> <li>No behavior drift in replication</li> <li>No WAL format changes</li> <li>No MVCC behavior changes</li> </ul> <p>Any regression is a blocking defect.</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#6-disablement-isolation-tests","title":"6. Disablement &amp; Isolation Tests","text":"<p>If Phase 6 logic is disabled or bypassed: - System MUST behave exactly like Phase 5 - No promotion paths exist - No hidden state introduced</p> <p>Disablement behavior MUST be tested.</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#7-determinism-enforcement","title":"7. Determinism Enforcement","text":"<p>All tests MUST: - Be reproducible - Avoid timing dependencies - Avoid randomized ordering - Avoid flaky assertions</p> <p>Non-deterministic tests are invalid.</p>"},{"location":"FAILOVER_TESTING_STRATEGY/#8-test-completion-criteria","title":"8. Test Completion Criteria","text":"<p>Phase 6 testing is complete when:</p> <ul> <li>All new tests pass</li> <li>All existing tests pass unchanged</li> <li>All invariants are covered by at least one test</li> <li>Crash matrices are exhaustive</li> <li>No untested failure paths exist</li> </ul>"},{"location":"FAILOVER_TESTING_STRATEGY/#9-audit-requirement","title":"9. Audit Requirement","text":"<p>Before Phase 6 can be frozen:</p> <ul> <li>Test coverage must be reviewed</li> <li>Crash coverage must be audited</li> <li>Invariant mapping must be verified</li> </ul> <p>No audit \u2192 no freeze.</p> <p>END OF DOCUMENT</p>"},{"location":"FAILOVER_VISION/","title":"FAILOVER_VISION.md \u2014 Failover &amp; Promotion","text":""},{"location":"FAILOVER_VISION/#status","title":"Status","text":"<ul> <li>Phase: 6</li> <li>Authority: Normative</li> <li>Depends on: Phases 0\u20135 (Frozen)</li> <li>Scope: Failover &amp; Promotion semantics only</li> </ul>"},{"location":"FAILOVER_VISION/#1-purpose","title":"1. Purpose","text":"<p>Phase 6 introduces explicit, correctness-preserving failover and promotion for AeroDB\u2019s replication system.</p> <p>After Phase 5, AeroDB supports: - Deterministic primary\u2013replica replication - Single-writer authority - Replica read safety - Crash-safe recovery - Full observability and explanation</p> <p>What is missing is a defined, safe transition of write authority when a primary becomes unavailable.</p> <p>Phase 6 exists to answer one question, and one question only:</p> <p>When and how may a replica become the primary, without violating correctness?</p>"},{"location":"FAILOVER_VISION/#2-design-philosophy","title":"2. Design Philosophy","text":"<p>Phase 6 follows AeroDB\u2019s core philosophy:</p> <ol> <li>Correctness over availability</li> <li>Determinism over automation</li> <li>Explicit authority over heuristics</li> <li>Explainability over convenience</li> </ol> <p>Failover in Phase 6 is: - Explicit, not heuristic - Safe, not fast - Auditable, not magical - Deterministic, not adaptive</p>"},{"location":"FAILOVER_VISION/#3-what-phase-6-introduces","title":"3. What Phase 6 Introduces","text":"<p>Phase 6 introduces:</p> <ul> <li>A formal promotion model for replicas</li> <li>Explicit authority transfer rules</li> <li>A well-defined failover state machine</li> <li>Clear safety checks before promotion</li> <li>Observable and explainable failover decisions</li> </ul> <p>Phase 6 does not introduce: - Automatic leader election - Consensus protocols (Raft, Paxos, etc.) - Split-brain tolerance - Background retries - Hidden recovery behavior</p>"},{"location":"FAILOVER_VISION/#4-explicit-non-goals","title":"4. Explicit Non-Goals","text":"<p>Phase 6 explicitly does not aim to:</p> <ul> <li>Maximize availability at all costs</li> <li>Mask failures from operators</li> <li>Automatically \u201cheal\u201d the system</li> <li>Optimize for cloud orchestration platforms</li> <li>Introduce multi-writer semantics</li> <li>Redefine replication from Phase 5</li> </ul> <p>If a system cannot prove safety, it must refuse promotion.</p>"},{"location":"FAILOVER_VISION/#5-relationship-to-frozen-phases","title":"5. Relationship to Frozen Phases","text":"<p>Phase 6:</p> <ul> <li>Does not modify Phase 0\u20135 invariants</li> <li>Does not reinterpret replication semantics</li> <li>Does not change WAL, MVCC, or recovery rules</li> <li>Does not weaken failure guarantees</li> </ul> <p>All Phase 0\u20135 behavior remains authoritative and frozen.</p> <p>Phase 6 is strictly additive.</p>"},{"location":"FAILOVER_VISION/#6-operational-model-high-level","title":"6. Operational Model (High-Level)","text":"<p>At a conceptual level, Phase 6 enables:</p> <ul> <li>A replica to be considered for promotion</li> <li>A promotion to be validated against safety rules</li> <li>A promotion to either:</li> <li>Succeed explicitly, or</li> <li>Fail explicitly with explanation</li> </ul> <p>There is no partial success.</p>"},{"location":"FAILOVER_VISION/#7-observability-explanation","title":"7. Observability &amp; Explanation","text":"<p>Every failover-related decision must be:</p> <ul> <li>Observable via existing observability infrastructure</li> <li>Explainable via the explanation engine</li> <li>Traceable to explicit invariants and rules</li> </ul> <p>AeroDB must always be able to answer:</p> <p>Why was promotion allowed or denied?</p>"},{"location":"FAILOVER_VISION/#8-success-criteria","title":"8. Success Criteria","text":"<p>Phase 6 is complete when:</p> <ul> <li>Promotion rules are fully specified</li> <li>Failure cases are exhaustively defined</li> <li>No ambiguity exists in authority transitions</li> <li>All behavior is deterministic and testable</li> <li>All new logic is observable and explainable</li> <li>All Phase 0\u20135 tests remain unchanged and passing</li> </ul>"},{"location":"FAILOVER_VISION/#9-exit-condition","title":"9. Exit Condition","text":"<p>Once Phase 6 is audited and frozen:</p> <p>AeroDB is launch-ready as a correctness-first replicated database.</p> <p>Admin UI, operator tooling, and security enhancements are explicitly deferred to later phases.</p> <p>END OF DOCUMENT</p>"},{"location":"FUNCTIONS_ARCHITECTURE/","title":"Phase 12: Serverless Functions Architecture","text":"<p>Document Type: Technical Architecture Phase: 12 - Serverless Functions Status: Active</p>"},{"location":"FUNCTIONS_ARCHITECTURE/#system-overview","title":"System Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Client Applications                      \u2502\n\u2502                   (REST API, Cron Scheduler)                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                  \u2502  Functions Module   \u2502\n                  \u2502 (Invoker, Scheduler)\u2502\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                    \u2502                    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502WASM Runtime    \u2502  \u2502 Function        \u2502  \u2502    Database    \u2502\n\u2502 (Sandbox)      \u2502  \u2502   Registry      \u2502  \u2502   (Executor)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Host          \u2502\n\u2502  Functions     \u2502\n\u2502(db, log, http) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#component-architecture","title":"Component Architecture","text":""},{"location":"FUNCTIONS_ARCHITECTURE/#1-function-registry","title":"1. Function Registry","text":"<p>Purpose: Store and index deployed functions</p> <pre><code>pub struct FunctionRegistry {\n    functions: HashMap&lt;Uuid, Function&gt;,\n    name_index: HashMap&lt;String, Uuid&gt;,\n    trigger_index: HashMap&lt;TriggerType, HashSet&lt;Uuid&gt;&gt;,\n}\n</code></pre> <p>Operations: - <code>register(function)</code> - Add function to registry - <code>get_by_name(name)</code> - Lookup by name - <code>get_by_trigger(trigger)</code> - Find all functions for trigger type - <code>unregister(id)</code> - Remove function</p>"},{"location":"FUNCTIONS_ARCHITECTURE/#2-wasm-runtime","title":"2. WASM Runtime","text":"<p>Integration: wasmer or wasmtime</p> <pre><code>pub struct WasmRuntime {\n    engine: Engine,\n    store: Store,\n}\n\nimpl WasmRuntime {\n    pub fn load_module(&amp;self, wasm_bytes: &amp;[u8]) -&gt; Result&lt;Module&gt; {\n        Module::new(&amp;self.engine, wasm_bytes)\n    }\n\n    pub fn instantiate(&amp;self, module: &amp;Module) -&gt; Result&lt;Instance&gt; {\n        let imports = create_host_functions();\n        Instance::new(&amp;mut self.store, module, &amp;imports)\n    }\n}\n</code></pre> <p>Resource Limits: <pre><code>pub struct ResourceLimits {\n    timeout: Duration,      // Default: 10s\n    max_memory: usize,      // Default: 128MB\n    max_stack: usize,       // Default: 1MB\n}\n</code></pre></p>"},{"location":"FUNCTIONS_ARCHITECTURE/#3-invoker","title":"3. Invoker","text":"<p>Purpose: Execute functions with resource limits</p> <pre><code>pub struct Invoker {\n    runtime: WasmRuntime,\n    registry: Arc&lt;FunctionRegistry&gt;,\n    executor: Arc&lt;Executor&gt;,  // For database access\n}\n\nimpl Invoker {\n    pub async fn invoke(\n        &amp;self,\n        function_name: &amp;str,\n        payload: Value,\n        context: &amp;RlsContext,\n    ) -&gt; Result&lt;InvocationResult&gt; {\n        // 1. Lookup function\n        let func = self.registry.get_by_name(function_name)?;\n\n        // 2. Load WASM module\n        let module = self.runtime.load_module(&amp;func.wasm_bytes)?;\n\n        // 3. Create instance with host functions\n        let instance = self.runtime.instantiate(&amp;module)?;\n\n        // 4. Call handler with timeout\n        let result = timeout(\n            func.config.timeout,\n            self.call_handler(instance, payload, context)\n        ).await?;\n\n        Ok(result)\n    }\n}\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#4-scheduler","title":"4. Scheduler","text":"<p>Purpose: Run cron-based jobs</p> <pre><code>pub struct FunctionScheduler {\n    jobs: HashMap&lt;Uuid, ScheduledJob&gt;,\n    invoker: Arc&lt;Invoker&gt;,\n}\n\npub struct ScheduledJob {\n    id: Uuid,\n    function_id: Uuid,\n    cron_expression: String,\n    next_run: DateTime&lt;Utc&gt;,\n    enabled: bool,\n}\n\nimpl FunctionScheduler {\n    pub async fn run(&amp;self) {\n        loop {\n            let now = Utc::now();\n            let due_jobs = self.get_due_jobs(now);\n\n            for job in due_jobs {\n                tokio::spawn(async move {\n                    self.invoker.invoke(...).await;\n                });\n\n                self.update_next_run(&amp;job);\n            }\n\n            sleep(Duration::from_secs(1)).await;\n        }\n    }\n}\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#module-structure","title":"Module Structure","text":"<pre><code>src/functions/\n\u251c\u2500\u2500 mod.rs              # Module entry, exports\n\u251c\u2500\u2500 errors.rs           # Function-specific errors\n\u251c\u2500\u2500 function.rs         # Function model, metadata\n\u251c\u2500\u2500 trigger.rs          # Trigger types (HTTP, DB, Schedule)\n\u251c\u2500\u2500 registry.rs         # Function registry (in-memory index)\n\u251c\u2500\u2500 runtime.rs          # WASM runtime (wasmer integration)\n\u251c\u2500\u2500 invoker.rs          # Function execution with limits\n\u251c\u2500\u2500 scheduler.rs        # Cron job scheduler\n\u2514\u2500\u2500 host_functions.rs   # Host functions (db_query, log, etc.)\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#data-flow","title":"Data Flow","text":""},{"location":"FUNCTIONS_ARCHITECTURE/#http-trigger-flow","title":"HTTP Trigger Flow","text":"<pre><code>1. Client \u2192 REST API\n   POST /functions/v1/my-function\n   Headers: Authorization, Content-Type\n   Body: {\"key\": \"value\"}\n\n2. REST API \u2192 Auth Module\n   Extract JWT \u2192 RlsContext\n\n3. REST API \u2192 Invoker\n   invoke(\"my-function\", payload, context)\n\n4. Invoker:\n   a. Lookup function in registry\n   b. Load WASM module\n   c. Create instance with host functions\n   d. Call exported `handler` function\n   e. Enforce timeout (10s default)\n   f. Enforce memory limit (128MB default)\n\n5. Function (WASM):\n   a. Parse payload\n   b. Call host function: db_query(...)\n   c. Call host function: log(...)\n   d. Return result\n\n6. Invoker \u2192 REST API\n   Return result or error\n\n7. REST API \u2192 Client\n   200 OK {result} or 500 Error\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#database-trigger-flow","title":"Database Trigger Flow","text":"<pre><code>1. Database \u2192 WAL\n   INSERT INTO users VALUES (...)\n\n2. WAL \u2192 Event Log (Phase 10)\n   Emit DatabaseEvent::Insert\n\n3. Event Log \u2192 Function Trigger Dispatcher\n   Check: Are there DB triggers for \"users\" table?\n\n4. Trigger Dispatcher \u2192 Invoker\n   For each matching function:\n     invoke(function, {table: \"users\", op: \"INSERT\", row: ...})\n\n5. Invoker executes function (same as HTTP flow)\n\n6. Function result logged, errors don't crash database\n</code></pre> <p>Non-Determinism Note: Database triggers run after WAL commit, not during transaction. They are best-effort, not transactional.</p>"},{"location":"FUNCTIONS_ARCHITECTURE/#schedule-trigger-flow","title":"Schedule Trigger Flow","text":"<pre><code>1. Scheduler (background thread):\n   Loop every 1 second:\n     a. Get current time\n     b. Find jobs where next_run &lt;= now\n     c. Spawn task for each due job\n\n2. Spawned Task \u2192 Invoker\n   invoke(function, {timestamp: now})\n\n3. Invoker executes function\n\n4. Scheduler updates next_run based on cron expression\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#host-functions","title":"Host Functions","text":"<p>Functions call out to AeroDB via imported host functions:</p>"},{"location":"FUNCTIONS_ARCHITECTURE/#db_query","title":"db_query","text":"<pre><code>#[host_function]\nfn db_query(sql: String, params: Vec&lt;Value&gt;) -&gt; Result&lt;Vec&lt;Row&gt;&gt; {\n    // Parse SQL\n    let query = parse_sql(&amp;sql)?;\n\n    // Execute with RLS context (from invocation)\n    let result = executor.execute(query, &amp;rls_context)?;\n\n    Ok(result)\n}\n</code></pre> <p>WASM Side: <pre><code>// Import from host\nextern \"C\" {\n    fn db_query(sql_ptr: *const u8, sql_len: usize) -&gt; i32;\n}\n\n// Wrapper\nfunction query(sql, params) {\n    return JSON.parse(callHost(db_query, JSON.stringify({sql, params})));\n}\n</code></pre></p>"},{"location":"FUNCTIONS_ARCHITECTURE/#log","title":"log","text":"<pre><code>#[host_function]\nfn log(level: String, message: String) {\n    let level = match level.as_str() {\n        \"info\" =&gt; log::Level::Info,\n        \"warn\" =&gt; log::Level::Warn,\n        \"error\" =&gt; log::Level::Error,\n        _ =&gt; log::Level::Debug,\n    };\n\n    log::log!(level, \"[Function] {}\", message);\n}\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#http_fetch-future","title":"http_fetch (Future)","text":"<pre><code>#[host_function]\nasync fn http_fetch(url: String) -&gt; Result&lt;String&gt; {\n    let client = reqwest::Client::new();\n    let response = client.get(&amp;url).send().await?;\n    Ok(response.text().await?)\n}\n</code></pre> <p>Security: Whitelist allowed domains in function config</p>"},{"location":"FUNCTIONS_ARCHITECTURE/#env","title":"env","text":"<pre><code>#[host_function]\nfn env(key: String) -&gt; Option&lt;String&gt; {\n    // Only return whitelisted env vars\n    let allowed = [\"DATABASE_URL\", \"API_KEY\"];\n\n    if allowed.contains(&amp;key.as_str()) {\n        std::env::var(&amp;key).ok()\n    } else {\n        None\n    }\n}\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#resource-enforcement","title":"Resource Enforcement","text":""},{"location":"FUNCTIONS_ARCHITECTURE/#timeout","title":"Timeout","text":"<pre><code>pub async fn invoke_with_timeout(\n    instance: Instance,\n    payload: Value,\n) -&gt; Result&lt;Value&gt; {\n    let timeout = Duration::from_secs(10);\n\n    match tokio::time::timeout(timeout, call_handler(instance, payload)).await {\n        Ok(result) =&gt; result,\n        Err(_) =&gt; Err(FunctionError::Timeout),\n    }\n}\n</code></pre> <p>Behavior: - Function exceeds 10s \u2192 Killed, error returned - Partial work is NOT rolled back (non-transactional)</p>"},{"location":"FUNCTIONS_ARCHITECTURE/#memory-limit","title":"Memory Limit","text":"<pre><code>let mut store = Store::new(&amp;engine);\nstore.limiter(|_| ResourceLimiter {\n    memory_size: 128 * 1024 * 1024,  // 128MB\n});\n\nlet instance = Instance::new(&amp;mut store, &amp;module, &amp;imports)?;\n</code></pre> <p>Behavior: - Function allocates &gt; 128MB \u2192 Panic, error returned - Memory is freed when function completes</p>"},{"location":"FUNCTIONS_ARCHITECTURE/#stack-limit","title":"Stack Limit","text":"<pre><code>let mut config = Config::new();\nconfig.max_wasm_stack(1024 * 1024);  // 1MB\nlet engine = Engine::new(&amp;config)?;\n</code></pre> <p>Behavior: - Deep recursion \u2192 Stack overflow, error returned</p>"},{"location":"FUNCTIONS_ARCHITECTURE/#error-handling","title":"Error Handling","text":""},{"location":"FUNCTIONS_ARCHITECTURE/#function-errors","title":"Function Errors","text":"<pre><code>pub enum FunctionError {\n    NotFound,              // Function doesn't exist\n    InvalidWasm,           // WASM compilation failure\n    Timeout,               // Exceeded timeout\n    OutOfMemory,           // Exceeded memory limit\n    HostFunctionError,     // db_query failed, etc.\n    RuntimePanic,          // WASM panic\n}\n</code></pre> <p>HTTP Mapping: <pre><code>impl From&lt;FunctionError&gt; for HttpStatus {\n    fn from(err: FunctionError) -&gt; HttpStatus {\n        match err {\n            FunctionError::NotFound =&gt; 404,\n            FunctionError::InvalidWasm =&gt; 400,\n            FunctionError::Timeout =&gt; 504,  // Gateway Timeout\n            FunctionError::OutOfMemory =&gt; 507,\n            FunctionError::HostFunctionError =&gt; 500,\n            FunctionError::RuntimePanic =&gt; 500,\n        }\n    }\n}\n</code></pre></p>"},{"location":"FUNCTIONS_ARCHITECTURE/#error-isolation","title":"Error Isolation","text":"<p>Key Principle: Function errors do NOT affect database or other functions.</p> <pre><code>pub async fn invoke_safe(&amp;self, func: &amp;Function, payload: Value) -&gt; InvocationResult {\n    match self.invoke_internal(func, payload).await {\n        Ok(result) =&gt; InvocationResult::Success(result),\n        Err(e) =&gt; {\n            log::error!(\"Function '{}' failed: {}\", func.name, e);\n            InvocationResult::Error {\n                code: e.code(),\n                message: e.to_string(),\n            }\n        }\n    }\n    // Database is unaffected\n}\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#integration-points","title":"Integration Points","text":""},{"location":"FUNCTIONS_ARCHITECTURE/#with-authentication-phase-8","title":"With Authentication (Phase 8)","text":"<pre><code>// HTTP trigger: RLS context from JWT\nlet context = extract_rls_context(&amp;request)?;\ninvoker.invoke(\"my-function\", payload, &amp;context)?;\n\n// Database trigger: Inherit context from triggering transaction\nlet context = transaction.rls_context();\ninvoker.invoke(\"on-user-created\", user_data, &amp;context)?;\n\n// Schedule trigger: Use service role context\nlet context = RlsContext::service_role();\ninvoker.invoke(\"cleanup-job\", empty_payload, &amp;context)?;\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#with-rest-api-phase-9","title":"With REST API (Phase 9)","text":"<p>Endpoints: <pre><code>POST   /functions/v1/deploy              # Deploy new function\nGET    /functions/v1/{name}              # Get function metadata\nDELETE /functions/v1/{name}              # Undeploy function\nPOST   /functions/v1/invoke/{name}       # Invoke function (HTTP trigger)\n</code></pre></p>"},{"location":"FUNCTIONS_ARCHITECTURE/#with-real-time-phase-10","title":"With Real-Time (Phase 10)","text":"<p>Functions can write to database, events propagate automatically:</p> <pre><code>// Function writes to DB\nexport async function handler() {\n  await db.query(\"INSERT INTO notifications (user_id, message) VALUES (...) \");\n  // Event emitted via Phase 10\n}\n\n// Client subscribes to notifications\nsupabase.channel('notifications')\n  .on('INSERT', handleNotification)\n  .subscribe();\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#observabilitymetrics","title":"ObservabilityMetrics","text":"<pre><code>functions_invocations_total{name, trigger, status}\nfunctions_duration_seconds{name}\nfunctions_memory_bytes{name}\nfunctions_timeout_total{name}\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#logs","title":"Logs","text":"<pre><code>{\n  \"level\": \"INFO\",\n  \"service\": \"functions\",\n  \"operation\": \"invoke\",\n  \"function\": \"send-email\",\n  \"trigger\": \"http\",\n  \"duration_ms\": 234,\n  \"memory_mb\": 12,\n  \"status\": \"success\",\n  \"user_id\": \"uuid\"\n}\n</code></pre>"},{"location":"FUNCTIONS_ARCHITECTURE/#alerts","title":"Alerts","text":"<ul> <li>Timeout rate &gt; 10%</li> <li>Error rate &gt; 5%</li> <li>Memory usage &gt; 90% of limit</li> </ul>"},{"location":"FUNCTIONS_EXECUTION_MODEL/","title":"Phase 12: Execution Model","text":"<p>Document Type: Execution Specification Phase: 12 - Serverless Functions Status: Active</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#execution-flow","title":"Execution Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Trigger  \u2502 (HTTP, Database, Schedule, Webhook)\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502\n     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Invoker      \u2502\n\u2502 1. Lookup func \u2502\n\u2502 2. Load WASM   \u2502\n\u2502 3. Call handler\u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502\n     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    WASM Runtime          \u2502\n\u2502 \u2022 Sandbox environment    \u2502\n\u2502 \u2022 Resource limits        \u2502\n\u2502 \u2022 Host function imports  \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502\n     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Function Code          \u2502\n\u2502 exports.handler(event)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502\n     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Host Functions         \u2502\n\u2502 \u2022 db_query(...)          \u2502\n\u2502 \u2022 log(...)               \u2502\n\u2502 \u2022 http_fetch(...)        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#trigger-types","title":"Trigger Types","text":""},{"location":"FUNCTIONS_EXECUTION_MODEL/#1-http-trigger","title":"1. HTTP Trigger","text":"<p>Invocation: <pre><code>POST /functions/v1/invoke/{function_name}\nAuthorization: Bearer &lt;JWT&gt;\nContent-Type: application/json\n\n{\"key\": \"value\"}\n</code></pre></p> <p>Event Payload: <pre><code>{\n  \"trigger\": \"http\",\n  \"method\": \"POST\",\n  \"path\": \"/functions/v1/invoke/my-function\",\n  \"headers\": {\"content-type\": \"application/json\"},\n  \"body\": {\"key\": \"value\"},\n  \"user_id\": \"uuid\",  // From JWT\n  \"request_id\": \"uuid\"\n}\n</code></pre></p> <p>Function Handler: <pre><code>export async function handler(event) {\n  const { body } = event;\n  // Process request\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ result: \"success\" })\n  };\n}\n</code></pre></p> <p>Response: Function return value becomes HTTP response body.</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#2-database-trigger","title":"2. Database Trigger","text":"<p>Registration: <pre><code>Function {\n    trigger: TriggerType::Database {\n        table: \"users\",\n        operation: DatabaseOperation::Insert,\n    }\n}\n</code></pre></p> <p>When Fired: <pre><code>INSERT INTO users (id, email) VALUES ('uuid', 'user@example.com');\n-- After commit, function invoked\n</code></pre></p> <p>Event Payload: <pre><code>{\n  \"trigger\": \"database\",\n  \"table\": \"users\",\n  \"operation\": \"INSERT\",\n  \"old\": null,\n  \"new\": {\n    \"id\": \"uuid\",\n    \"email\": \"user@example.com\",\n    \"created_at\": \"2026-02-06T09:00:00Z\"\n  },\n  \"timestamp\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p> <p>Function Handler: <pre><code>export async function handler(event) {\n  const user = event.new;\n\n  // Create user profile\n  await db.query(\n    \"INSERT INTO profiles (user_id, display_name) VALUES ($1, $2)\",\n    [user.id, user.email.split('@')[0]]\n  );\n\n  return { profileCreated: true };\n}\n</code></pre></p> <p>UPDATE Operation: <pre><code>{\n  \"trigger\": \"database\",\n  \"operation\": \"UPDATE\",\n  \"old\": {\"id\": \"uuid\", \"email\": \"old@example.com\"},\n  \"new\": {\"id\": \"uuid\", \"email\": \"new@example.com\"},\n  ...\n}\n</code></pre></p> <p>DELETE Operation: <pre><code>{\n  \"trigger\": \"database\",\n  \"operation\": \"DELETE\",\n  \"old\": {\"id\": \"uuid\", \"email\": \"user@example.com\"},\n  \"new\": null,\n  ...\n}\n</code></pre></p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#3-schedule-trigger","title":"3. Schedule Trigger","text":"<p>Registration: <pre><code>Function {\n    trigger: TriggerType::Schedule {\n        cron: \"0 3 * * *\",  // Daily at 3 AM\n    }\n}\n</code></pre></p> <p>Cron Format: <pre><code> \u250c\u2500\u2500\u2500\u2500\u2500minute (0 - 59)\n \u2502 \u250c\u2500\u2500\u2500hour (0 - 23)\n \u2502 \u2502 \u250c\u2500day of month (1 - 31)\n \u2502 \u2502 \u2502 \u250c\u2500month (1 - 12)\n \u2502 \u2502 \u2502 \u2502 \u250c\u2500day of week (0 - 6, Sunday = 0)\n \u2502 \u2502 \u2502 \u2502 \u2502\n * * * * *\n</code></pre></p> <p>Examples: <pre><code>\"0 */6 * * *\"  # Every 6 hours\n\"*/15 * * * *\" # Every 15 minutes\n\"0 0 1 * *\"    # First day of month at midnight\n\"0 9 * * 1-5\"  # Weekdays at 9 AM\n</code></pre></p> <p>Event Payload: <pre><code>{\n  \"trigger\": \"schedule\",\n  \"cron\": \"0 3 * * *\",\n  \"scheduled_time\": \"2026-02-06T03:00:00Z\",\n  \"actual_time\": \"2026-02-06T03:00:01Z\"\n}\n</code></pre></p> <p>Function Handler: <pre><code>export async function handler(event) {\n  console.log(\"Running cleanup job\");\n\n  const result = await db.query(\n    \"DELETE FROM logs WHERE created_at &lt; NOW() - INTERVAL '30 days'\"\n  );\n\n  return { deletedRows: result.rowCount };\n}\n</code></pre></p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#4-webhook-trigger-future","title":"4. Webhook Trigger (Future)","text":"<p>Registration: <pre><code>Function {\n    trigger: TriggerType::Webhook {\n        secret: \"whsec_...\",  // Verify signature\n    }\n}\n</code></pre></p> <p>Invocation: <pre><code>POST /functions/v1/webhook/{function_name}\nX-Webhook-Signature: sha256=...\nContent-Type: application/json\n\n{\"event\": \"payment.succeeded\", \"amount\": 1000}\n</code></pre></p> <p>Event Payload: <pre><code>{\n  \"trigger\": \"webhook\",\n  \"headers\": {\"x-webhook-signature\": \"sha256=...\"},\n  \"body\": {\"event\": \"payment.succeeded\", \"amount\": 1000},\n  \"timestamp\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#resource-limits","title":"Resource Limits","text":""},{"location":"FUNCTIONS_EXECUTION_MODEL/#timeout","title":"Timeout","text":"<p>Default: 10 seconds Range: 1s - 300s (5 minutes) Configurable: Per-function</p> <p>Enforcement: <pre><code>let result = tokio::time::timeout(\n    func.config.timeout,\n    call_handler(instance, payload)\n).await;\n\nmatch result {\n    Ok(value) =&gt; Ok(value),\n    Err(_) =&gt; Err(FunctionError::Timeout),\n}\n</code></pre></p> <p>Behavior: - Function exceeds timeout \u2192 Killed immediately - Partial work NOT rolled back (non-transactional) - Error logged, caller receives 504</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#memory-limit","title":"Memory Limit","text":"<p>Default: 128 MB Range: 16MB - 512MB Configurable: Per-function</p> <p>Enforcement: <pre><code>let mut store = Store::new(&amp;engine);\nstore.limiter(|_| ResourceLimiter {\n    memory_size: func.config.max_memory,\n});\n</code></pre></p> <p>Behavior: - Allocation exceeds limit \u2192 WASM panic - Error logged, caller receives 507</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#cpu-future","title":"CPU (Future)","text":"<p>Proposal: CPU instruction count limit - Track WASM instructions executed - Terminate after threshold (e.g., 1 billion instructions)</p> <p>Not Implemented: Current timeout is wall-clock based</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#host-functions","title":"Host Functions","text":"<p>Functions call AeroDB via imported host functions.</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#db_query","title":"db_query","text":"<p>Signature: <pre><code>fn db_query(sql: String, params: Vec&lt;Value&gt;) -&gt; Result&lt;Vec&lt;Row&gt;&gt;\n</code></pre></p> <p>WASM Import: <pre><code>// Provided by AeroDB runtime\nextern \"aerodb\" {\n  function db_query(sql: string, params: any[]): Row[];\n}\n</code></pre></p> <p>Example: <pre><code>const users = await db.query(\n  \"SELECT * FROM users WHERE created_at &gt; $1\",\n  [new Date('2026-01-01')]\n);\n</code></pre></p> <p>RLS Enforcement: Function inherits RLS context from invocation. Cannot bypass without service role.</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#log","title":"log","text":"<p>Signature: <pre><code>fn log(level: String, message: String)\n</code></pre></p> <p>Levels: debug, info, warn, error</p> <p>Example: <pre><code>log.info(\"Processing user registration\");\nlog.error(\"SMTP connection failed\");\n</code></pre></p> <p>Output: <pre><code>{\n  \"level\": \"INFO\",\n  \"source\": \"function:send_welcome_email\",\n  \"message\": \"Processing user registration\",\n  \"timestamp\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#http_fetch-future","title":"http_fetch (Future)","text":"<p>Signature: <pre><code>async fn http_fetch(url: String, options: HttpOptions) -&gt; Result&lt;HttpResponse&gt;\n</code></pre></p> <p>Example: <pre><code>const response = await http.fetch(\"https://api.stripe.com/v1/charges\", {\n  method: \"POST\",\n  headers: {\"Authorization\": `Bearer ${env(\"STRIPE_KEY\")}`},\n  body: JSON.stringify({amount: 1000})\n});\n</code></pre></p> <p>Security: - Whitelist allowed domains in function config - Rate limiting per function - Timeout applies to HTTP request</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#env","title":"env","text":"<p>Signature: <pre><code>fn env(key: String) -&gt; Option&lt;String&gt;\n</code></pre></p> <p>Example: <pre><code>const apiKey = env(\"STRIPE_API_KEY\");\nconst dbUrl = env(\"DATABASE_URL\");\n</code></pre></p> <p>Security: - Only whitelisted env vars returned - Secrets redacted in logs - Per-function environment isolation</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#error-handling","title":"Error Handling","text":""},{"location":"FUNCTIONS_EXECUTION_MODEL/#function-errors","title":"Function Errors","text":"<p>Types: - Timeout: Function exceeded time limit - OutOfMemory: Function exceeded memory limit - Panic: WASM runtime panic (assertion failure, null pointer, etc.) - HostFunctionError: db_query failed, http_fetch failed, etc.</p> <p>Error Propagation: <pre><code>export async function handler(event) {\n  try {\n    const result = await db.query(\"SELECT * FROM users\");\n    return { users: result };\n  } catch (error) {\n    // Error logged, propagated to caller\n    throw new Error(`Database query failed: ${error.message}`);\n  }\n}\n</code></pre></p> <p>Caller Receives: <pre><code>{\n  \"error\": \"500 Internal Server Error\",\n  \"message\": \"Database query failed: Connection refused\",\n  \"code\": \"FUNCTION_ERROR\"\n}\n</code></pre></p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#database-isolation","title":"Database Isolation","text":"<p>Key Principle: Function errors do NOT affect database.</p> <p>Scenario: <pre><code>// Database trigger on INSERT users\nexport async function handler(event) {\n  // This query succeeds\n  await db.query(\"INSERT INTO profiles ...\");\n\n  // This panics\n  throw new Error(\"Oops\");\n}\n</code></pre></p> <p>Result: - User INSERT: \u2705 Committed - Profile INSERT: \u2705 Committed (separate transaction) - Function: \u274c Error logged - Database: \u2705 Unaffected</p> <p>No Atomicity: Functions are NOT transactional with triggering operation.</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#concurrency","title":"Concurrency","text":""},{"location":"FUNCTIONS_EXECUTION_MODEL/#parallel-invocations","title":"Parallel Invocations","text":"<p>Multiple invocations of same function run concurrently:</p> <pre><code>Time     Invocation 1    Invocation 2    Invocation 3\nT0       Start\nT1       db_query        Start\nT2                       db_query        Start\nT3       Return          Return          db_query\nT4                                       Return\n</code></pre> <p>No Shared State: Each invocation has isolated WASM instance.</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#database-trigger-concurrency","title":"Database Trigger Concurrency","text":"<pre><code>-- Transaction 1\nBEGIN;\nINSERT INTO users VALUES (...);  -- Triggers function\nCOMMIT;\n\n-- Transaction 2 (concurrent)\nBEGIN;\nINSERT INTO users VALUES (...);  -- Triggers function\nCOMMIT;\n</code></pre> <p>Behavior: - Both functions invoked concurrently - No ordering guarantee - Each sees its own inserted row</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#cold-start","title":"Cold Start","text":"<p>Definition: Time to load WASM module and create instance</p> <p>Typical: 50-100ms</p> <p>Components: 1. WASM module compilation: 30ms 2. Instance creation: 10ms 3. Host function setup: 10ms</p> <p>Optimization (Future): - Module caching (reuse compiled modules) - Warm instance pool - Pre-instantiation on deploy</p>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#invocation-lifecycle","title":"Invocation Lifecycle","text":"<pre><code>1. Trigger fires\n   \u251c\u2500 HTTP: Client request\n   \u251c\u2500 Database: WAL commit\n   \u251c\u2500 Schedule: Cron tick\n   \u2514\u2500 Webhook: External POST\n\n2. Invoker: Lookup function\n   \u2514\u2500 Registry.get_by_name(name) or get_by_trigger(trigger)\n\n3. Invoker: Load WASM module\n   \u2514\u2500 Runtime.load_module(func.wasm_bytes)\n\n4. Invoker: Create instance\n   \u2514\u2500 Runtime.instantiate(module, host_functions)\n\n5. Invoker: Call handler with timeout\n   \u2514\u2500 tokio::timeout(func.config.timeout, call_handler(instance, payload))\n\n6. Function: Execute\n   \u251c\u2500 Parse event payload\n   \u251c\u2500 Call host functions (db_query, log, etc.)\n   \u2514\u2500 Return result\n\n7. Invoker: Cleanup\n   \u2514\u2500 Drop instance, free memory\n\n8. Invoker: Log invocation\n   \u2514\u2500 INSERT INTO function_invocations (...)\n\n9. Invoker: Return result to caller\n</code></pre>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#performance-characteristics","title":"Performance Characteristics","text":"Metric Typical Target Cold start 80ms &lt; 100ms Execution overhead 3ms &lt; 5ms Memory overhead 8MB &lt; 10MB Throughput 100/s &gt; 50/s Concurrent invocations 100 &gt; 100"},{"location":"FUNCTIONS_EXECUTION_MODEL/#examples","title":"Examples","text":""},{"location":"FUNCTIONS_EXECUTION_MODEL/#http-function-with-database-access","title":"HTTP Function with Database Access","text":"<pre><code>export async function handler(event) {\n  const { user_id } = event.body;\n\n  const user = await db.query(\n    \"SELECT * FROM users WHERE id = $1\",\n    [user_id]\n  );\n\n  return {\n    statusCode: 200,\n    body: JSON.stringify(user[0])\n  };\n}\n</code></pre>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#database-trigger-with-external-api","title":"Database Trigger with External API","text":"<pre><code>export async function onOrderCreated(event) {\n  const order = event.new;\n\n log.info(`Processing order ${order.id}`);\n\n  // Call external warehouse API\n  const response = await http.fetch(\"https://warehouse.example.com/ship\", {\n    method: \"POST\",\n    body: JSON.stringify(order)\n  });\n\n  // Update order status\n  await db.query(\n    \"UPDATE orders SET status = 'shipped' WHERE id = $1\",\n    [order.id]\n  );\n\n  return { shipped: true };\n}\n</code></pre>"},{"location":"FUNCTIONS_EXECUTION_MODEL/#scheduled-cleanup-job","title":"Scheduled Cleanup Job","text":"<pre><code>export async function cleanupExpiredSessions() {\n  const result = await db.query(\n    \"DELETE FROM sessions WHERE expires_at &lt; NOW()\"\n  );\n\n  log.info(`Cleaned up ${result.rowCount} expired sessions`);\n\n  return { cleaned: result.rowCount };\n}\n</code></pre>"},{"location":"FUNCTIONS_FAILURE_MODEL/","title":"Phase 12: Serverless Functions Failure Model","text":"<p>Document Type: Failure Model Phase: 12 - Serverless Functions Status: Active</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#error-classification","title":"Error Classification","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#client-errors-4xx","title":"Client Errors (4xx)","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#404-not-found","title":"404 Not Found","text":"<p>Causes: - Function doesn't exist - Function disabled</p> <p>Example: <pre><code>POST /functions/v1/invoke/nonexistent\n\u2192 404: Function not found\n</code></pre></p> <p>Recovery: Verify function name, check if deployed and enabled</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#400-bad-request","title":"400 Bad Request","text":"<p>Causes: - Invalid WASM binary - Invalid function name format - Invalid trigger configuration - Malformed invocation payload</p> <p>Example: <pre><code>POST /functions/v1/deploy\nBody: {name: \"Send Email\", wasm: &lt;invalid&gt;}\n\u2192 400: Invalid function name (contains space)\n</code></pre></p> <p>Recovery: Fix request format</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#server-errors-5xx","title":"Server Errors (5xx)","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#500-internal-server-error","title":"500 Internal Server Error","text":"<p>Causes: - WASM runtime panic - Host function error (db_query failed, etc.) - Unexpected error in function code</p> <p>Example: <pre><code>export async function handler() {\n  throw new Error(\"Unexpected error\");\n}\n\u2192 500: Function error\n</code></pre></p> <p>Recovery: Check function logs, fix function code</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#504-gateway-timeout","title":"504 Gateway Timeout","text":"<p>Causes: - Function execution exceeds timeout</p> <p>Example: <pre><code>export async function handler() {\n  while (true) { /* infinite loop */ }\n}\n\u2192 504: Function timeout after 10s\n</code></pre></p> <p>Recovery: Optimize function, increase timeout limit</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#507-insufficient-storage","title":"507 Insufficient Storage","text":"<p>Causes: - Function exceeds memory limit</p> <p>Example: <pre><code>export async function handler() {\n  const huge = new Array(1000000000);  // OOM\n}\n\u2192 507: Function exceeded memory limit (128MB)\n</code></pre></p> <p>Recovery: Optimize memory usage, increase limit</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#failure-scenarios","title":"Failure Scenarios","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#1-function-timeout","title":"1. Function Timeout","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#scenario-infinite-loop","title":"Scenario: Infinite loop","text":"<pre><code>export async function handler() {\n  let i = 0;\n  while (true) {\n    i++;  // Never returns\n  }\n}\n</code></pre> <p>Behavior: - Execution starts - After 10s (default timeout), Tokio kills task - WASM instance dropped - Error logged - Caller receives 504</p> <p>Database Impact: None (previous db_query calls already committed)</p> <p>Cleanup: Automatic (instance memory freed)</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#2-memory-exhaustion","title":"2. Memory Exhaustion","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#scenario-allocate-too-much-memory","title":"Scenario: Allocate too much memory","text":"<pre><code>export async function handler() {\n  const huge = new Array(200 * 1024 * 1024);  // 200MB\n  // Exceeds 128MB limit\n}\n</code></pre> <p>Behavior: - WASM allocation triggers store limiter check - Limit exceeded \u2192 WASM panic (\"out of memory\") - Instance dropped - Error logged - Caller receives 507</p> <p>Partial Allocations: Freed when instance dropped</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#3-database-trigger-function-failure","title":"3. Database Trigger Function Failure","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#scenario-function-fails-after-db-commit","title":"Scenario: Function fails after DB commit","text":"<pre><code>INSERT INTO users (id, email) VALUES ('uuid', 'user@example.com');\nCOMMIT;  -- Database committed\n</code></pre> <pre><code>// Trigger function\nexport async function onUserCreated(user) {\n  // This succeeds\n  await db.query(\"INSERT INTO profiles ...\");\n\n  // This fails\n  throw new Error(\"Email service down\");\n}\n</code></pre> <p>State: - User inserted: \u2713 (committed) - Profile inserted: \u2713 (committed in separate transaction) - Function: \u2717 (error)</p> <p>Recovery: - Error logged - Application continues - Function may be retried manually (future: retry policies)</p> <p>Key Point: Database trigger functions are non-transactional with triggering operation.</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#4-host-function-error","title":"4. Host Function Error","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#scenario-db_query-fails","title":"Scenario: db_query fails","text":"<pre><code>export async function handler() {\n  await db.query(\"SELECT * FROM nonexistent_table\");\n}\n</code></pre> <p>Behavior: - db_query host function executes - Query parser fails (table not found) - Error propagated to WASM - Function returns error - Caller receives 500</p> <p>Database Impact: None (query never executed)</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#5-wasm-compilation-failure","title":"5. WASM Compilation Failure","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#scenario-invalid-wasm-binary","title":"Scenario: Invalid WASM binary","text":"<pre><code>POST /functions/v1/deploy\nBody: {name: \"my-function\", wasm: &lt;corrupted binary&gt;}\n</code></pre> <p>Behavior: - Server attempts to compile WASM - Module::new() fails - Deployment rejected - Caller receives 400</p> <p>Prevention: Client-side WASM validation before upload</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#6-concurrent-invocation-limit","title":"6. Concurrent Invocation Limit","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#scenario-too-many-concurrent-invocations","title":"Scenario: Too many concurrent invocations","text":"<pre><code>1000 concurrent POST /functions/v1/invoke/slow-function\n</code></pre> <p>Behavior (Current): All invocations spawned concurrently (may overload)</p> <p>Behavior (Future with Limit): - First 100 invocations accepted - Remaining rejected with 429 (Too Many Requests) - Queued for later execution</p> <p>Mitigation: Connection pooling, rate limiting</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#cascading-failures","title":"Cascading Failures","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#database-unavailable","title":"Database Unavailable","text":"<p>Impact: - db_query host function fails - Functions cannot query database - HTTP trigger invocations fail with 500</p> <p>Mitigation: - Circuit breaker on db connection - Graceful degradation (return cached data) - Retry with exponential backoff</p> <p>Non-Impact: Functions already running continue (WASM isolated).</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#wasm-runtime-crash","title":"WASM Runtime Crash","text":"<p>Impact: - All function invocations fail - No new functions can be deployed</p> <p>Mitigation: - Restart runtime - Fallback to secondary instance - Alert ops team</p> <p>Database Impact: None (runtime is separate process)</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#scheduler-failure","title":"Scheduler Failure","text":"<p>Impact: - Scheduled functions don't run - Cron jobs missed</p> <p>Mitigation: - Scheduler health check - Restart scheduler on failure - Persistent job queue (future)</p> <p>Recovery: Re-schedule missed jobs based on last_run</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#recovery-strategies","title":"Recovery Strategies","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#1-automatic-retry-future","title":"1. Automatic Retry (Future)","text":"<p>Proposal: Retry failed invocations automatically</p> <pre><code>pub struct RetryPolicy {\n    max_retries: u32,\n    backoff: Duration,\n}\n\nasync fn invoke_with_retry(func: &amp;Function, payload: Value) -&gt; Result&lt;Value&gt; {\n    for attempt in 0..policy.max_retries {\n        match invoke(func, payload).await {\n            Ok(result) =&gt; return Ok(result),\n            Err(e) if e.is_retriable() =&gt; {\n                sleep(policy.backoff * attempt).await;\n                continue;\n            }\n            Err(e) =&gt; return Err(e),\n        }\n    }\n    Err(FunctionError::MaxRetriesExceeded)\n}\n</code></pre> <p>Retriable Errors: Timeout, database connection failure, host function transient errors</p> <p>Non-Retriable: Invalid WASM, memory limit, user code errors</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#2-dead-letter-queue-future","title":"2. Dead Letter Queue (Future)","text":"<p>Proposal: Failed invocations go to DLQ for manual inspection</p> <pre><code>async fn handle_failure(func: &amp;Function, payload: Value, error: FunctionError) {\n    dead_letter_queue.push(DeadLetter {\n        function_id: func.id,\n        payload,\n        error: error.to_string(),\n        timestamp: Utc::now(),\n    });\n}\n</code></pre> <p>Manual Recovery: Admin inspects DLQ, fixes function, retries</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#3-circuit-breaker","title":"3. Circuit Breaker","text":"<p>Proposal: Prevent cascading failures from external services</p> <pre><code>if error_rate(last_5_minutes) &gt; 50% {\n    return Err(FunctionError::CircuitOpen);\n}\n</code></pre> <p>States: - Closed: Normal operation - Open: All invocations fail fast - Half-Open: Test with single invocation</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#error-logging","title":"Error Logging","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#structured-logs","title":"Structured Logs","text":"<pre><code>{\n  \"level\": \"ERROR\",\n  \"service\": \"functions\",\n  \"operation\": \"invoke\",\n  \"function\": \"send_email\",\n  \"error\": \"504 Timeout\",\n  \"duration_ms\": 10000,\n  \"user_id\": \"uuid\",\n  \"request_id\": \"uuid\",\n  \"timestamp\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre>"},{"location":"FUNCTIONS_FAILURE_MODEL/#metrics","title":"Metrics","text":"<pre><code>functions_errors_total{name, error_type}\nfunctions_timeout_total{name}\nfunctions_memory_exceeded_total{name}\n</code></pre>"},{"location":"FUNCTIONS_FAILURE_MODEL/#alerts","title":"Alerts","text":"<ul> <li>CRITICAL: Error rate &gt; 10% for 5 minutes</li> <li>WARNING: Timeout rate &gt; 5%</li> <li>INFO: Memory limit hit</li> </ul>"},{"location":"FUNCTIONS_FAILURE_MODEL/#client-retry-strategy","title":"Client Retry Strategy","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#http-trigger-synchronous","title":"HTTP Trigger (Synchronous)","text":"<pre><code>async function invokeFunctionWithRetry(name, payload, maxRetries = 3) {\n  for (let attempt = 0; attempt &lt; maxRetries; attempt++) {\n    try {\n      return await fetch(`/functions/v1/invoke/${name}`, {\n        method: \"POST\",\n        body: JSON.stringify(payload)\n      });\n    } catch (error) {\n      if (error.status &gt;= 400 &amp;&amp; error.status &lt; 500) {\n        throw error;  // Client error - don't retry\n      }\n      if (attempt === maxRetries - 1) {\n        throw error;\n      }\n      await sleep(1000 * Math.pow(2, attempt));  // Exponential backoff\n    }\n  }\n}\n</code></pre>"},{"location":"FUNCTIONS_FAILURE_MODEL/#database-trigger-asynchronous","title":"Database Trigger (Asynchronous)","text":"<p>No Client Retry: Function invoked automatically, retry handled server-side (future).</p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#testing-failures","title":"Testing Failures","text":""},{"location":"FUNCTIONS_FAILURE_MODEL/#chaos-testing","title":"Chaos Testing","text":"<p>Inject Failures: <pre><code>rust\n#[cfg(test)]\nmod chaos_tests {\n    #[test]\n    fn test_function_timeout() {\n        // Function that sleeps 20s (exceeds 10s timeout)\n        assert_eq!(invoke(sleeping_func), Err(FunctionError::Timeout));\n    }\n\n    #[test]\n    fn test_memory_limit() {\n        // Function that allocates 256MB (exceeds 128MB limit)\n        assert_eq!(invoke(memory_hog_func), Err(FunctionError::OutOfMemory));\n    }\n\n    #[test]\n    fn test_database_down() {\n        // db_query fails with connection error\n        assert_eq!(invoke(db_func), Err(FunctionError::HostFunctionError));\n    }\n}\n</code></pre></p>"},{"location":"FUNCTIONS_FAILURE_MODEL/#failure-documentation","title":"Failure Documentation","text":"<p>Per-Error Code:</p> Error User-Facing Message Admin Action 404 Function not found Deploy function 400 Invalid request Fix request format 500 Function error Check logs, fix code 504 Function timeout Optimize or increase timeout 507 Memory exceeded Optimize or increase limit"},{"location":"FUNCTIONS_FUNCTION_MODEL/","title":"Phase 12: Function Model","text":"<p>Document Type: Data Model Specification Phase: 12 - Serverless Functions Status: Active</p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#function-structure","title":"Function Structure","text":"<pre><code>pub struct Function {\n    pub id: Uuid,\n    pub name: String,\n    pub description: String,\n    pub trigger: TriggerType,\n    pub wasm_hash: String,          // SHA-256 of WASM bytes\n    pub wasm_bytes: Vec&lt;u8&gt;,        // Raw WASM binary\n    pub config: FunctionConfig,\n    pub enabled: bool,\n    pub created_at: DateTime&lt;Utc&gt;,\n    pub updated_at: DateTime&lt;Utc&gt;,\n}\n\npub struct FunctionConfig {\n    pub timeout: Duration,          // Default: 10s\n    pub max_memory: usize,          // Default: 128MB\n    pub environment: HashMap&lt;String, String&gt;,\n}\n</code></pre>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#fields","title":"Fields","text":""},{"location":"FUNCTIONS_FUNCTION_MODEL/#id","title":"id","text":"<ul> <li>Type: UUID v4</li> <li>Purpose: Primary key</li> <li>Immutable: Yes</li> </ul>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#name","title":"name","text":"<ul> <li>Type: String</li> <li>Constraints:</li> <li>Unique across all functions</li> <li>1-64 characters</li> <li>Lowercase alphanumeric + hyphens + underscores</li> <li>Must start with letter</li> <li>Regex: <code>^[a-z][a-z0-9_-]*$</code></li> </ul> <p>Examples: <pre><code>\u2705 send_welcome_email\n\u2705 cleanup-old-data\n\u2705 process_payment\n\u274c SendEmail (uppercase)\n\u274c _cleanup (starts with underscore)\n\u274c send email (space)\n</code></pre></p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#trigger","title":"trigger","text":"<ul> <li>Type: Enum (TriggerType)</li> <li>Purpose: How function is invoked</li> <li>See: FUNCTIONS_EXECUTION_MODEL.md for details</li> </ul>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#wasm_hash","title":"wasm_hash","text":"<ul> <li>Type: String (hex SHA-256)</li> <li>Purpose: Verify WASM integrity, detect changes</li> <li>Calculate: <code>SHA256(wasm_bytes)</code></li> </ul>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#wasm_bytes","title":"wasm_bytes","text":"<ul> <li>Type: Binary blob</li> <li>Purpose: Compiled WASM module</li> <li>Size: Typically 10KB-1MB (limit: 10MB)</li> <li>Storage: In-memory for fast loading, disk backup</li> </ul>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#config","title":"config","text":"<p>Runtime configuration for this function</p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#timeout","title":"timeout","text":"<ul> <li>Default: 10 seconds</li> <li>Range: 1s - 300s (5 minutes)</li> <li>Enforcement: Tokio timeout, kills function if exceeded</li> </ul>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#max_memory","title":"max_memory","text":"<ul> <li>Default: 128 MB</li> <li>Range: 16MB - 512MB</li> <li>Enforcement: WASM store limiter</li> </ul>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#environment","title":"environment","text":"<ul> <li>Type: HashMap <li>Purpose: Environment variables accessible to function</li> <li>Security: Redact secrets in logs</li> <li>Example: <pre><code>{\n  \"DATABASE_URL\": \"postgres://...\",\n  \"API_KEY\": \"sk_***\",\n  \"ENV\": \"production\"\n}\n</code></pre></li>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#enabled","title":"enabled","text":"<ul> <li>Type: Boolean</li> <li>Purpose: Disable without deleting</li> <li>Default: true</li> <li>Behavior: Disabled functions return 404 on invocation</li> </ul>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#trigger-types","title":"Trigger Types","text":"<pre><code>pub enum TriggerType {\n    Http,\n    Database {\n        table: String,\n        operation: DatabaseOperation,  // INSERT | UPDATE | DELETE\n    },\n    Schedule {\n        cron: String,  // \"0 */6 * * *\"\n    },\n    Webhook {\n        secret: String,\n    },\n}\n\npub enum DatabaseOperation {\n    Insert,\n    Update,\n    Delete,\n}\n</code></pre> <p>See FUNCTIONS_EXECUTION_MODEL.md for trigger details.</p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#function-lifecycle","title":"Function Lifecycle","text":""},{"location":"FUNCTIONS_FUNCTION_MODEL/#deploy","title":"Deploy","text":"<pre><code>1. Client uploads WASM binary\n2. Server validates WASM (can compile?)\n3. Server calculates hash\n4. Server stores function in registry\n5. Server returns function ID\n</code></pre>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#invoke","title":"Invoke","text":"<pre><code>1. Trigger fires (HTTP, DB, Schedule)\n2. Lookup function by name or trigger\n3. Load WASM module\n4. Create instance with host functions\n5. Call handler, enforce limits\n6. Return result or error\n</code></pre>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#update","title":"Update","text":"<pre><code>1. Client uploads new WASM binary\n2. Server recomputes hash\n3. Server updates wasm_bytes, wasm_hash\n4. Old invocations use old WASM (no mid-flight updates)\n</code></pre>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#delete","title":"Delete","text":"<pre><code>1. Client deletes function\n2. Server removes from registry\n3. In-flight invocations complete\n4. New invocations return 404\n</code></pre>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#function-metadata-collection","title":"Function Metadata Collection","text":"<pre><code>CREATE COLLECTION functions (\n    id           TEXT PRIMARY KEY,\n    name         TEXT UNIQUE NOT NULL,\n    description  TEXT,\n    trigger_type TEXT NOT NULL,  -- JSON-serialized TriggerType\n    wasm_hash    TEXT NOT NULL,\n    wasm_data    BYTEA NOT NULL,  -- WASM binary\n    config       JSONB NOT NULL,\n    enabled      BOOLEAN DEFAULT TRUE,\n    created_at   TIMESTAMP NOT NULL,\n    updated_at   TIMESTAMP NOT NULL\n);\n\nCREATE INDEX idx_functions_name ON functions(name);\nCREATE INDEX idx_functions_trigger ON functions(trigger_type);\n</code></pre> <p>Example Row: <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"name\": \"send_welcome_email\",\n  \"description\": \"Send welcome email to new users\",\n  \"trigger_type\": \"{\\\"Database\\\":{\\\"table\\\":\\\"users\\\",\\\"operation\\\":\\\"Insert\\\"}}\",\n  \"wasm_hash\": \"a7ffc6f8bf1ed76651c14756a061d662...\",\n  \"wasm_data\": \"&lt;binary&gt;\",\n  \"config\": {\n    \"timeout\": 10,\n    \"max_memory\": 134217728,\n    \"environment\": {\n      \"SMTP_HOST\": \"smtp.example.com\"\n    }\n  },\n  \"enabled\": true,\n  \"created_at\": \"2026-02-06T09:00:00Z\",\n  \"updated_at\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#invocation-log-collection","title":"Invocation Log Collection","text":"<p>Track every function invocation for observability.</p> <pre><code>CREATE COLLECTION function_invocations (\n    id            TEXT PRIMARY KEY,\n    function_id   TEXT NOT NULL REFERENCES functions(id),\n    trigger       TEXT NOT NULL,  -- \"http\" | \"database\" | \"schedule\"\n    status        TEXT NOT NULL,  -- \"success\" | \"error\" | \"timeout\"\n    duration_ms   INTEGER,\n    memory_peak   INTEGER,        -- Bytes\n    error_message TEXT,\n    user_id       TEXT,           -- If invoked via HTTP with auth\n    timestamp     TIMESTAMP NOT NULL\n);\n\nCREATE INDEX idx_invocations_function ON function_invocations(function_id);\nCREATE INDEX idx_invocations_timestamp ON function_invocations(timestamp);\n</code></pre> <p>Example Row: <pre><code>{\n  \"id\": \"123e4567-e89b-12d3-a456-426614174000\",\n  \"function_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"trigger\": \"database\",\n  \"status\": \"success\",\n  \"duration_ms\": 234,\n  \"memory_peak\": 12582912,  // 12MB\n  \"error_message\": null,\n  \"user_id\": null,\n  \"timestamp\": \"2026-02-06T09:15:00Z\"\n}\n</code></pre></p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#function-operations","title":"Function Operations","text":""},{"location":"FUNCTIONS_FUNCTION_MODEL/#deploy-function","title":"Deploy Function","text":"<p>Request: <pre><code>POST /functions/v1/deploy\nAuthorization: Bearer &lt;JWT&gt;\nContent-Type: multipart/form-data\n\nname: send_welcome_email\ndescription: Send email to new users\ntrigger: {\"Database\": {\"table\": \"users\", \"operation\": \"Insert\"}}\nwasm: &lt;binary file&gt;\nconfig: {\"timeout\": 15, \"max_memory\": 134217728}\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 201 Created\nContent-Type: application/json\n\n{\n  \"id\": \"550e8400-...\",\n  \"name\": \"send_welcome_email\",\n  \"wasm_hash\": \"a7ffc6f8...\",\n  \"created_at\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p> <p>Errors: - <code>400 Bad Request</code> - Invalid WASM or configuration - <code>409 Conflict</code> - Function name already exists - <code>413 Payload Too Large</code> - WASM exceeds 10MB</p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#get-function","title":"Get Function","text":"<p>Request: <pre><code>GET /functions/v1/send_welcome_email\nAuthorization: Bearer &lt;JWT&gt;\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 200 OK\n\n{\n  \"id\": \"550e8400-...\",\n  \"name\": \"send_welcome_email\",\n  \"description\": \"Send email to new users\",\n  \"trigger\": {\"Database\": {\"table\": \"users\", \"operation\": \"Insert\"}},\n  \"config\": {\"timeout\": 15, \"max_memory\": 134217728},\n  \"enabled\": true,\n  \"invocation_count\": 1234,\n  \"last_invocation\": \"2026-02-06T09:15:00Z\"\n}\n</code></pre></p> <p>Note: WASM binary NOT returned (too large), only hash</p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#update-function","title":"Update Function","text":"<p>Request: <pre><code>PATCH /functions/v1/send_welcome_email\nAuthorization: Bearer &lt;JWT&gt;\nContent-Type: application/json\n\n{\n  \"config\": {\n    \"timeout\": 20\n  }\n}\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 200 OK\n\n{\n  \"id\": \"550e8400-...\",\n  \"config\": {\"timeout\": 20, \"max_memory\": 134217728},\n  \"updated_at\": \"2026-02-06T10:00:00Z\"\n}\n</code></pre></p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#delete-function","title":"Delete Function","text":"<p>Request: <pre><code>DELETE /functions/v1/send_welcome_email\nAuthorization: Bearer &lt;JWT&gt;\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 204 No Content\n</code></pre></p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#invoke-function-http-trigger","title":"Invoke Function (HTTP Trigger)","text":"<p>Request: <pre><code>POST /functions/v1/invoke/send_welcome_email\nAuthorization: Bearer &lt;JWT&gt;\nContent-Type: application/json\n\n{\n  \"email\": \"user@example.com\",\n  \"name\": \"Alice\"\n}\n</code></pre></p> <p>Response (Success): <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"status\": \"sent\",\n  \"message_id\": \"abc123\"\n}\n</code></pre></p> <p>Response (Error): <pre><code>HTTP/1.1 500 Internal Server Error\n\n{\n  \"error\": \"Function error\",\n  \"message\": \"SMTP connection failed\",\n  \"code\": \"HOST_FUNCTION_ERROR\"\n}\n</code></pre></p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#validation-rules","title":"Validation Rules","text":""},{"location":"FUNCTIONS_FUNCTION_MODEL/#wasm-validation","title":"WASM Validation","text":"<pre><code>pub fn validate_wasm(bytes: &amp;[u8]) -&gt; Result&lt;()&gt; {\n    // Must compile\n    let engine = Engine::default();\n    Module::new(&amp;engine, bytes)?;\n\n    // Size limit\n    if bytes.len() &gt; 10 * 1024 * 1024 {\n        return Err(FunctionError::WasmTooLarge);\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#name-validation","title":"Name Validation","text":"<pre><code>pub fn validate_function_name(name: &amp;str) -&gt; Result&lt;()&gt; {\n    if name.is_empty() || name.len() &gt; 64 {\n        return Err(FunctionError::InvalidName(\"Length must be 1-64\"));\n    }\n\n    let regex = Regex::new(r\"^[a-z][a-z0-9_-]*$\").unwrap();\n    if !regex.is_match(name) {\n        return Err(FunctionError::InvalidName(\"Invalid format\"));\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#invariants","title":"Invariants","text":""},{"location":"FUNCTIONS_FUNCTION_MODEL/#func-i1-name-uniqueness","title":"FUNC-I1: Name Uniqueness","text":"<p>No two functions have the same name</p> <p>Enforcement: UNIQUE constraint on <code>name</code> field</p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#func-i2-hash-integrity","title":"FUNC-I2: Hash Integrity","text":"<p>wasm_hash = SHA256(wasm_bytes)</p> <p>Verification: Recalculate hash on load, compare</p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#func-i3-resource-limits-enforced","title":"FUNC-I3: Resource Limits Enforced","text":"<p>All invocations respect timeout and memory limits</p> <p>Enforcement: Tokio timeout + WASM store limiter</p>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#examples","title":"Examples","text":""},{"location":"FUNCTIONS_FUNCTION_MODEL/#http-function","title":"HTTP Function","text":"<pre><code>Function {\n    name: \"get_user_stats\",\n    trigger: TriggerType::Http,\n    config: FunctionConfig {\n        timeout: Duration::from_secs(5),\n        max_memory: 64 * 1024 * 1024,  // 64MB\n        ...\n    },\n}\n</code></pre>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#database-trigger","title":"Database Trigger","text":"<pre><code>Function {\n    name: \"on_order_created\",\n    trigger: TriggerType::Database {\n        table: \"orders\",\n        operation: DatabaseOperation::Insert,\n    },\n    config: FunctionConfig::default(),\n}\n</code></pre>"},{"location":"FUNCTIONS_FUNCTION_MODEL/#scheduled-job","title":"Scheduled Job","text":"<pre><code>Function {\n    name: \"cleanup_old_logs\",\n    trigger: TriggerType::Schedule {\n        cron: \"0 3 * * *\",  // Daily at 3 AM\n    },\n    config: FunctionConfig {\n        timeout: Duration::from_secs(300),  // 5 minutes\n        ...\n    },\n}\n</code></pre>"},{"location":"FUNCTIONS_INVARIANTS/","title":"Phase 12: Serverless Functions Invariants","text":"<p>Document Type: Invariants Specification Phase: 12 - Serverless Functions Status: Active</p>"},{"location":"FUNCTIONS_INVARIANTS/#core-invariants","title":"Core Invariants","text":""},{"location":"FUNCTIONS_INVARIANTS/#func-i1-sandbox-isolation","title":"FUNC-I1: Sandbox Isolation","text":"<p>Functions cannot escape WASM sandbox</p> <p>Formal Statement: <pre><code>\u2200 function f, invocation i:\n  execute(f, i) \u2192 memory_isolated(f) \u2227 no_filesystem_access(f) \u2227 no_raw_sockets(f)\n</code></pre></p> <p>Enforcement: - WASM sandbox by design (no syscalls) - Host functions are only escape mechanism - Memory mapped private per instance</p> <p>Violation Consequences: - Security breach - Cross-function data leakage - System compromise</p>"},{"location":"FUNCTIONS_INVARIANTS/#func-i2-resource-limits-enforced","title":"FUNC-I2: Resource Limits Enforced","text":"<p>All invocations respect timeout and memory limits</p> <p>Formal Statement: <pre><code>\u2200 invocation i with config c:\n  execution_time(i) &gt; c.timeout \u2192 terminate(i) \u2227 error(\"Timeout\")\n  memory_usage(i) &gt; c.max_memory \u2192 panic(i) \u2227 error(\"OutOfMemory\")\n</code></pre></p> <p>Enforcement: <pre><code>tokio::timeout(config.timeout, execute);\nstore.limiter(|_| ResourceLimiter { memory_size: config.max_memory });\n</code></pre></p> <p>Violation Consequences: - Runaway functions consume resources - System instability - Denial of service</p>"},{"location":"FUNCTIONS_INVARIANTS/#func-i3-rls-enforced-on-host-functions","title":"FUNC-I3: RLS Enforced on Host Functions","text":"<p>Host functions respect RLS context</p> <p>Formal Statement: <pre><code>\u2200 host_call h in function f with context c:\n  h(db_query, sql) \u2192 enforce_rls(sql, c)\n</code></pre></p> <p>Enforcement: <pre><code>fn db_query_host(sql: &amp;str) -&gt; Result&lt;Vec&lt;Row&gt;&gt; {\n    let query = parse_sql(sql)?;\n    executor.execute(query, &amp;rls_context)?  // \u2b05\ufe0f RLS context from invocation\n}\n</code></pre></p> <p>Violation Consequences: - Unauthorized data access - RLS bypass - Security breach</p> <p>Service Role Exception: Explicit bypass via <code>can_bypass_rls</code> flag.</p>"},{"location":"FUNCTIONS_INVARIANTS/#func-i4-function-errors-isolated","title":"FUNC-I4: Function Errors Isolated","text":"<p>Function failures do NOT crash database</p> <p>Formal Statement: <pre><code>\u2200 function f, error e:\n  execute(f) = Err(e) \u2192 log(e) \u2227 database_unaffected\n</code></pre></p> <p>Enforcement: <pre><code>match invoke_function(func, payload) {\n    Ok(result) =&gt; Ok(result),\n    Err(e) =&gt; {\n        log::error!(\"Function '{}' failed: {}\", func.name, e);\n        Err(e)  // Database continues normally\n    }\n}\n</code></pre></p> <p>Implication: Functions are non-transactional with database operations.</p>"},{"location":"FUNCTIONS_INVARIANTS/#func-i5-hash-integrity","title":"FUNC-I5: Hash Integrity","text":"<p>wasm_hash matches wasm_bytes</p> <p>Formal Statement: <pre><code>\u2200 function f:\n  f.wasm_hash = SHA256(f.wasm_bytes)\n</code></pre></p> <p>Enforcement: <pre><code>pub fn verify_hash(func: &amp;Function) -&gt; Result&lt;()&gt; {\n    let mut hasher = Sha256::new();\n    hasher.update(&amp;func.wasm_bytes);\n    let actual_hash = format!(\"{:x}\", hasher.finalize());\n\n    if actual_hash != func.wasm_hash {\n        return Err(FunctionError::HashMismatch);\n    }\n    Ok(())\n}\n</code></pre></p> <p>Purpose: Detect corruption, ensure deployed WASM matches expected.</p>"},{"location":"FUNCTIONS_INVARIANTS/#execution-invariants","title":"Execution Invariants","text":""},{"location":"FUNCTIONS_INVARIANTS/#func-e1-invocation-logging","title":"FUNC-E1: Invocation Logging","text":"<p>Every invocation is logged</p> <p>Guarantee: <pre><code>invoke(f, payload) \u2192 INSERT INTO function_invocations (...)\n</code></pre></p> <p>Fields Logged: - function_id, trigger, status, duration_ms, memory_peak, error_message, timestamp</p> <p>Purpose: Observability, debugging, auditing</p>"},{"location":"FUNCTIONS_INVARIANTS/#func-e2-concurrent-invocations-isolated","title":"FUNC-E2: Concurrent Invocations Isolated","text":"<p>Concurrent invocations have separate WASM instances</p> <p>Guarantee: <pre><code>\u2200 invocations i1, i2 of function f:\n  i1.instance \u2260 i2.instance \u2227 no_shared_memory(i1, i2)\n</code></pre></p> <p>Enforcement: New WASM instance per invocation</p> <p>Implication: No state persists between invocations.</p>"},{"location":"FUNCTIONS_INVARIANTS/#func-e3-determinism-boundary","title":"FUNC-E3: Determinism Boundary","text":"<p>Functions are explicitly non-deterministic</p> <p>Guarantee: <pre><code>replay(database_operations) \u2192 deterministic\nreplay(function_invocations) \u2192 UNDEFINED (non-deterministic)\n</code></pre></p> <p>Rationale: - User code behavior undefined - External API calls non-deterministic - Time-based logic non-deterministic</p> <p>Implication: Functions cannot be part of deterministic replay.</p>"},{"location":"FUNCTIONS_INVARIANTS/#security-invariants","title":"Security Invariants","text":""},{"location":"FUNCTIONS_INVARIANTS/#func-s1-secrets-not-logged","title":"FUNC-S1: Secrets Not Logged","text":"<p>Environment variables with sensitive data are redacted</p> <p>Guarantee: <pre><code>log_invocation(i) \u2192 redact(i.config.environment, sensitive_keys)\n</code></pre></p> <p>Sensitive Keys: API_KEY, SECRET, PASSWORD, TOKEN</p> <p>Example: <pre><code>{\n  \"environment\": {\n    \"API_KEY\": \"***REDACTED***\",\n    \"ENV\": \"production\"\n  }\n}\n</code></pre></p>"},{"location":"FUNCTIONS_INVARIANTS/#func-s2-no-filesystem-access","title":"FUNC-S2: No Filesystem Access","text":"<p>Functions cannot read/write filesystem</p> <p>Guarantee: <pre><code>\u2200 wasm_call c:\n  c \u2209 {open, read, write, unlink, ...}  # No syscalls\n</code></pre></p> <p>Enforcement: WASM has no syscall interface (unless WASI enabled)</p> <p>Future: WASI with explicit file handle grants</p>"},{"location":"FUNCTIONS_INVARIANTS/#func-s3-network-access-restricted","title":"FUNC-S3: Network Access Restricted","text":"<p>Functions cannot open raw sockets</p> <p>Guarantee: <pre><code>\u2200 wasm_call c:\n  c \u2209 {socket, connect, bind, listen}\n</code></pre></p> <p>Network Access: Only via <code>http_fetch</code> host function (controlled)</p>"},{"location":"FUNCTIONS_INVARIANTS/#failure-invariants","title":"Failure Invariants","text":""},{"location":"FUNCTIONS_INVARIANTS/#func-f1-timeout-cleanup","title":"FUNC-F1: Timeout Cleanup","text":"<p>Timed-out functions are terminated and cleaned up</p> <p>Guarantee: <pre><code>execution_time(f) &gt; timeout \u2192 terminate(f) \u2227 free_memory(f)\n</code></pre></p> <p>Enforcement: Tokio timeout drops future, WASM instance dropped</p>"},{"location":"FUNCTIONS_INVARIANTS/#func-f2-partial-work-not-rolled-back","title":"FUNC-F2: Partial Work Not Rolled Back","text":"<p>Database writes committed even if function fails</p> <p>Scenario: <pre><code>export async function handler() {\n  await db.query(\"INSERT INTO logs ...\");  // Committed\n  throw new Error(\"Oops\");                 // Function fails\n}\n</code></pre></p> <p>Guarantee: <pre><code>db.query succeeds \u2192 commit (even if function later fails)\n</code></pre></p> <p>Rationale: Functions are non-transactional.</p>"},{"location":"FUNCTIONS_INVARIANTS/#func-f3-idempotent-cleanup","title":"FUNC-F3: Idempotent Cleanup","text":"<p>Invocation cleanup is idempotent</p> <p>Guarantee: <pre><code>cleanup(invocation) \u2192 cleanup(invocation) = no-op\n</code></pre></p> <p>Enforcement: - WASM instance dropped once - Logs inserted once - Memory freed once</p>"},{"location":"FUNCTIONS_INVARIANTS/#trigger-invariants","title":"Trigger Invariants","text":""},{"location":"FUNCTIONS_INVARIANTS/#func-t1-database-triggers-fire-after-commit","title":"FUNC-T1: Database Triggers Fire After Commit","text":"<p>Database triggers invoked after WAL commit</p> <p>Guarantee: <pre><code>BEGIN;\n  INSERT INTO users ...;\n  # Function NOT invoked yet\nCOMMIT;\n# Now function invoked\n</code></pre></p> <p>Implication: Trigger sees committed data, cannot rollback triggering transaction.</p>"},{"location":"FUNCTIONS_INVARIANTS/#func-t2-schedule-triggers-fire-once-per-cron-match","title":"FUNC-T2: Schedule Triggers Fire Once Per Cron Match","text":"<p>Scheduled functions invoked once per cron expression match</p> <p>Guarantee: <pre><code>cron_expression matches time T \u2192 invoke_once(f, T)\n</code></pre></p> <p>No Duplicate Invocations: Scheduler tracks last_run, updates next_run.</p>"},{"location":"FUNCTIONS_INVARIANTS/#func-t3-http-triggers-synchronous","title":"FUNC-T3: HTTP Triggers Synchronous","text":"<p>HTTP trigger waits for function result</p> <p>Guarantee: <pre><code>POST /functions/v1/invoke/f \u2192 invoke(f) \u2192 wait_for_result \u2192 return response\n</code></pre></p> <p>Contrast with Database/Schedule: Async (fire-and-forget).</p>"},{"location":"FUNCTIONS_INVARIANTS/#invariant-testing-matrix","title":"Invariant Testing Matrix","text":"Invariant Unit Test Integration Test Stress Test FUNC-I1 \u2705 Sandbox checks \u2705 Syscall denial - FUNC-I2 \u2705 Timeout/memory \u2705 Runaway function \u2705 100 concurrent FUNC-I3 \u2705 RLS enforcement \u2705 Multi-user - FUNC-I4 \u2705 Error isolation \u2705 Panic recovery - FUNC-I5 \u2705 Hash verify \u2705 Deploy+invoke - FUNC-E1 \u2705 Log insertion \u2705 E2E invocation - FUNC-E2 \u2705 Instance isolation \u2705 Concurrent invoke \u2705 1000 parallel FUNC-S1 \u2705 Secret redaction \u2705 Log inspection - FUNC-T1 \u2705 Trigger timing \u2705 DB trigger - FUNC-T2 \u2705 Cron scheduling \u2705 No duplicates - FUNC-T3 \u2705 HTTP sync \u2705 Request/response -"},{"location":"FUNCTIONS_INVARIANTS/#invariant-monitoring","title":"Invariant Monitoring","text":""},{"location":"FUNCTIONS_INVARIANTS/#runtime-checks","title":"Runtime Checks","text":"<ul> <li>Hash verification on function load</li> <li>Resource limit enforcement on every invocation</li> <li>RLS context validation before db_query</li> </ul>"},{"location":"FUNCTIONS_INVARIANTS/#alerts","title":"Alerts","text":"<ul> <li>Function timeout rate &gt; 10% \u2192 WARNING</li> <li>Function error rate &gt; 5% \u2192 CRITICAL</li> <li>Memory limit hit rate &gt; 1% \u2192 WARNING</li> <li>Concurrent invocations &gt; 1000 \u2192 INFO</li> </ul>"},{"location":"FUNCTIONS_READINESS/","title":"Phase 12: Readiness Checklist","text":"<p>Document Type: Readiness Checklist Phase: 12 - Serverless Functions Status: In Progress</p>"},{"location":"FUNCTIONS_READINESS/#documentation-checklist","title":"Documentation Checklist","text":"<ul> <li> FUNCTIONS_VISION.md - Goals and philosophy</li> <li> FUNCTIONS_ARCHITECTURE.md - WASM runtime and components</li> <li> FUNCTIONS_FUNCTION_MODEL.md - Function structure and metadata</li> <li> FUNCTIONS_EXECUTION_MODEL.md - Trigger types and execution flow</li> <li> FUNCTIONS_INVARIANTS.md - Security and isolation invariants</li> <li> FUNCTIONS_FAILURE_MODEL.md - Error handling and recovery</li> <li> FUNCTIONS_TESTING_STRATEGY.md - Test coverage plan</li> <li> FUNCTIONS_READINESS.md - Freeze criteria (this document)</li> </ul> <p>Status: \u2705 All 8 documents complete</p>"},{"location":"FUNCTIONS_READINESS/#implementation-checklist","title":"Implementation Checklist","text":""},{"location":"FUNCTIONS_READINESS/#core-modules","title":"Core Modules","text":"<ul> <li> <code>src/functions/mod.rs</code> - Module entry point</li> <li> <code>src/functions/errors.rs</code> - Function error types</li> <li> <code>src/functions/function.rs</code> - Function model and config</li> <li> <code>src/functions/trigger.rs</code> - Trigger types (HTTP, DB, Schedule)</li> <li> <code>src/functions/registry.rs</code> - Function registry with indexing</li> <li> <code>src/functions/runtime.rs</code> - WASM runtime integration (wasmer/wasmtime)</li> <li> <code>src/functions/invoker.rs</code> - Function execution with limits</li> <li> <code>src/functions/scheduler.rs</code> - Cron job scheduler</li> <li> <code>src/functions/host_functions.rs</code> - Host function implementations</li> </ul> <p>Priority: runtime.rs requires WASM integration (external dependency)</p>"},{"location":"FUNCTIONS_READINESS/#api-endpoints","title":"API Endpoints","text":"<ul> <li> POST <code>/functions/v1/deploy</code> - Deploy new function</li> <li> GET <code>/functions/v1/{name}</code> - Get function metadata</li> <li> PATCH <code>/functions/v1/{name}</code> - Update function config</li> <li> DELETE <code>/functions/v1/{name}</code> - Undeploy function</li> <li> POST <code>/functions/v1/invoke/{name}</code> - Invoke HTTP trigger</li> <li> GET <code>/functions/v1/{name}/logs</code> - Get invocation logs</li> </ul>"},{"location":"FUNCTIONS_READINESS/#wasm-runtime","title":"WASM Runtime","text":"<ul> <li> Integrate wasmer or wasmtime</li> <li> Module compilation and caching</li> <li> Instance creation with host functions</li> <li> Timeout enforcement (Tokio)</li> <li> Memory limit enforcement (store limiter)</li> <li> Stack limit enforcement</li> </ul>"},{"location":"FUNCTIONS_READINESS/#host-functions","title":"Host Functions","text":"<ul> <li> <code>db_query</code> - Query database with RLS</li> <li> <code>log</code> - Write logs</li> <li> <code>env</code> - Get environment variables</li> <li> <code>http_fetch</code> - External HTTP requests (future)</li> </ul>"},{"location":"FUNCTIONS_READINESS/#triggers","title":"Triggers","text":"<ul> <li> HTTP trigger - Synchronous invocation</li> <li> Database trigger - Fire on INSERT/UPDATE/DELETE</li> <li> Schedule trigger - Cron-based execution</li> <li> Webhook trigger - External POST with signature (future)</li> </ul>"},{"location":"FUNCTIONS_READINESS/#metadata-storage","title":"Metadata Storage","text":"<ul> <li> <code>functions</code> collection schema</li> <li> <code>function_invocations</code> collection schema</li> <li> Executor integration for metadata queries</li> </ul>"},{"location":"FUNCTIONS_READINESS/#test-checklist","title":"Test Checklist","text":""},{"location":"FUNCTIONS_READINESS/#unit-tests","title":"Unit Tests","text":"<ul> <li> Registry operations (&gt; 10 tests)</li> <li> Runtime module loading (&gt; 8 tests)</li> <li> Invoker execution (&gt; 15 tests)</li> <li> Scheduler cron parsing (&gt; 10 tests)</li> <li> Host functions (&gt; 10 tests)</li> <li> Error handling (&gt; 10 tests)</li> </ul> <p>Target: &gt; 60 unit tests, &gt; 90% coverage</p>"},{"location":"FUNCTIONS_READINESS/#integration-tests","title":"Integration Tests","text":"<ul> <li> HTTP function E2E</li> <li> Database trigger E2E</li> <li> Schedule trigger E2E</li> <li> RLS enforcement with functions</li> <li> Concurrent invocations</li> </ul> <p>Target: &gt; 10 integration tests</p>"},{"location":"FUNCTIONS_READINESS/#stress-tests","title":"Stress Tests","text":"<ul> <li> 1000 concurrent invocations</li> <li> Memory leak detection</li> <li> Timeout enforcement under load</li> </ul>"},{"location":"FUNCTIONS_READINESS/#security-tests","title":"Security Tests","text":"<ul> <li> RLS bypass attempts blocked</li> <li> Secrets redacted in logs</li> <li> Sandbox escape attempts blocked</li> </ul>"},{"location":"FUNCTIONS_READINESS/#invariant-validation","title":"Invariant Validation","text":"<p>Each invariant must have tests proving it holds:</p> Invariant Test Coverage Status FUNC-I1: Sandbox Isolation Security tests \u2b1c FUNC-I2: Resource Limits Stress tests \u2b1c FUNC-I3: RLS Enforced Integration tests \u2b1c FUNC-I4: Error Isolation Failure injection \u2b1c FUNC-I5: Hash Integrity Deploy tests \u2b1c FUNC-E1: Logging Integration tests \u2b1c FUNC-E2: Concurrency Stress tests \u2b1c FUNC-T1: DB Trigger Timing Integration tests \u2b1c"},{"location":"FUNCTIONS_READINESS/#performance-benchmarks","title":"Performance Benchmarks","text":"Metric Target Actual Status Cold start (p95) &lt; 100ms - \u2b1c Execution overhead (p95) &lt; 5ms - \u2b1c Throughput &gt; 50/s - \u2b1c Concurrent invocations &gt; 100 - \u2b1c"},{"location":"FUNCTIONS_READINESS/#integration-points","title":"Integration Points","text":""},{"location":"FUNCTIONS_READINESS/#aerodb-core","title":"AeroDB Core","text":"<ul> <li> Executor integration for db_query host function</li> <li> WAL integration for database triggers</li> <li> RLS context from auth module</li> </ul>"},{"location":"FUNCTIONS_READINESS/#rest-api-phase-9","title":"REST API (Phase 9)","text":"<ul> <li> Function endpoints registered</li> <li> Multipart upload for WASM binaries</li> <li> Error mapping to HTTP status codes</li> </ul>"},{"location":"FUNCTIONS_READINESS/#authentication-phase-8","title":"Authentication (Phase 8)","text":"<ul> <li> RLS context passed to all invocations</li> <li> Service role bypass tested</li> <li> JWT validation for HTTP triggers</li> </ul>"},{"location":"FUNCTIONS_READINESS/#real-time-phase-10","title":"Real-Time (Phase 10)","text":"<ul> <li> Function writes propagate to event log</li> <li> Events visible to subscribers</li> </ul>"},{"location":"FUNCTIONS_READINESS/#external-dependencies","title":"External Dependencies","text":""},{"location":"FUNCTIONS_READINESS/#wasm-runtime_1","title":"WASM Runtime","text":"<p>Option 1: wasmer (Recommended) <pre><code>[dependencies]\nwasmer = \"4.0\"\nwasmer-wasi = \"4.0\"\n</code></pre></p> <p>Option 2: wasmtime <pre><code>[dependencies]\nwasmtime = \"15.0\"\n</code></pre></p> <p>Decision: Choose wasmer for better resource limit API</p>"},{"location":"FUNCTIONS_READINESS/#cron-parser","title":"Cron Parser","text":"<pre><code>[dependencies]\ncron = \"0.12\"\n</code></pre>"},{"location":"FUNCTIONS_READINESS/#deployment-checklist","title":"Deployment Checklist","text":""},{"location":"FUNCTIONS_READINESS/#configuration","title":"Configuration","text":"<ul> <li> <code>functions.timeout_default</code> = 10s</li> <li> <code>functions.memory_default</code> = 128MB</li> <li> <code>functions.wasm_max_size</code> = 10MB</li> <li> <code>functions.concurrent_limit</code> = 1000</li> </ul>"},{"location":"FUNCTIONS_READINESS/#migration","title":"Migration","text":"<ul> <li> Create <code>functions</code> schema</li> <li> Create <code>function_invocations</code> schema</li> <li> Index on function name</li> <li> Index on trigger type</li> </ul>"},{"location":"FUNCTIONS_READINESS/#monitoring","title":"Monitoring","text":"<ul> <li> Metrics: invocations, duration, errors</li> <li> Metrics: cold start latency</li> <li> Logs: function invocation with context</li> <li> Alerts: error rate &gt; 5%, timeout rate &gt; 10%</li> </ul>"},{"location":"FUNCTIONS_READINESS/#freeze-criteria","title":"Freeze Criteria","text":"<p>Phase 12 can be frozen when:</p> <ol> <li>\u2705 All 8 documentation files complete</li> <li>\u2b1c All 9 core modules implemented</li> <li>\u2b1c WASM runtime integrated (wasmer)</li> <li>\u2b1c All 6 API endpoints working</li> <li>\u2b1c All 4 host functions implemented</li> <li>\u2b1c All 3 trigger types working (HTTP, DB, Schedule)</li> <li>\u2b1c Metadata stored in AeroDB via executor</li> <li>\u2b1c All 8 invariants have test coverage</li> <li>\u2b1c &gt; 60 unit tests passing</li> <li>\u2b1c &gt; 10 integration tests passing</li> <li>\u2b1c Performance benchmarks meet targets</li> <li>\u2b1c Timeout and memory limits enforced</li> <li>\u2b1c RLS enforcement verified</li> </ol> <p>Current Status: \ud83d\udd34 NOT READY (docs complete, implementation needed)</p>"},{"location":"FUNCTIONS_READINESS/#known-limitations-deferred","title":"Known Limitations (Deferred)","text":"<ul> <li>WASI support for filesystem/network access</li> <li>Multi-language SDKs (JavaScript, Python compile to WASM)</li> <li>Function-to-function calls</li> <li>Warm instance pooling (cold start optimization)</li> <li>Retry policies for failed invocations</li> <li>Dead letter queue for errors</li> <li>Distributed tracing</li> <li>Custom npm/pip packages in functions</li> <li>Webhook signature verification</li> <li>Rate limiting per function</li> </ul> <p>These are explicitly deferred to keep Phase 12 focused on core WASM execution.</p>"},{"location":"FUNCTIONS_READINESS/#risk-assessment","title":"Risk Assessment","text":"Risk Mitigation Owner WASM runtime complexity Use battle-tested wasmer Core team Resource limit bypass Sandbox + limits enforced Security team Function errors crash DB Explicit isolation, non-transactional Core team Cold start latency Module caching, pre-compilation Performance team Concurrent invocation DoS Connection pooling, rate limits Infrastructure team"},{"location":"FUNCTIONS_READINESS/#sign-off-required","title":"Sign-Off Required","text":"<ul> <li> Lead Engineer: Core implementation review</li> <li> Security: Sandbox and RLS review</li> <li> QA: Test coverage and edge cases</li> <li> Docs: All 8 documents complete (\u2705 DONE)</li> <li> Performance: Benchmarks meet targets</li> <li> DevOps: WASM runtime dependencies ready</li> </ul>"},{"location":"FUNCTIONS_TESTING_STRATEGY/","title":"Phase 12: Testing Strategy","text":"<p>Document Type: Testing Strategy Phase: 12 - Serverless Functions Status: Active</p>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#test-coverage-goals","title":"Test Coverage Goals","text":"Component Target Focus Areas Function registry 95% CRUD, indexing, concurrency WASM runtime (stubbed) 90% Module loading, resource limits Invoker 95% Execution, timeout, error handling Scheduler 90% Cron parsing, job execution Host functions 95% db_query, log, RLS enforcement Triggers 90% HTTP, database, schedule"},{"location":"FUNCTIONS_TESTING_STRATEGY/#unit-tests","title":"Unit Tests","text":""},{"location":"FUNCTIONS_TESTING_STRATEGY/#registry-tests","title":"Registry Tests","text":"<pre><code>#[test]\nfn test_register_function()\nfn test_duplicate_name_errors()\nfn test_get_by_name()\nfn test_get_by_trigger()\nfn test_unregister()\nfn test_concurrent_registration()\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#runtime-tests","title":"Runtime Tests","text":"<pre><code>#[test]\nfn test_load_valid_wasm()\nfn test_invalid_wasm_rejected()\nfn test_timeout_enforcement()\nfn test_memory_limit_enforcement()\nfn test_cold_start_performance()\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#invoker-tests","title":"Invoker Tests","text":"<pre><code>#[test]\nfn test_invoke_http_function()\nfn test_invoke_with_rls_context()\nfn test_disabled_function_returns_error()\nfn test_timeout_kills_function()\nfn test_memory_exceeded_error()\nfn test_invocation_logged()\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#scheduler-tests","title":"Scheduler Tests","text":"<pre><code>#[test]\nfn test_parse_cron_expression()\nfn test_calculate_next_run()\nfn test_get_due_jobs()\nfn test_invalid_cron_rejected()\nfn test_job_invocation()\nfn test_concurrent_jobs()\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#integration-tests","title":"Integration Tests","text":""},{"location":"FUNCTIONS_TESTING_STRATEGY/#end-to-end-scenarios","title":"End-to-End Scenarios","text":""},{"location":"FUNCTIONS_TESTING_STRATEGY/#1-http-function-flow","title":"1. HTTP Function Flow","text":"<pre><code>#[tokio::test]\nasync fn test_http_function_e2e() {\n    // 1. Deploy function\n    let func = deploy_function(\"hello\", http_trigger, hello_wasm).await?;\n\n    // 2. Invoke function\n    let response = invoke_http(\"hello\", json!({\"name\": \"World\"})).await?;\n\n    // 3. Verify response\n    assert_eq!(response.status, 200);\n    assert_eq!(response.body[\"message\"], \"Hello, World!\");\n\n    // 4. Verify invocation logged\n    let logs = query_invocations(func.id).await?;\n    assert_eq!(logs.len(), 1);\n    assert_eq!(logs[0].status, \"success\");\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#2-database-trigger-flow","title":"2. Database Trigger Flow","text":"<pre><code>#[tokio::test]\nasync fn test_database_trigger_e2e() {\n    // 1. Deploy database trigger function\n    let func = deploy_function(\n        \"on_user_created\",\n        database_trigger(\"users\", \"INSERT\"),\n        create_profile_wasm\n    ).await?;\n\n    // 2. Insert user (triggers function)\n    db.execute(\"INSERT INTO users (id, email) VALUES ($1, $2)\", \n               [\"uuid\", \"user@example.com\"]).await?;\n\n    // 3. Wait for async trigger\n    sleep(Duration::from_millis(100)).await;\n\n    // 4. Verify profile created\n    let profiles = db.query(\"SELECT * FROM profiles WHERE user_id = $1\", [\"uuid\"]).await?;\n    assert_eq!(profiles.len(), 1);\n\n    // 5. Verify function invoked\n    let logs = query_invocations(func.id).await?;\n    assert_eq!(logs[0].trigger, \"database\");\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#3-scheduled-job-flow","title":"3. Scheduled Job Flow","text":"<pre><code>#[tokio::test]\nasync fn test_schedule_trigger_e2e() {\n    // 1. Deploy scheduled function (every minute)\n    let func = deploy_function(\n        \"cleanup_job\",\n        schedule_trigger(\"* * * * *\"),\n        cleanup_wasm\n    ).await?;\n\n    // 2. Wait for job to run\n    sleep(Duration::from_secs(61)).await;\n\n    // 3. Verify function invoked\n    let logs = query_invocations(func.id).await?;\n    assert!(logs.len() &gt;= 1);\n    assert_eq!(logs[0].trigger, \"schedule\");\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#host-function-tests","title":"Host Function Tests","text":""},{"location":"FUNCTIONS_TESTING_STRATEGY/#db_query-tests","title":"db_query Tests","text":"<pre><code>#[test]\nfn test_db_query_respects_rls() {\n    let context = RlsContext { user_id: Some(user_a_id), ... };\n\n    // User A can query their own data\n    let result = db_query_host(\"SELECT * FROM users WHERE id = $1\", [user_a_id], &amp;context)?;\n    assert_eq!(result.len(), 1);\n\n    // User A cannot query user B's data (RLS blocks)\n    let result = db_query_host(\"SELECT * FROM users WHERE id = $1\", [user_b_id], &amp;context)?;\n    assert_eq!(result.len(), 0);\n}\n\n#[test]\nfn test_db_query_service_role_bypass() {\n    let context = RlsContext { can_bypass_rls: true, ... };\n\n    // Service role can query all data\n    let result = db_query_host(\"SELECT * FROM users\", [], &amp;context)?;\n    assert_eq!(result.len(), 2);  // All users\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#log-tests","title":"log Tests","text":"<pre><code>#[test]\nfn test_log_host_function() {\n    log_host(\"info\", \"Test message\");\n\n    // Verify log written\n    let logs = capture_logs();\n    assert!(logs.contains(\"[Function] Test message\"));\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#stress-tests","title":"Stress Tests","text":""},{"location":"FUNCTIONS_TESTING_STRATEGY/#concurrent-invocations","title":"Concurrent Invocations","text":"<pre><code>#[tokio::test]\nasync fn test_1000_concurrent_invocations() {\n    let func = deploy_function(\"fast\", http_trigger, fast_wasm).await?;\n\n    let mut tasks = vec![];\n    for i in 0..1000 {\n        tasks.push(tokio::spawn(invoke_http(\"fast\", json!({\"id\": i}))));\n    }\n\n    let results = futures::future::join_all(tasks).await;\n\n    // All invocations succeed\n    assert_eq!(results.iter().filter(|r| r.is_ok()).count(), 1000);\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#memory-leak-detection","title":"Memory Leak Detection","text":"<pre><code>#[test]\nfn test_no_memory_leak_after_1000_invocations() {\n    let initial_memory = get_memory_usage();\n\n    for _ in 0..1000 {\n        invoke_and_wait(\"simple_function\", json!({}));\n    }\n\n    let final_memory = get_memory_usage();\n\n    // Memory usage should not grow significantly\n    assert!(final_memory - initial_memory &lt; 10 * 1024 * 1024);  // &lt; 10MB growth\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#failure-injection","title":"Failure Injection","text":"Scenario Expected Behavior Function timeout Error 504, invocation logged, instance cleaned up Memory exceeded Error 507, WASM panic, instance dropped Invalid WASM Error 400, deployment rejected db_query fails Error 500, function error logged Database down Error 500, circuit breaker (future) Concurrent limit Error 429 (future), queue invocation"},{"location":"FUNCTIONS_TESTING_STRATEGY/#timeout-test","title":"Timeout Test","text":"<pre><code>#[test]\nfn test_timeout_enforcement() {\n    let func = deploy_function(\"infinite_loop\", http_trigger, loop_wasm)?;\n    func.config.timeout = Duration::from_secs(2);\n\n    let start = Instant::now();\n    let result = invoke(\"infinite_loop\", json!({}));\n    let duration = start.elapsed();\n\n    assert_eq!(result, Err(FunctionError::Timeout));\n    assert!(duration &gt;= Duration::from_secs(2));\n    assert!(duration &lt; Duration::from_secs(3));  // Killed promptly\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#memory-limit-test","title":"Memory Limit Test","text":"<pre><code>#[test]\nfn test_memory_limit_enforcement() {\n    let func = deploy_function(\"memory_hog\", http_trigger, allocate_wasm)?;\n    func.config.max_memory = 64 * 1024 * 1024;  // 64MB\n\n    let result = invoke(\"memory_hog\", json!({\"mb\": 128}));  // Try 128MB\n\n    assert_eq!(result, Err(FunctionError::OutOfMemory));\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#security-tests","title":"Security Tests","text":""},{"location":"FUNCTIONS_TESTING_STRATEGY/#rls-bypass-attempts","title":"RLS Bypass Attempts","text":"<pre><code>#[test]\nfn test_cannot_bypass_rls_without_service_role() {\n    let user_context = RlsContext { user_id: Some(user_id), can_bypass_rls: false, ... };\n\n    // Try to query all users (RLS should filter)\n    let result = db_query_host(\"SELECT * FROM private_table\", [], &amp;user_context)?;\n\n    // Should only see own data\n    assert_eq!(result.len(), 1);\n    assert_eq!(result[0][\"owner_id\"], user_id);\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#secret-redaction","title":"Secret Redaction","text":"<pre><code>#[test]\nfn test_secrets_redacted_in_logs() {\n    let func = deploy_function(\"with_secrets\", http_trigger, wasm)?;\n    func.config.environment.insert(\"API_KEY\", \"secret123\");\n\n    invoke(\"with_secrets\", json!({}));\n\n    let logs = query_invocation_logs(func.id)?;\n    assert!(!logs.contains(\"secret123\"));\n    assert!(logs.contains(\"***REDACTED***\"));\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#performance-benchmarks","title":"Performance Benchmarks","text":""},{"location":"FUNCTIONS_TESTING_STRATEGY/#target-metrics","title":"Target Metrics","text":"<ul> <li>Cold start: &lt; 100ms (p95)</li> <li>Execution overhead: &lt; 5ms (p95)</li> <li>Throughput: &gt; 50 invocations/sec</li> <li>Concurrent invocations: &gt; 100</li> </ul>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#benchmark-tests","title":"Benchmark Tests","text":"<pre><code>#[bench]\nfn bench_cold_start(b: &amp;mut Bencher) {\n    b.iter(|| {\n        let func = load_function(\"benchmark\");\n        let instance = create_instance(func);\n    });\n}\n\n#[bench]\nfn bench_invoke_simple_function(b: &amp;mut Bencher) {\n    let func = deploy_function(\"simple\", http_trigger, simple_wasm)?;\n\n    b.iter(|| {\n        invoke(\"simple\", json!({}));\n    });\n}\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#invariant-validation","title":"Invariant Validation","text":"<p>Each test category validates specific invariants:</p> <ul> <li>FUNC-I1 (Sandbox): Security tests verify no escape</li> <li>FUNC-I2 (Limits): Stress tests verify timeout/memory enforcement</li> <li>FUNC-I3 (RLS): Security tests verify RLS on db_query</li> <li>FUNC-I4 (Isolation): Failure injection tests verify database unaffected</li> <li>FUNC-I5 (Hash): Deploy tests verify hash integrity</li> </ul>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#coverage-validation","title":"Coverage Validation","text":"<p>Run with coverage: <pre><code>cargo tarpaulin --lib --packages aerodb --out Lcov -- functions::\n</code></pre></p> <p>Acceptance: &gt; 90% line coverage, &gt; 85% branch coverage</p>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#test-data","title":"Test Data","text":""},{"location":"FUNCTIONS_TESTING_STRATEGY/#sample-wasm-functions","title":"Sample WASM Functions","text":"<ul> <li><code>hello_wasm</code>: Returns \"Hello, World!\"</li> <li><code>db_query_wasm</code>: Queries database</li> <li><code>loop_wasm</code>: Infinite loop (for timeout testing)</li> <li><code>allocate_wasm</code>: Allocates large memory (for limit testing)</li> <li><code>panic_wasm</code>: Panics immediately</li> </ul>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#fixtures","title":"Fixtures","text":"<ul> <li>Test functions stored in <code>tests/fixtures/functions/</code></li> <li>Compiled to WASM in CI</li> <li>Versioned with tests</li> </ul>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#ci-integration","title":"CI Integration","text":""},{"location":"FUNCTIONS_TESTING_STRATEGY/#pipeline","title":"Pipeline","text":"<pre><code>test_functions:\n  - cargo test functions:: --lib\n  - cargo bench functions:: --no-run\n  - cargo tarpaulin functions::\n</code></pre>"},{"location":"FUNCTIONS_TESTING_STRATEGY/#acceptance-criteria","title":"Acceptance Criteria","text":"<ul> <li>All unit tests pass</li> <li>All integration tests pass</li> <li>Coverage &gt; 90%</li> <li>No memory leaks detected</li> <li>Performance benchmarks meet targets</li> </ul>"},{"location":"FUNCTIONS_VISION/","title":"Phase 12: Serverless Functions Vision","text":"<p>Document Type: Vision Statement Phase: 12 - Serverless Functions Status: Active</p>"},{"location":"FUNCTIONS_VISION/#goal","title":"Goal","text":"<p>Enable custom server-side logic via WebAssembly (WASM) functions that can be triggered by HTTP requests, database events, or schedules. Functions run in sandboxed environments with resource limits, providing a secure extension point for application logic without modifying AeroDB core.</p>"},{"location":"FUNCTIONS_VISION/#philosophy","title":"Philosophy","text":""},{"location":"FUNCTIONS_VISION/#1-non-deterministic-by-design","title":"1. Non-Deterministic by Design","text":"<p>Functions are explicitly non-deterministic, living outside AeroDB's deterministic core:</p> Layer Determinism Rationale Database Fully Deterministic Ensures correctness, replayability WAL/MVCC Fully Deterministic State machine behavior Functions Non-Deterministic User code, external APIs, undefined behavior <p>Key Principle: Functions read from and write to the database, but are NOT part of the database's deterministic execution path.</p>"},{"location":"FUNCTIONS_VISION/#2-sandboxed-execution","title":"2. Sandboxed Execution","text":"<p>Functions run in WebAssembly for isolation: - Memory-safe (no buffer overflows) - CPU-limited (timeouts enforced) - Memory-limited (heap size caps) - No filesystem access (host functions only) - No network access (unless granted via host functions)</p> <p>Security Model: Zero-trust. Functions cannot: - Access other functions' memory - Bypass RLS - Crash the database - Consume unbounded resources</p>"},{"location":"FUNCTIONS_VISION/#3-fail-open","title":"3. Fail-Open","text":"<p>Function failures do NOT crash the database: - Timeout \u2192 Error logged, function terminates - Panic \u2192 Error logged, isolation maintained - Infinite loop \u2192 Timeout, function killed</p> <p>Contrast with Database: - Database query error \u2192 Transaction rolled back - Function error \u2192 Logged, caller notified, database unaffected</p>"},{"location":"FUNCTIONS_VISION/#4-explicit-triggers","title":"4. Explicit Triggers","text":"<p>Functions must be explicitly invoked: - HTTP trigger: <code>/functions/v1/{name}</code> endpoint - Database trigger: <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> on specific table - Schedule trigger: Cron expression - Webhook trigger: External HTTP POST (future)</p> <p>No Implicit Behavior: Functions don't auto-run on arbitrary events.</p>"},{"location":"FUNCTIONS_VISION/#5-host-functions","title":"5. Host Functions","text":"<p>Functions interact with AeroDB via host functions (imported from WASM):</p> <pre><code>// Available to WASM functions\nfn db_query(sql: &amp;str) -&gt; Result&lt;Vec&lt;Row&gt;&gt;;\nfn http_fetch(url: &amp;str) -&gt; Result&lt;String&gt;;\nfn log(message: &amp;str);\nfn env(key: &amp;str) -&gt; Option&lt;String&gt;;\n</code></pre> <p>Access Control: Host functions respect RLS context passed to function invocation.</p>"},{"location":"FUNCTIONS_VISION/#use-cases","title":"Use Cases","text":""},{"location":"FUNCTIONS_VISION/#1-http-api-endpoints","title":"1. HTTP API Endpoints","text":"<p>Custom business logic beyond CRUD:</p> <pre><code>// POST /functions/v1/send-welcome-email\nexport async function handler(event) {\n  const user = await db.query(\"SELECT * FROM users WHERE id = $1\", [event.user_id]);\n  await email.send(user.email, \"Welcome to AeroDB!\");\n  return { status: \"sent\" };\n}\n</code></pre>"},{"location":"FUNCTIONS_VISION/#2-database-triggers","title":"2. Database Triggers","text":"<p>React to data changes:</p> <pre><code>// Trigger: INSERT on orders table\nexport async function onOrderCreated(order) {\n  // Update inventory\n  await db.query(\"UPDATE products SET stock = stock - $1 WHERE id = $2\", \n                 [order.quantity, order.product_id]);\n\n  // Notify warehouse\n  await http.post(\"https://warehouse.example.com/ship\", order);\n}\n</code></pre>"},{"location":"FUNCTIONS_VISION/#3-scheduled-jobs","title":"3. Scheduled Jobs","text":"<p>Background tasks:</p> <pre><code>// Schedule: \"0 2 * * *\" (daily at 2 AM)\nexport async function cleanupExpiredSessions() {\n  await db.query(\"DELETE FROM sessions WHERE expires_at &lt; NOW()\");\n  console.log(\"Cleaned up expired sessions\");\n}\n</code></pre>"},{"location":"FUNCTIONS_VISION/#4-webhook-handlers","title":"4. Webhook Handlers","text":"<p>Process external events:</p> <pre><code>// Webhook: Stripe payment success\nexport async function handleStripeWebhook(event) {\n  if (event.type === \"payment_intent.succeeded\") {\n    await db.query(\"UPDATE subscriptions SET status = 'active' WHERE user_id = $1\",\n                   [event.metadata.user_id]);\n  }\n}\n</code></pre>"},{"location":"FUNCTIONS_VISION/#design-principles","title":"Design Principles","text":""},{"location":"FUNCTIONS_VISION/#simplicity-over-features","title":"Simplicity Over Features","text":"<p>Include: - WASM execution (wasmer/wasmtime) - Resource limits (timeout, memory) - Basic host functions (db_query, log) - HTTP, database, schedule triggers</p> <p>Exclude (defer): - Multi-language support (JS, Python, etc.) - WASM only - Stateful functions (cold start every invocation) - Function-to-function calls - Distributed tracing - Custom dependencies/packages</p> <p>Rationale: Focus on core execution. Language SDKs can compile to WASM.</p>"},{"location":"FUNCTIONS_VISION/#security-by-default","title":"Security by Default","text":"<p>Functions get minimal permissions: - RLS enforced on db_query - No file system access - No raw network sockets - Environment variables are whitelisted - Secrets via secure env vars only</p> <p>Privilege Escalation: Service role context can be passed explicitly (admin functions).</p>"},{"location":"FUNCTIONS_VISION/#observable","title":"Observable","text":"<p>All function invocations are logged: <pre><code>{\n  \"function\": \"send-welcome-email\",\n  \"trigger\": \"http\",\n  \"duration_ms\": 234,\n  \"memory_peak_mb\": 12,\n  \"status\": \"success\",\n  \"user_id\": \"uuid\",\n  \"timestamp\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p> <p>Metrics: - Invocation count per function - Success/failure rate - Execution duration (p50, p95, p99) - Memory usage</p>"},{"location":"FUNCTIONS_VISION/#success-criteria","title":"Success Criteria","text":"<p>Phase 12 is successful when:</p>"},{"location":"FUNCTIONS_VISION/#functional","title":"Functional","text":"<ol> <li>\u2705 Deploy WASM function via REST API</li> <li>\u2705 Invoke function via HTTP (<code>POST /functions/v1/{name}</code>)</li> <li>\u2705 Database trigger fires on INSERT/UPDATE/DELETE</li> <li>\u2705 Schedule trigger runs on cron expression</li> <li>\u2705 Function can query database (RLS enforced)</li> <li>\u2705 Function can log messages</li> <li>\u2705 Timeout enforced (default: 10s)</li> <li>\u2705 Memory limit enforced (default: 128MB)</li> </ol>"},{"location":"FUNCTIONS_VISION/#non-functional","title":"Non-Functional","text":"<ol> <li>\u2705 Function cold start &lt; 100ms (p95)</li> <li>\u2705 Execution overhead &lt; 5ms (p95)</li> <li>\u2705 Handle 100 concurrent function invocations</li> <li>\u2705 Timeout kills runaway functions</li> <li>\u2705 Memory limit prevents OOM</li> </ol>"},{"location":"FUNCTIONS_VISION/#security","title":"Security","text":"<ol> <li>\u2705 Functions cannot bypass RLS</li> <li>\u2705 Functions cannot access filesystem</li> <li>\u2705 Functions cannot crash database</li> <li>\u2705 Secrets not leaked in logs</li> </ol>"},{"location":"FUNCTIONS_VISION/#integration-with-aerodb","title":"Integration with AeroDB","text":""},{"location":"FUNCTIONS_VISION/#authentication-phase-8","title":"Authentication (Phase 8)","text":"<pre><code>// Function inherits RLS context from caller\nlet context = extract_rls_context(&amp;request)?;\nfunctions.invoke(\"my-function\", payload, &amp;context)?;\n</code></pre>"},{"location":"FUNCTIONS_VISION/#database-core","title":"Database (Core)","text":"<pre><code>// Host function: db_query\nfn db_query(sql: &amp;str, params: Vec&lt;Value&gt;) -&gt; Result&lt;Vec&lt;Row&gt;&gt; {\n    let query = parse_sql(sql)?;\n    executor.execute(query, &amp;rls_context)?  // \u2b05\ufe0f RLS enforced\n}\n</code></pre>"},{"location":"FUNCTIONS_VISION/#real-time-phase-10","title":"Real-Time (Phase 10)","text":"<pre><code>// Function can emit events\nexport async function handler(event) {\n  await db.query(\"INSERT INTO events ...\");\n  // Event automatically propagated to subscribers via Phase 10\n}\n</code></pre>"},{"location":"FUNCTIONS_VISION/#examples","title":"Examples","text":""},{"location":"FUNCTIONS_VISION/#example-1-http-function","title":"Example 1: HTTP Function","text":"<pre><code>// functions/hello.js\nexport async function handler(request) {\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ message: `Hello, ${request.name}!` })\n  };\n}\n</code></pre> <p>Deploy: <pre><code>curl -X POST /functions/v1/deploy \\\n  -H \"Authorization: Bearer $JWT\" \\\n  -F \"name=hello\" \\\n  -F \"wasm=@hello.wasm\"\n</code></pre></p> <p>Invoke: <pre><code>curl -X POST /functions/v1/hello \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"World\"}'\n\n\u2192 {\"message\": \"Hello, World!\"}\n</code></pre></p>"},{"location":"FUNCTIONS_VISION/#example-2-database-trigger","title":"Example 2: Database Trigger","text":"<pre><code>// Trigger: INSERT on users table\nexport async function onUserCreated(user) {\n  // Automatically create user profile\n  await db.query(\n    \"INSERT INTO profiles (user_id, display_name) VALUES ($1, $2)\",\n    [user.id, user.email.split('@')[0]]\n  );\n}\n</code></pre>"},{"location":"FUNCTIONS_VISION/#example-3-scheduled-cleanup","title":"Example 3: Scheduled Cleanup","text":"<pre><code>// Schedule: \"0 3 * * *\" (daily at 3 AM)\nexport async function cleanupOldData() {\n  const result = await db.query(\n    \"DELETE FROM logs WHERE created_at &lt; NOW() - INTERVAL '30 days'\"\n  );\n  console.log(`Deleted ${result.rowCount} old log entries`);\n}\n</code></pre>"},{"location":"FUNCTIONS_VISION/#non-goals","title":"Non-Goals","text":"<p>What Phase 12 does NOT do:</p>"},{"location":"FUNCTIONS_VISION/#no-state-between-invocations","title":"No State Between Invocations","text":"<p>Each invocation starts fresh (cold start). Future: Warm instances, connection pooling</p>"},{"location":"FUNCTIONS_VISION/#no-direct-function-to-function-calls","title":"No Direct Function-to-Function Calls","text":"<p>Functions cannot call each other directly. Workaround: HTTP trigger or database as message queue</p>"},{"location":"FUNCTIONS_VISION/#no-custom-npmpip-packages","title":"No Custom npm/pip Packages","text":"<p>WASM only, no dependency management (yet). Future: WASI support for packages</p>"},{"location":"FUNCTIONS_VISION/#no-websocket-from-functions","title":"No WebSocket from Functions","text":"<p>Functions cannot hold WebSocket connections. Workaround: Write to database, Phase 10 broadcasts</p>"},{"location":"FUNCTIONS_VISION/#risks-and-mitigations","title":"Risks and Mitigations","text":"Risk Mitigation Runaway function (CPU) Timeout enforcement (default: 10s) Memory leak Heap size limit (default: 128MB) Database overload Rate limiting, connection pooling Secrets in logs Redact sensitive env vars Malicious WASM Sandbox isolation, resource limits Function versioning Store WASM hash, rollback support (future)"},{"location":"FUNCTIONS_VISION/#future-phases","title":"Future Phases","text":""},{"location":"FUNCTIONS_VISION/#phase-121-language-sdks","title":"Phase 12.1: Language SDKs","text":"<ul> <li>JavaScript/TypeScript SDK (compile to WASM)</li> <li>Python SDK (compile to WASM via RustPython)</li> <li>Rust SDK (native WASM)</li> </ul>"},{"location":"FUNCTIONS_VISION/#phase-122-stateful-functions","title":"Phase 12.2: Stateful Functions","text":"<ul> <li>Warm instance pooling</li> <li>Connection reuse</li> <li>In-memory caching</li> </ul>"},{"location":"FUNCTIONS_VISION/#phase-123-function-orchestration","title":"Phase 12.3: Function Orchestration","text":"<ul> <li>Function-to-function calls</li> <li>Workflow engine (step functions)</li> <li>Retry policies</li> </ul>"},{"location":"FUNCTIONS_VISION/#stakeholders","title":"Stakeholders","text":"<ul> <li>Application developers: Extend AeroDB with custom logic</li> <li>DevOps: Observable, resource-limited execution</li> <li>Security team: Sandboxed, RLS-enforced functions</li> <li>AeroDB core: Clean separation from deterministic core</li> </ul>"},{"location":"INIT_READINESS/","title":"Phase 1 Final Readiness Checklist \u2014 AeroDB","text":"<p>This checklist defines the non-negotiable completion criteria for AeroDB Phase 1.</p> <p>Phase 1 is considered complete only if every item below is satisfied.</p> <p>If any item is unchecked, Phase 1 is incomplete.</p>"},{"location":"INIT_READINESS/#1-core-data-safety","title":"1. Core Data Safety","text":""},{"location":"INIT_READINESS/#write-ahead-log-wal","title":"Write-Ahead Log (WAL)","text":"<ul> <li> Every acknowledged write is fsynced before success</li> <li> WAL append order is strictly monotonic</li> <li> WAL corruption is detected via checksum</li> <li> WAL corruption halts recovery (FATAL)</li> <li> WAL replay is deterministic</li> <li> WAL truncation occurs only during checkpoint</li> </ul>"},{"location":"INIT_READINESS/#storage-engine","title":"Storage Engine","text":"<ul> <li> Storage is append-only</li> <li> Full-document writes only (no deltas)</li> <li> Every record is checksummed</li> <li> Corruption is detected on read</li> <li> Corruption is never silently repaired</li> <li> Tombstones correctly represent deletes</li> <li> Reads never observe partial records</li> </ul>"},{"location":"INIT_READINESS/#2-schema-enforcement","title":"2. Schema Enforcement","text":"<ul> <li> Schemas are mandatory for all writes</li> <li> Schema ID and version must be explicit</li> <li> Schema versions are immutable</li> <li> No implicit fields or coercion</li> <li> Extra fields are rejected</li> <li> Missing required fields are rejected</li> <li> <code>_id</code> is required and immutable</li> <li> Recovery fails if referenced schema is missing</li> </ul>"},{"location":"INIT_READINESS/#3-query-safety-determinism","title":"3. Query Safety &amp; Determinism","text":""},{"location":"INIT_READINESS/#planner","title":"Planner","text":"<ul> <li> All queries are proven bounded before execution</li> <li> Queries without limit are rejected</li> <li> Filters on non-indexed fields are rejected</li> <li> Sorts on non-indexed fields are rejected</li> <li> Planner output is deterministic</li> <li> Tie-breaking rules are deterministic</li> <li> Explain output is stable</li> </ul>"},{"location":"INIT_READINESS/#executor","title":"Executor","text":"<ul> <li> Execution follows plan exactly</li> <li> No runtime heuristics</li> <li> Deterministic result ordering</li> <li> Stable sort only</li> <li> Limit enforced physically</li> <li> Schema version filtering enforced</li> <li> Checksum validated on every read</li> </ul>"},{"location":"INIT_READINESS/#4-index-integrity","title":"4. Index Integrity","text":"<ul> <li> Indexes are derived state only</li> <li> Indexes are rebuilt on startup</li> <li> Index rebuild halts on corruption</li> <li> Index ordering is deterministic</li> <li> Tombstoned documents are excluded</li> <li> No index persistence to disk</li> </ul>"},{"location":"INIT_READINESS/#5-recovery-correctness","title":"5. Recovery Correctness","text":"<ul> <li> Recovery always runs on startup</li> <li> WAL replay starts at correct position</li> <li> Replay is sequential and deterministic</li> <li> Index rebuild runs after replay</li> <li> Storage checksums verified post-replay</li> <li> Schema references verified</li> <li> Recovery success/failure is explicit</li> <li> No partial recovery allowed</li> </ul>"},{"location":"INIT_READINESS/#6-snapshot","title":"6. Snapshot","text":"<ul> <li> Snapshot is read-only</li> <li> Snapshot fsyncs WAL before copy</li> <li> Snapshot copies storage byte-for-byte</li> <li> Snapshot copies schemas</li> <li> Snapshot has a manifest</li> <li> Manifest includes checksums</li> <li> Partial snapshots are cleaned up</li> <li> Snapshot does NOT truncate WAL</li> </ul>"},{"location":"INIT_READINESS/#7-checkpoint","title":"7. Checkpoint","text":"<ul> <li> Checkpoint acquires global execution lock</li> <li> Checkpoint creates snapshot first</li> <li> Checkpoint writes marker before truncation</li> <li> WAL truncation is atomic</li> <li> Crash before truncation preserves WAL</li> <li> Crash after truncation recovers via snapshot</li> <li> Checkpoint errors are non-fatal</li> <li> Checkpoint ID equals snapshot ID</li> </ul>"},{"location":"INIT_READINESS/#8-backup","title":"8. Backup","text":"<ul> <li> Backup uses latest snapshot</li> <li> Backup includes WAL tail</li> <li> Backup is deterministic</li> <li> Backup has a manifest</li> <li> No compression used</li> <li> Backup is read-only</li> <li> Partial backups are cleaned up</li> <li> Backup errors do not affect serving</li> </ul>"},{"location":"INIT_READINESS/#9-restore","title":"9. Restore","text":"<ul> <li> Restore is offline-only</li> <li> Restore validates backup structure</li> <li> Restore validates snapshot checksums</li> <li> Restore validates WAL integrity</li> <li> Restore uses atomic directory replacement</li> <li> Original data preserved on failure</li> <li> Restore never rebuilds indexes</li> <li> Restore errors are FATAL</li> </ul>"},{"location":"INIT_READINESS/#10-observability","title":"10. Observability","text":"<ul> <li> Structured JSON logs</li> <li> Deterministic key ordering</li> <li> Lifecycle events logged</li> <li> WAL events logged</li> <li> Snapshot / checkpoint events logged</li> <li> Backup / restore events logged</li> <li> Recovery events logged</li> <li> Query lifecycle logged</li> <li> Metrics counters monotonic</li> <li> Observability has zero behavioral impact</li> </ul>"},{"location":"INIT_READINESS/#11-crash-testing","title":"11. Crash Testing","text":"<ul> <li> Crash injection via environment variable</li> <li> Crash points implemented across subsystems</li> <li> WAL crash scenarios tested</li> <li> Storage mid-write crashes tested</li> <li> Snapshot crashes tested</li> <li> Checkpoint crashes tested</li> <li> Backup crashes tested</li> <li> Restore crashes tested</li> <li> Recovery determinism verified</li> <li> No flaky crash tests</li> </ul>"},{"location":"INIT_READINESS/#12-configuration-safety","title":"12. Configuration Safety","text":"<ul> <li> Unsafe configurations rejected</li> <li> WAL fsync cannot be disabled</li> <li> Checksums cannot be disabled</li> <li> Schemas cannot be bypassed</li> <li> Configuration validated at startup</li> <li> Configuration is immutable post-start</li> </ul>"},{"location":"INIT_READINESS/#13-cli-boot","title":"13. CLI &amp; Boot","text":"<ul> <li> <code>init</code> creates correct layout</li> <li> <code>start</code> runs full recovery before serving</li> <li> <code>query</code> and <code>explain</code> require recovery</li> <li> Clean shutdown marker handled correctly</li> <li> Startup failure halts immediately</li> <li> No background threads started implicitly</li> </ul>"},{"location":"INIT_READINESS/#14-tests-discipline","title":"14. Tests &amp; Discipline","text":"<ul> <li> All unit tests passing</li> <li> All integration tests passing</li> <li> All crash tests passing</li> <li> No ignored tests</li> <li> No flaky tests</li> <li> Code matches governing docs</li> <li> No undocumented behavior</li> </ul>"},{"location":"INIT_READINESS/#phase-1-exit-criteria","title":"Phase 1 Exit Criteria","text":"<p>Phase 1 is complete only if:</p> <ul> <li>All checklist items are checked</li> <li>Crash testing passes consistently</li> <li>No invariants are violated</li> <li>System behavior matches documentation exactly</li> </ul>"},{"location":"INIT_READINESS/#what-phase-1-guarantees","title":"What Phase 1 Guarantees","text":"<ul> <li>No acknowledged write is lost</li> <li>Corruption is always detected</li> <li>Recovery is deterministic</li> <li>Backups are restorable</li> <li>Restore is atomic</li> <li>Queries are bounded and safe</li> <li>Behavior is explicit and explainable</li> </ul> <p>END INIT_READINESS.md</p>"},{"location":"INSTALL/","title":"Installation","text":"<p>This document explains how to build, initialize, and run AeroDB Phase 0 from source.</p> <p>AeroDB Phase 0 is a single-node, deterministic document database with:</p> <ul> <li>Mandatory schemas</li> <li>WAL-backed durability</li> <li>Full crash recovery</li> <li>Deterministic query planning and execution</li> </ul> <p>This is infrastructure software, not a toy.</p>"},{"location":"INSTALL/#1-system-requirements","title":"1. System Requirements","text":""},{"location":"INSTALL/#operating-system","title":"Operating System","text":"<ul> <li>Linux (recommended)</li> <li>macOS (untested but should work)</li> </ul> <p>Windows is not supported in Phase 0.</p>"},{"location":"INSTALL/#rust-toolchain","title":"Rust Toolchain","text":"<p>Minimum:</p> <pre><code>rustc 1.75+\ncargo 1.75+\n</code></pre> <p>Check:</p> <pre><code>rustc --version\ncargo --version\n</code></pre> <p>If not installed:</p> <pre><code>curl https://sh.rustup.rs -sSf | sh\n</code></pre> <p>Restart your shell after installation.</p>"},{"location":"INSTALL/#2-clone-the-repository","title":"2. Clone the Repository","text":"<pre><code>git clone &lt;your-repo-url&gt; aerodb\ncd aerodb\n</code></pre>"},{"location":"INSTALL/#3-build-aerodb","title":"3. Build AeroDB","text":"<p>Debug build:</p> <pre><code>cargo build\n</code></pre> <p>Release build (recommended):</p> <pre><code>cargo build --release\n</code></pre> <p>Binary location:</p> <pre><code>target/release/aerodb\n</code></pre>"},{"location":"INSTALL/#4-directory-layout","title":"4. Directory Layout","text":"<p>AeroDB stores all data under <code>data_dir</code>.</p> <p>After initialization:</p> <pre><code>data/\n\u251c\u2500\u2500 wal/\n\u251c\u2500\u2500 data/\n\u251c\u2500\u2500 metadata/\n\u2502   \u2514\u2500\u2500 schemas/\n\u2514\u2500\u2500 clean_shutdown\n</code></pre> <p>You must provide a config file.</p>"},{"location":"INSTALL/#5-create-configuration","title":"5. Create Configuration","text":"<p>Create <code>aerodb.json</code>:</p> <pre><code>{\n  \"data_dir\": \"./data\",\n  \"wal_sync_mode\": \"fsync\",\n  \"max_wal_size_bytes\": 1073741824,\n  \"max_memory_bytes\": 536870912\n}\n</code></pre> <p>Notes:</p> <ul> <li><code>data_dir</code> is required</li> <li>Other fields are optional</li> <li>All values become immutable after first startup</li> </ul>"},{"location":"INSTALL/#6-initialize-database","title":"6. Initialize Database","text":"<p>Run:</p> <pre><code>./target/release/aerodb init --config aerodb.json\n</code></pre> <p>This creates:</p> <pre><code>./data/\n</code></pre> <p>If this directory already exists, init will fail.</p>"},{"location":"INSTALL/#7-define-a-schema","title":"7. Define a Schema","text":"<p>Schemas must exist before any writes.</p> <p>Create:</p> <pre><code>data/metadata/schemas/user_v1.json\n</code></pre> <p>Example:</p> <pre><code>{\n  \"schema_id\": \"user\",\n  \"schema_version\": \"v1\",\n  \"fields\": {\n    \"_id\": { \"type\": \"string\" },\n    \"name\": { \"type\": \"string\" },\n    \"age\": { \"type\": \"int\" }\n  },\n  \"indexes\": [\"_id\", \"name\", \"age\"]\n}\n</code></pre> <p>Rules:</p> <ul> <li><code>_id</code> is mandatory</li> <li>All indexed fields must be declared</li> <li>Schema versions are immutable</li> </ul>"},{"location":"INSTALL/#8-start-aerodb","title":"8. Start AeroDB","text":"<p>Run:</p> <pre><code>./target/release/aerodb start --config aerodb.json\n</code></pre> <p>Startup will:</p> <ol> <li>Load config</li> <li>Load schemas</li> <li>Replay WAL</li> <li>Rebuild indexes</li> <li>Verify consistency</li> <li>Enter SERVING state</li> </ol> <p>On success, AeroDB waits for JSON requests on stdin.</p>"},{"location":"INSTALL/#9-insert-a-document","title":"9. Insert a Document","text":"<p>Create <code>insert.json</code>:</p> <pre><code>{\n  \"op\": \"insert\",\n  \"schema_id\": \"user\",\n  \"schema_version\": \"v1\",\n  \"document\": {\n    \"_id\": \"1\",\n    \"name\": \"alice\",\n    \"age\": 30\n  }\n}\n</code></pre> <p>Send it:</p> <pre><code>echo '{\"op\":\"insert\",\"schema_id\":\"user\",\"schema_version\":\"v1\",\"document\":{\"_id\":\"1\",\"name\":\"alice\",\"age\":30}}' | ./target/release/aerodb query --config aerodb.json\n</code></pre> <p>Expected response:</p> <pre><code>{\n  \"status\": \"ok\",\n  \"data\": []\n}\n</code></pre>"},{"location":"INSTALL/#10-query-documents","title":"10. Query Documents","text":"<p>Create <code>query.json</code>:</p> <pre><code>{\n  \"op\": \"query\",\n  \"schema_id\": \"user\",\n  \"schema_version\": \"v1\",\n  \"filter\": {\n    \"age\": 30\n  },\n  \"limit\": 10\n}\n</code></pre> <p>Run:</p> <pre><code>cat query.json | ./target/release/aerodb query --config aerodb.json\n</code></pre> <p>Example output:</p> <pre><code>{\n  \"status\": \"ok\",\n  \"data\": [\n    {\n      \"_id\": \"1\",\n      \"name\": \"alice\",\n      \"age\": 30\n    }\n  ]\n}\n</code></pre>"},{"location":"INSTALL/#11-explain-a-query","title":"11. Explain a Query","text":"<pre><code>cat query.json | ./target/release/aerodb explain --config aerodb.json\n</code></pre> <p>Returns deterministic execution plan.</p>"},{"location":"INSTALL/#12-crash-recovery-test","title":"12. Crash Recovery Test","text":"<p>You can simulate a crash:</p> <ol> <li>Start AeroDB</li> <li>Insert data</li> <li>Kill process (<code>Ctrl+C</code> or SIGKILL)</li> <li>Restart</li> </ol> <p>On restart:</p> <ul> <li>WAL is replayed</li> <li>indexes rebuilt</li> <li>data is preserved</li> </ul> <p>This is mandatory behavior.</p>"},{"location":"INSTALL/#13-common-failures","title":"13. Common Failures","text":""},{"location":"INSTALL/#missing-schema","title":"Missing Schema","text":"<pre><code>AERO_RECOVERY_SCHEMA_MISSING\n</code></pre> <p>\u2192 Schema files not present or mismatched.</p>"},{"location":"INSTALL/#wal-storage-corruption","title":"WAL / Storage Corruption","text":"<pre><code>AERO_DATA_CORRUPTION\n</code></pre> <p>\u2192 Database halts. Restore from backup.</p> <p>AeroDB never auto-repairs.</p>"},{"location":"INSTALL/#invalid-config","title":"Invalid Config","text":"<pre><code>AERO_CONFIG_INVALID\n</code></pre> <p>\u2192 Fix config and retry.</p>"},{"location":"INSTALL/#14-phase-0-limitations","title":"14. Phase-0 Limitations","text":"<p>AeroDB Phase 0 does NOT support:</p> <ul> <li>HTTP server</li> <li>joins</li> <li>aggregations</li> <li>transactions</li> <li>replication</li> <li>checkpoints</li> <li>WAL truncation</li> <li>schema migrations</li> </ul> <p>This is expected.</p>"},{"location":"INSTALL/#15-next-steps","title":"15. Next Steps","text":"<p>Recommended after installation:</p> <ul> <li>Read <code>BOOT.md</code></li> <li>Read <code>API_SPEC.md</code></li> <li>Read <code>LIFECYCLE.md</code></li> </ul> <p>These define system guarantees.</p>"},{"location":"JS_SDK_ARCHITECTURE/","title":"Phase 14: Client SDKs - JavaScript/TypeScript Architecture","text":""},{"location":"JS_SDK_ARCHITECTURE/#package-structure","title":"Package Structure","text":"<pre><code>@aerodb/client/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 index.ts                 # Main entry point\n\u2502   \u251c\u2500\u2500 AeroDBClient.ts          # Client class\n\u2502   \u251c\u2500\u2500 auth/                    # Authentication\n\u2502   \u2502   \u251c\u2500\u2500 AuthClient.ts\n\u2502   \u2502   \u2514\u2500\u2500 types.ts\n\u2502   \u251c\u2500\u2500 database/                # CRUD operations\n\u2502   \u2502   \u251c\u2500\u2500 QueryBuilder.ts\n\u2502   \u2502   \u251c\u2500\u2500 PostgrestClient.ts   # PostgREST-style API\n\u2502   \u2502   \u2514\u2500\u2500 types.ts\n\u2502   \u251c\u2500\u2500 realtime/                # WebSocket\n\u2502   \u2502   \u251c\u2500\u2500 RealtimeClient.ts\n\u2502   \u2502   \u251c\u2500\u2500 RealtimeChannel.ts\n\u2502   \u2502   \u2514\u2500\u2500 types.ts\n\u2502   \u251c\u2500\u2500 storage/                 # File uploads\n\u2502   \u2502   \u251c\u2500\u2500 StorageClient.ts\n\u2502   \u2502   \u2514\u2500\u2500 types.ts\n\u2502   \u251c\u2500\u2500 functions/               # Serverless\n\u2502   \u2502   \u251c\u2500\u2500 FunctionsClient.ts\n\u2502   \u2502   \u2514\u2500\u2500 types.ts\n\u2502   \u251c\u2500\u2500 lib/                     # Shared utilities\n\u2502   \u2502   \u251c\u2500\u2500 fetch.ts\n\u2502   \u2502   \u251c\u2500\u2500 constants.ts\n\u2502   \u2502   \u2514\u2500\u2500 helpers.ts\n\u2502   \u2514\u2500\u2500 types/                   # Global types\n\u2502       \u2514\u2500\u2500 index.ts\n\u251c\u2500\u2500 tests/                       # Unit tests\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 tsconfig.json\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"JS_SDK_ARCHITECTURE/#core-classes","title":"Core Classes","text":""},{"location":"JS_SDK_ARCHITECTURE/#aerodbclient","title":"AeroDBClient","text":"<p>Main entry point, exposes all sub-clients:</p> <pre><code>// src/AeroDBClient.ts\nimport { AuthClient } from './auth/AuthClient';\nimport { PostgrestClient } from './database/PostgrestClient';\nimport { RealtimeClient } from './realtime/RealtimeClient';\nimport { StorageClient } from './storage/StorageClient';\nimport { FunctionsClient } from './functions/FunctionsClient';\n\nexport interface AeroDBClientOptions {\n  url: string;              // Base URL (e.g., https://api.aerodb.com)\n  key?: string;             // API key (optional, can use signIn)\n  schema?: string;          // Database schema (default: 'public')\n  headers?: Record&lt;string, string&gt;;\n  realtime?: { url: string }; // WebSocket URL override\n}\n\nexport class AeroDBClient {\n  auth: AuthClient;\n  private db: PostgrestClient;\n  realtime: RealtimeClient;\n  storage: StorageClient;\n  functions: FunctionsClient;\n\n  constructor(options: AeroDBClientOptions) {\n    this.auth = new AuthClient(options);\n    this.db = new PostgrestClient(options);\n    this.realtime = new RealtimeClient(options);\n    this.storage = new StorageClient(options);\n    this.functions = new FunctionsClient(options);\n  }\n\n  // Shorthand for database queries\n  from&lt;T = any&gt;(collection: string) {\n    return this.db.from&lt;T&gt;(collection);\n  }\n\n  // Create a real-time channel\n  channel(name: string) {\n    return this.realtime.channel(name);\n  }\n}\n</code></pre>"},{"location":"JS_SDK_ARCHITECTURE/#authclient","title":"AuthClient","text":"<pre><code>// src/auth/AuthClient.ts\nimport type { User, Session, AuthResponse } from './types';\n\nexport class AuthClient {\n  private url: string;\n\n  constructor(options: AeroDBClientOptions) {\n    this.url = `${options.url}/auth`;\n  }\n\n  async signUp(email: string, password: string): Promise&lt;AuthResponse&gt; {\n    const res = await fetch(`${this.url}/signup`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ email, password }),\n    });\n\n    const data = await res.json();\n\n    if (!res.ok) {\n      return { data: null, error: { message: data.error, status: res.status } };\n    }\n\n    return { data: { user: data.user, session: data.session }, error: null };\n  }\n\n  async signIn(email: string, password: string): Promise&lt;AuthResponse&gt; {\n    const res = await fetch(`${this.url}/login`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ email, password }),\n    });\n\n    const data = await res.json();\n\n    if (!res.ok) {\n      return { data: null, error: { message: data.error, status: res.status } };\n    }\n\n    // Store tokens\n    localStorage.setItem('access_token', data.access_token);\n    localStorage.setItem('refresh_token', data.refresh_token);\n\n    return { data: { user: data.user, session: data.session }, error: null };\n  }\n\n  async signOut(): Promise&lt;{ error: null | { message: string } }&gt; {\n    const token = localStorage.getItem('access_token');\n\n    await fetch(`${this.url}/logout`, {\n      method: 'POST',\n      headers: { Authorization: `Bearer ${token}` },\n    });\n\n    localStorage.removeItem('access_token');\n    localStorage.removeItem('refresh_token');\n\n    return { error: null };\n  }\n\n  async getUser(): Promise&lt;{ data: User | null; error: any }&gt; {\n    const token = localStorage.getItem('access_token');\n\n    if (!token) {\n      return { data: null, error: { message: 'Not authenticated' } };\n    }\n\n    const res = await fetch(`${this.url}/user`, {\n      headers: { Authorization: `Bearer ${token}` },\n    });\n\n    if (!res.ok) {\n      return { data: null, error: { message: 'Failed to fetch user' } };\n    }\n\n    const user = await res.json();\n    return { data: user, error: null };\n  }\n\n  onAuthStateChange(callback: (event: 'SIGNED_IN' | 'SIGNED_OUT', session: Session | null) =&gt; void) {\n    // Listen for storage events (multi-tab sync)\n    window.addEventListener('storage', (e) =&gt; {\n      if (e.key === 'access_token') {\n        if (e.newValue) {\n          callback('SIGNED_IN', { access_token: e.newValue });\n        } else {\n          callback('SIGNED_OUT', null);\n        }\n      }\n    });\n  }\n}\n</code></pre>"},{"location":"JS_SDK_ARCHITECTURE/#querybuilder","title":"QueryBuilder","text":"<pre><code>// src/database/QueryBuilder.ts\nexport type FilterOperator = 'eq' | 'neq' | 'gt' | 'gte' | 'lt' | 'lte' | 'like' | 'ilike' | 'in';\n\nexport class QueryBuilder&lt;T = any&gt; {\n  private collection: string;\n  private selectFields: string = '*';\n  private filters: Array&lt;{ field: string; op: FilterOperator; value: any }&gt; = [];\n  private orderFields: Array&lt;{ field: string; ascending: boolean }&gt; = [];\n  private limitValue?: number;\n  private offsetValue?: number;\n  private baseUrl: string;\n\n  constructor(collection: string, baseUrl: string) {\n    this.collection = collection;\n    this.baseUrl = baseUrl;\n  }\n\n  select(fields: string = '*'): this {\n    this.selectFields = fields;\n    return this;\n  }\n\n  eq(field: keyof T, value: any): this {\n    this.filters.push({ field: field as string, op: 'eq', value });\n    return this;\n  }\n\n  neq(field: keyof T, value: any): this {\n    this.filters.push({ field: field as string, op: 'neq', value });\n    return this;\n  }\n\n  gt(field: keyof T, value: any): this {\n    this.filters.push({ field: field as string, op: 'gt', value });\n    return this;\n  }\n\n  gte(field: keyof T, value: any): this {\n    this.filters.push({ field: field as string, op: 'gte', value });\n    return this;\n  }\n\n  lt(field: keyof T, value: any): this {\n    this.filters.push({ field: field as string, op: 'lt', value });\n    return this;\n  }\n\n  lte(field: keyof T, value: any): this {\n    this.filters.push({ field: field as string, op: 'lte', value });\n    return this;\n  }\n\n  like(field: keyof T, pattern: string): this {\n    this.filters.push({ field: field as string, op: 'like', value: pattern });\n    return this;\n  }\n\n  order(field: keyof T, options: { ascending?: boolean } = {}): this {\n    this.orderFields.push({ field: field as string, ascending: options.ascending ?? true });\n    return this;\n  }\n\n  limit(count: number): this {\n    this.limitValue = count;\n    return this;\n  }\n\n  offset(count: number): this {\n    this.offsetValue = count;\n    return this;\n  }\n\n  private buildQueryString(): string {\n    const params = new URLSearchParams();\n\n    if (this.selectFields) {\n      params.set('select', this.selectFields);\n    }\n\n    this.filters.forEach(({ field, op, value }) =&gt; {\n      params.set(field, `${op}.${value}`);\n    });\n\n    if (this.orderFields.length &gt; 0) {\n      const order = this.orderFields.map(({ field, ascending }) =&gt; \n        `${field}.${ascending ? 'asc' : 'desc'}`\n      ).join(',');\n      params.set('order', order);\n    }\n\n    if (this.limitValue) {\n      params.set('limit', String(this.limitValue));\n    }\n\n    if (this.offsetValue) {\n      params.set('offset', String(this.offsetValue));\n    }\n\n    return params.toString();\n  }\n\n  async execute(): Promise&lt;{ data: T[] | null; error: any }&gt; {\n    const token = localStorage.getItem('access_token');\n    const queryString = this.buildQueryString();\n    const url = `${this.baseUrl}/rest/v1/${this.collection}?${queryString}`;\n\n    const res = await fetch(url, {\n      headers: token ? { Authorization: `Bearer ${token}` } : {},\n    });\n\n    const json = await res.json();\n\n    if (!res.ok) {\n      return { data: null, error: { message: json.error, status: res.status } };\n    }\n\n    return { data: json.data, error: null };\n  }\n}\n</code></pre>"},{"location":"JS_SDK_ARCHITECTURE/#realtimechannel","title":"RealtimeChannel","text":"<pre><code>// src/realtime/RealtimeChannel.ts\nexport type RealtimeEvent = 'INSERT' | 'UPDATE' | 'DELETE';\n\nexport class RealtimeChannel {\n  private name: string;\n  private ws: WebSocket;\n  private callbacks: Map&lt;RealtimeEvent, Array&lt;(payload: any) =&gt; void&gt;&gt; = new Map();\n\n  constructor(name: string, ws: WebSocket) {\n    this.name = name;\n    this.ws = ws;\n\n    this.ws.onmessage = (event) =&gt; {\n      const message = JSON.parse(event.data);\n      if (message.type === 'event' &amp;&amp; message.channel === this.name) {\n        const eventType = message.payload.type as RealtimeEvent;\n        const handlers = this.callbacks.get(eventType) || [];\n        handlers.forEach((cb) =&gt; cb(message.payload));\n      }\n    };\n  }\n\n  on(event: RealtimeEvent, callback: (payload: any) =&gt; void): this {\n    if (!this.callbacks.has(event)) {\n      this.callbacks.set(event, []);\n    }\n    this.callbacks.get(event)!.push(callback);\n    return this;\n  }\n\n  subscribe(): this {\n    this.ws.send(JSON.stringify({ type: 'subscribe', channel: this.name }));\n    return this;\n  }\n\n  unsubscribe(): void {\n    this.ws.send(JSON.stringify({ type: 'unsubscribe', channel: this.name }));\n    this.ws.close();\n  }\n}\n</code></pre>"},{"location":"JS_SDK_ARCHITECTURE/#type-definitions","title":"Type Definitions","text":"<pre><code>// src/types/index.ts\nexport interface AeroDBResponse&lt;T&gt; {\n  data: T | null;\n  error: AeroDBError | null;\n}\n\nexport interface AeroDBError {\n  message: string;\n  status?: number;\n  code?: string;\n}\n\nexport interface User {\n  id: string;\n  email: string;\n  created_at: string;\n}\n\nexport interface Session {\n  access_token: string;\n  refresh_token?: string;\n  expires_at?: number;\n}\n</code></pre>"},{"location":"JS_SDK_ARCHITECTURE/#usage-example","title":"Usage Example","text":"<pre><code>import { AeroDBClient } from '@aerodb/client';\n\nconst client = new AeroDBClient({\n  url: 'https://api.aerodb.com',\n});\n\n// Auth\nconst { data, error } = await client.auth.signIn('user@example.com', 'password');\n\n// Query\nconst { data: users } = await client\n  .from('users')\n  .select('id, name, email')\n  .eq('role', 'admin')\n  .limit(10)\n  .execute();\n\n// Real-time\nclient.channel('users')\n  .on('INSERT', (payload) =&gt; {\n    console.log('New user:', payload.new);\n  })\n  .subscribe();\n\n// Storage\nconst { data: file } = await client.storage\n  .from('avatars')\n  .upload('user-123.png', fileBlob);\n</code></pre>"},{"location":"JS_SDK_ARCHITECTURE/#build-configuration","title":"Build Configuration","text":"<pre><code>// package.json\n{\n  \"name\": \"@aerodb/client\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n  },\n  \"scripts\": {\n    \"build\": \"tsup src/index.ts --format cjs,esm --dts\",\n    \"test\": \"vitest\",\n    \"lint\": \"eslint src\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"tsup\": \"^8.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"vitest\": \"^1.0.0\"\n  }\n}\n</code></pre>"},{"location":"JS_SDK_ARCHITECTURE/#testing","title":"Testing","text":"<pre><code>// tests/QueryBuilder.test.ts\nimport { describe, it, expect } from 'vitest';\nimport { QueryBuilder } from '../src/database/QueryBuilder';\n\ndescribe('QueryBuilder', () =&gt; {\n  it('builds simple query', () =&gt; {\n    const qb = new QueryBuilder('users', 'https://api.example.com');\n    qb.select('id, name').eq('role', 'admin').limit(10);\n\n    const query = qb['buildQueryString'](); // Access private for testing\n    expect(query).toContain('select=id,name');\n    expect(query).toContain('role=eq.admin');\n    expect(query).toContain('limit=10');\n  });\n});\n</code></pre>"},{"location":"JS_SDK_READINESS/","title":"Phase 14: Client SDKs - Readiness Criteria","text":""},{"location":"JS_SDK_READINESS/#freeze-checklist","title":"Freeze Checklist","text":"<p>Phase 14 is ready to freeze when all items below are complete:</p>"},{"location":"JS_SDK_READINESS/#1-javascripttypescript-sdk-aerodbclient","title":"1. JavaScript/TypeScript SDK (@aerodb/client)","text":"<ul> <li> Core Features</li> <li> AeroDBClient class with all sub-clients</li> <li> AuthClient (signUp, signIn, signOut, getUser, onAuthStateChange)</li> <li> QueryBuilder (select, eq, neq, gt, gte, lt, lte, like, order, limit, offset)</li> <li> PostgrestClient (from method)</li> <li> RealtimeClient (channel, subscribe, unsubscribe)</li> <li> RealtimeChannel (on, off event handlers)</li> <li> StorageClient (from, upload, download, delete)</li> <li> <p> FunctionsClient (invoke)</p> </li> <li> <p> Type Safety</p> </li> <li> Full TypeScript types for all methods</li> <li> Generic type parameter for <code>from&lt;T&gt;()</code></li> <li> Union types for filter operators</li> <li> <p> Result type (<code>{ data, error }</code>) for all async methods</p> </li> <li> <p> Error Handling</p> </li> <li> No exceptions thrown (all use Result type)</li> <li> AeroDBError interface with message, status, code</li> <li> Network errors caught and returned as error</li> <li> <p> 401 triggers token refresh automatically</p> </li> <li> <p> Build</p> </li> <li> ESM and CJS outputs (<code>dist/index.js</code>, <code>dist/index.cjs</code>)</li> <li> TypeScript declarations (<code>dist/index.d.ts</code>)</li> <li> Tree-shakeable (side-effect free)</li> <li> Bundle size &lt; 50KB (gzipped)</li> </ul>"},{"location":"JS_SDK_READINESS/#2-python-sdk-aerodb-py","title":"2. Python SDK (aerodb-py)","text":"<ul> <li> Core Features</li> <li> <code>AeroDBClient</code> class</li> <li> <code>AuthClient</code> (sign_up, sign_in, sign_out, get_user)</li> <li> <code>QueryBuilder</code> (select, eq, neq, gt, gte, lt, lte, like, order, limit, offset)</li> <li> <code>PostgrestClient</code> (from_ method, avoid keyword clash)</li> <li> <code>RealtimeClient</code> (async WebSocket)</li> <li> <code>StorageClient</code> (upload, download, delete)</li> <li> <p> <code>FunctionsClient</code> (invoke)</p> </li> <li> <p> Type Hints</p> </li> <li> All methods have type annotations</li> <li> Generic <code>TypeVar</code> for <code>from_[T]()</code></li> <li> Result type: <code>AeroDBResponse[T]</code></li> <li> <p> mypy passes with strict mode</p> </li> <li> <p> Async Support</p> </li> <li> All I/O methods are <code>async def</code></li> <li> Uses <code>aiohttp</code> for HTTP</li> <li> <p> Works with asyncio event loop</p> </li> <li> <p> Pandas Integration</p> </li> <li> <code>to_dataframe()</code> method on query results</li> <li> Automatic type inference (str, int, datetime)</li> </ul>"},{"location":"JS_SDK_READINESS/#3-testing","title":"3. Testing","text":"<ul> <li> Unit Tests (JS/TS)</li> <li> QueryBuilder (all filter methods)</li> <li> AuthClient (signIn, signOut)</li> <li> RealtimeChannel (subscribe, on)</li> <li> <p> 90%+ line coverage</p> </li> <li> <p> Unit Tests (Python)</p> </li> <li> QueryBuilder (all filter methods)</li> <li> AuthClient (sign_in, sign_out)</li> <li> async methods work with asyncio</li> <li> <p> 90%+ line coverage</p> </li> <li> <p> Integration Tests</p> </li> <li> Test against real AeroDB instance</li> <li> CRUD operations (insert, select, update, delete)</li> <li> Real-time subscriptions (receive events)</li> <li> <p> Storage uploads/downloads</p> </li> <li> <p> Mock API Tests</p> </li> <li> MSW for JS/TS (Mock Service Worker)</li> <li> <code>responses</code> library for Python</li> <li> All endpoints mocked</li> </ul>"},{"location":"JS_SDK_READINESS/#4-documentation","title":"4. Documentation","text":"<ul> <li> README.md</li> <li> Installation instructions</li> <li> Quick start example</li> <li> API reference (brief)</li> <li> <p> Links to full docs</p> </li> <li> <p> API Documentation</p> </li> <li> TSDoc comments for all public methods (JS/TS)</li> <li> Docstrings for all public methods (Python)</li> <li> <p> Generated docs (TypeDoc for JS, Sphinx for Python)</p> </li> <li> <p> Examples</p> </li> <li> CRUD operations</li> <li> Authentication flow</li> <li> Real-time subscriptions</li> <li> <p> File uploads</p> </li> <li> <p> Migration Guide</p> </li> <li> From raw fetch() to SDK</li> <li> Breaking changes between versions</li> </ul>"},{"location":"JS_SDK_READINESS/#5-publishing","title":"5. Publishing","text":"<ul> <li> npm Package (@aerodb/client)</li> <li> Published to https://www.npmjs.com/package/@aerodb/client</li> <li> Semantic versioning (1.0.0 for initial release)</li> <li> <code>latest</code> tag points to stable version</li> <li> <p> <code>next</code> tag for beta releases</p> </li> <li> <p> PyPI Package (aerodb-py)</p> </li> <li> Published to https://pypi.org/project/aerodb-py/</li> <li> Semantic versioning</li> <li> <p> Wheel and source distribution</p> </li> <li> <p> GitHub Releases</p> </li> <li> CHANGELOG.md kept up to date</li> <li> GitHub release for each version</li> <li> Tagged commits (v1.0.0, v1.1.0, etc.)</li> </ul>"},{"location":"JS_SDK_READINESS/#6-security","title":"6. Security","text":"<ul> <li> Token Storage</li> <li> Access token in memory by default (not localStorage)</li> <li> Refresh token in httpOnly cookie (if supported)</li> <li> <p> Tokens never logged to console/errors</p> </li> <li> <p> HTTPS Enforcement</p> </li> <li> SDK refuses to connect to http:// URLs (except localhost)</li> <li> Warning if connecting to insecure endpoint</li> </ul>"},{"location":"JS_SDK_READINESS/#7-performance","title":"7. Performance","text":"<ul> <li> Bundle Size</li> <li> JS/TS: &lt; 50KB gzipped</li> <li> <p> Tree-shakeable (unused exports removed)</p> </li> <li> <p> Dependency Count</p> </li> <li> JS/TS: Zero dependencies (use native fetch, WebSocket)</li> <li> <p> Python: Minimal dependencies (aiohttp, typing-extensions)</p> </li> <li> <p> Request Overhead</p> </li> <li> &lt; 5ms overhead over raw fetch()</li> </ul>"},{"location":"JS_SDK_READINESS/#8-backward-compatibility","title":"8. Backward Compatibility","text":"<ul> <li> Versioning Policy</li> <li> Breaking changes require major version bump</li> <li> Deprecation warnings for 1 minor version before removal</li> <li> Support for AeroDB API v1.x</li> </ul>"},{"location":"JS_SDK_READINESS/#sign-off","title":"Sign-Off","text":"<p>Phase 14 is frozen when:</p> <ol> <li>All checklist items complete</li> <li>JS/TS SDK published to npm</li> <li>Python SDK published to PyPI</li> <li>All tests pass (unit + integration)</li> <li>Documentation complete (README + API docs)</li> </ol> <p>Frozen on: [DATE]</p> <p>Approved by: [NAME]</p>"},{"location":"JS_SDK_VISION/","title":"Phase 14: Client SDKs - Vision","text":""},{"location":"JS_SDK_VISION/#purpose","title":"Purpose","text":"<p>Provide language-specific SDKs that abstract AeroDB's REST/WebSocket APIs into idiomatic, type-safe client libraries. SDKs enable developers to interact with AeroDB without manually crafting HTTP requests.</p>"},{"location":"JS_SDK_VISION/#philosophy","title":"Philosophy","text":""},{"location":"JS_SDK_VISION/#thin-clients-not-orms","title":"Thin Clients, Not ORMs","text":"<p>AeroDB SDKs are thin wrappers around the public APIs: - No business logic: SDKs serialize/deserialize, validate, and execute HTTP requests - No schema generation: Database schema is defined server-side, not in SDK - No query builders with infinite chaining: Simple, predictable API surface</p> <p>Contrast with ORMs (Prisma, Django ORM): - ORMs define models client-side \u2192 AeroDB schemas are server-defined - ORMs generate migrations \u2192 AeroDB migrations are SQL scripts - ORMs abstract SQL \u2192 AeroDB exposes SQL-like query semantics</p>"},{"location":"JS_SDK_VISION/#api-first-design","title":"API-First Design","text":"<p>SDKs mirror the REST API structure: - <code>/rest/v1/users</code> \u2192 <code>client.from('users')</code> - <code>/auth/login</code> \u2192 <code>client.auth.signIn()</code> - <code>/storage/v1/object/{bucket}/{path}</code> \u2192 <code>client.storage.from(bucket).upload(path)</code></p> <p>No magic, no hidden behavior.</p>"},{"location":"JS_SDK_VISION/#supported-languages","title":"Supported Languages","text":""},{"location":"JS_SDK_VISION/#phase-141-javascripttypescript-aerodbclient","title":"Phase 14.1: JavaScript/TypeScript (@aerodb/client)","text":"<p>Priority: HIGHEST (web developers)</p> <p>Features: - TypeScript-first (types for all methods) - ESM modules (tree-shakeable) - Works in browser (Vite/Webpack) and Node.js - WebSocket support for real-time</p>"},{"location":"JS_SDK_VISION/#phase-142-python-aerodb-py","title":"Phase 14.2: Python (aerodb-py)","text":"<p>Priority: HIGH (data science, backend)</p> <p>Features: - Type hints (mypy compatible) - Async/await support (asyncio) - Works with Flask, FastAPI, Django - Pandas integration (fetch \u2192 DataFrame)</p>"},{"location":"JS_SDK_VISION/#future-go-rust-dart","title":"Future: Go, Rust, Dart","text":"<p>Priority: MEDIUM</p> <p>Languages chosen based on user demand.</p>"},{"location":"JS_SDK_VISION/#core-tenets","title":"Core Tenets","text":""},{"location":"JS_SDK_VISION/#1-type-safety","title":"1. Type Safety","text":"<p>SDKs provide full type inference:</p> <pre><code>// TypeScript SDK\nconst { data, error } = await client\n  .from('users')\n  .select('id, name, email')\n  .eq('role', 'admin');\n\n// `data` is typed as: { id: string; name: string; email: string }[]\n// `error` is typed as: RestError | null\n</code></pre>"},{"location":"JS_SDK_VISION/#2-explicit-error-handling","title":"2. Explicit Error Handling","text":"<p>SDKs never throw exceptions (use Result type):</p> <pre><code>// Good: Predictable\nconst { data, error } = await client.from('users').select('*');\nif (error) {\n  console.error(error.message);\n} else {\n  console.log(data);\n}\n\n// Bad: Hidden control flow\ntry {\n  const data = await client.from('users').select('*'); // throws on error\n} catch (error) {\n  console.error(error);\n}\n</code></pre> <p>Python equivalent: <pre><code>result = await client.from_('users').select('*').execute()\nif result.error:\n    print(result.error.message)\nelse:\n    print(result.data)\n</code></pre></p>"},{"location":"JS_SDK_VISION/#3-method-chaining-fluent-api","title":"3. Method Chaining (Fluent API)","text":"<p>Queries are built declaratively:</p> <pre><code>const { data } = await client\n  .from('posts')\n  .select('title, author(*)')  // Embed relation\n  .gte('created_at', '2024-01-01')\n  .order('created_at', { ascending: false })\n  .limit(10);\n</code></pre>"},{"location":"JS_SDK_VISION/#4-real-time-subscriptions","title":"4. Real-Time Subscriptions","text":"<p>WebSocket API is integrated seamlessly:</p> <pre><code>const channel = client.channel('posts')\n  .on('INSERT', (payload) =&gt; {\n    console.log('New post:', payload.new);\n  })\n  .subscribe();\n\n// Later: unsubscribe\nchannel.unsubscribe();\n</code></pre>"},{"location":"JS_SDK_VISION/#non-goals","title":"Non-Goals","text":"<p>The SDKs explicitly do not:</p> <ol> <li>Generate types from database schema: Use code generation tools (e.g., <code>aerodb-codegen</code>) separately</li> <li>Manage migrations: Use CLI (<code>aerodb migrations up</code>)</li> <li>Provide an ORM: Use raw SQL for complex queries</li> <li>Abstract away HTTP: Developers should understand it's just API calls</li> <li>Support offline-first: No local cache, always hits server</li> </ol>"},{"location":"JS_SDK_VISION/#feature-matrix","title":"Feature Matrix","text":"Feature JS/TS Python Go Rust Auth (signIn, signOut) \u2705 \u2705 \ud83d\udd1c \ud83d\udd1c CRUD (select, insert, etc.) \u2705 \u2705 \ud83d\udd1c \ud83d\udd1c Real-Time (WebSocket) \u2705 \u2705 \ud83d\udd1c \ud83d\udd1c Storage (upload, download) \u2705 \u2705 \ud83d\udd1c \ud83d\udd1c Functions (invoke) \u2705 \u26a0\ufe0f \ud83d\udd1c \ud83d\udd1c Typed Responses \u2705 \u2705 \ud83d\udd1c \ud83d\udd1c Error Handling (Result) \u2705 \u2705 \ud83d\udd1c \ud83d\udd1c <p>\u2705 = Implemented | \u26a0\ufe0f = Partial | \ud83d\udd1c = Planned</p>"},{"location":"JS_SDK_VISION/#versioning-strategy","title":"Versioning Strategy","text":""},{"location":"JS_SDK_VISION/#semver","title":"Semver","text":"<p>SDKs follow semantic versioning: - Major: Breaking API changes (e.g., rename <code>signIn</code> \u2192 <code>login</code>) - Minor: New features (e.g., add <code>client.analytics</code>) - Patch: Bug fixes</p>"},{"location":"JS_SDK_VISION/#api-version-compatibility","title":"API Version Compatibility","text":"<p>SDK version maps to AeroDB API version: - <code>@aerodb/client@1.x</code> \u2192 <code>/rest/v1</code>, <code>/auth/v1</code> - <code>@aerodb/client@2.x</code> \u2192 <code>/rest/v2</code> (future)</p>"},{"location":"JS_SDK_VISION/#success-criteria","title":"Success Criteria","text":"<p>The SDKs are successful if:</p> <ol> <li>Zero config by default: <code>const client = new AeroDBClient({ url: '...' })</code> is enough</li> <li>Self-documenting: Type hints and autocomplete reveal API</li> <li>Thin: SDK bundle size &lt; 50KB (gzipped, JS/TS)</li> <li>Fast: Minimal overhead (&lt;5ms) over raw fetch()</li> </ol>"},{"location":"JS_SDK_VISION/#prior-art","title":"Prior Art","text":"<p>Inspired by: - Supabase JS: Fluent API, real-time subscriptions - Prisma Client: Type safety, result types - AWS SDK: Service-oriented structure (client.auth, client.storage) - Firebase SDK: Real-time listeners</p> <p>Differentiator: Explicit HTTP semantics - SDKs are thin, no magic.</p>"},{"location":"MANAGED_HOSTING_READINESS/","title":"Phase 15: Managed Hosting &amp; Multi-Tenancy - Readiness Criteria","text":""},{"location":"MANAGED_HOSTING_READINESS/#freeze-checklist","title":"Freeze Checklist","text":"<p>Phase 15 is ready to freeze when all items below are complete:</p>"},{"location":"MANAGED_HOSTING_READINESS/#1-control-plane-api","title":"1. Control Plane API","text":"<ul> <li> Tenant Management</li> <li> POST /v1/tenants (create tenant)</li> <li> GET /v1/tenants (list tenants)</li> <li> GET /v1/tenants/{id} (get tenant details)</li> <li> DELETE /v1/tenants/{id} (delete tenant)</li> <li> <p> PATCH /v1/tenants/{id} (update tenant config)</p> </li> <li> <p> Provisioning</p> </li> <li> Schema-per-tenant: &lt; 5 seconds</li> <li> Database-per-tenant: &lt; 30 seconds</li> <li> Cluster-per-tenant: &lt; 5 minutes</li> <li> <p> Automatic DNS setup (tenant-name.aerodb.com)</p> </li> <li> <p> Quota Enforcement</p> </li> <li> Storage limits (reject writes if exceeded)</li> <li> API request limits (rate limiting per tenant)</li> <li> File storage limits</li> <li> Real-time connection limits</li> </ul>"},{"location":"MANAGED_HOSTING_READINESS/#2-isolation-mechanisms","title":"2. Isolation Mechanisms","text":"<ul> <li> Schema-per-Tenant</li> <li> RLS policy: <code>tenant_id = current_setting('app.tenant_id')</code></li> <li> Connection pools tagged with tenant_id</li> <li> Middleware sets <code>app.tenant_id</code> on every request</li> <li> <p> Zero cross-tenant data leakage (verified by audit)</p> </li> <li> <p> Database-per-Tenant</p> </li> <li> Separate Postgres processes</li> <li> VPC isolation (if cloud-hosted)</li> <li> <p> No shared tables</p> </li> <li> <p> Cluster-per-Tenant</p> </li> <li> Dedicated VMs/containers</li> <li> Separate replication cluster</li> <li> No shared hardware</li> </ul>"},{"location":"MANAGED_HOSTING_READINESS/#3-billing-metering","title":"3. Billing &amp; Metering","text":"<ul> <li> Usage Tracking</li> <li> API requests (count, endpoint, status code)</li> <li> Storage used (documents, file storage)</li> <li> Egress bandwidth</li> <li> <p> Real-time connections (peak, average)</p> </li> <li> <p> Billing API</p> </li> <li> GET /v1/tenants/{id}/usage (current month)</li> <li> GET /v1/tenants/{id}/usage/{month} (historical)</li> <li> <p> Breakdown by resource type</p> </li> <li> <p> Invoice Generation</p> </li> <li> Monthly invoices (CSV, JSON, PDF)</li> <li> Stripe integration (optional)</li> </ul>"},{"location":"MANAGED_HOSTING_READINESS/#4-admin-dashboard-integration","title":"4. Admin Dashboard Integration","text":"<ul> <li> Tenant List</li> <li> Table with name, plan, created_at, storage_used</li> <li> Search by name</li> <li> <p> Filter by plan (Free, Pro, Enterprise)</p> </li> <li> <p> Tenant Details</p> </li> <li> Current usage metrics</li> <li> Quota limits</li> <li> Edit quota button</li> <li> <p> Delete tenant (with confirmation)</p> </li> <li> <p> Usage Charts</p> </li> <li> API requests over time</li> <li> Storage growth</li> <li> Real-time connections</li> </ul>"},{"location":"MANAGED_HOSTING_READINESS/#5-testing","title":"5. Testing","text":"<ul> <li> Unit Tests</li> <li> Tenant provisioning logic</li> <li> Quota enforcement (storage, API requests)</li> <li> <p> RLS policy generation</p> </li> <li> <p> Integration Tests</p> </li> <li> Create schema-per-tenant \u2192 insert data \u2192 verify isolation</li> <li> Create database-per-tenant \u2192 verify separate processes</li> <li> <p> Exceed quota \u2192 verify rejection</p> </li> <li> <p> Load Tests</p> </li> <li> 1000 tenants (schema-per-tenant)</li> <li> 100 tenants (database-per-tenant)</li> <li> API latency &lt; 100ms (p95) with multi-tenancy</li> </ul>"},{"location":"MANAGED_HOSTING_READINESS/#6-security","title":"6. Security","text":"<ul> <li> Tenant Isolation Audit</li> <li> Penetration test: Tenant A cannot read Tenant B's data</li> <li> SQL injection tests (parameterized queries only)</li> <li> <p> RLS bypass tests (no <code>SECURITY DEFINER</code> functions)</p> </li> <li> <p> API Authentication</p> </li> <li> Platform key required for control plane API</li> <li> Tenants cannot access other tenants' data</li> <li> Admin users cannot access tenant data without permission</li> </ul>"},{"location":"MANAGED_HOSTING_READINESS/#7-performance","title":"7. Performance","text":"<ul> <li> Provisioning Time</li> <li> Schema-per-tenant: &lt; 5s</li> <li> <p> Database-per-tenant: &lt; 30s</p> </li> <li> <p> Query Latency</p> </li> <li> Schema-per-tenant: No overhead vs single-tenant</li> <li> Database-per-tenant: &lt;10ms overhead</li> </ul>"},{"location":"MANAGED_HOSTING_READINESS/#8-documentation","title":"8. Documentation","text":"<ul> <li> Managed Hosting Guide</li> <li> How to create a tenant</li> <li> Isolation models comparison</li> <li> <p> Pricing calculator</p> </li> <li> <p> API Reference</p> </li> <li> Control Plane API (Tenant CRUD)</li> <li> Billing API</li> <li> Examples (curl, JS, Python)</li> </ul>"},{"location":"MANAGED_HOSTING_READINESS/#9-sla-uptime","title":"9. SLA &amp; Uptime","text":"<ul> <li> Monitoring</li> <li> Healthcheck per tenant (/health endpoint)</li> <li> Alert if tenant unreachable for &gt; 1 minute</li> <li> <p> Alert if quota exceeded</p> </li> <li> <p> SLA</p> </li> <li> 99.9% uptime guarantee (Free tier: best effort)</li> <li> Pro/Enterprise: &lt; 5 min downtime/month</li> </ul>"},{"location":"MANAGED_HOSTING_READINESS/#sign-off","title":"Sign-Off","text":"<p>Phase 15 is frozen when:</p> <ol> <li>All checklist items complete</li> <li>Multi-tenancy tested with 100+ tenants</li> <li>Zero cross-tenant data leakage</li> <li>Billing API functional</li> <li>Control Plane API documented</li> </ol> <p>Frozen on: [DATE]</p> <p>Approved by: [NAME]</p>"},{"location":"MANAGED_HOSTING_VISION/","title":"Phase 15: Managed Hosting &amp; Multi-Tenancy  - Vision","text":""},{"location":"MANAGED_HOSTING_VISION/#purpose","title":"Purpose","text":"<p>Provide managed AeroDB hosting with multi-tenant isolation, enabling SaaS applications to scale from prototype to production without infrastructure concerns.</p>"},{"location":"MANAGED_HOSTING_VISION/#philosophy","title":"Philosophy","text":""},{"location":"MANAGED_HOSTING_VISION/#control-plane-for-tenant-lifecycle","title":"Control Plane for Tenant Lifecycle","text":"<p>Managed hosting introduces a control plane that orchestrates tenant databases: - Provisioning: Create isolated database instances per tenant - Scaling: Auto-scale resources based on usage - Billing: Track usage, enforce quotas - Upgrades: Rolling updates without downtime</p>"},{"location":"MANAGED_HOSTING_VISION/#isolation-models","title":"Isolation Models","text":"<p>Three isolation strategies:</p> <ol> <li>Schema-per-Tenant (Shared Database)</li> <li>All tenants in one DB, separate schemas (<code>tenant_123.users</code>)</li> <li>Lowest cost, highest density</li> <li> <p>RLS ensures data isolation</p> </li> <li> <p>Database-per-Tenant (Dedicated Database)</p> </li> <li>Each tenant gets isolated database process</li> <li>Higher cost, stronger isolation</li> <li> <p>Suitable for compliance (HIPAA, SOC2)</p> </li> <li> <p>Cluster-per-Tenant (Enterprise)</p> </li> <li>Dedicated cluster (authority + replicas)</li> <li>Highest cost, maximum isolation</li> <li>For high-volume or regulated workloads</li> </ol>"},{"location":"MANAGED_HOSTING_VISION/#core-capabilities","title":"Core Capabilities","text":""},{"location":"MANAGED_HOSTING_VISION/#1-tenant-provisioning","title":"1. Tenant Provisioning","text":"<p>API to create new tenants:</p> <pre><code>curl -X POST https://control.aerodb.com/v1/tenants \\\n  -H \"Authorization: Bearer PLATFORM_KEY\" \\\n  -d '{\"name\": \"acme-corp\", \"plan\": \"pro\", \"region\": \"us-east-1\"}'\n</code></pre> <p>Response: <pre><code>{\n  \"tenant_id\": \"ten_abc123\",\n  \"database_url\": \"https://acme-corp.aerodb.com\",\n  \"created_at\": \"2024-08-15T12:00:00Z\"\n}\n</code></pre></p>"},{"location":"MANAGED_HOSTING_VISION/#2-resource-quotas","title":"2. Resource Quotas","text":"<p>Enforce limits per plan:</p> Resource Free Pro Enterprise Storage 500 MB 100 GB Unlimited API Requests 10k/mo 1M/mo Unlimited File Storage 1 GB 100 GB Unlimited Realtime Conns 100 10,000 Unlimited <p>Quota enforcement at database level (Phase 7 Control Plane integration).</p>"},{"location":"MANAGED_HOSTING_VISION/#3-metrics-billing","title":"3. Metrics &amp; Billing","text":"<p>Track usage per tenant: - API requests (count, latency) - Storage used (documents, files) - Egress bandwidth - Real-time connections</p> <p>Billing calculated monthly, exposed via admin API.</p>"},{"location":"MANAGED_HOSTING_VISION/#4-tenant-management-dashboard","title":"4. Tenant Management Dashboard","text":"<p>SaaS providers get admin panel: - List all tenants - Create/delete tenants - View usage metrics - Manage quotas</p>"},{"location":"MANAGED_HOSTING_VISION/#isolation-guarantees","title":"Isolation Guarantees","text":""},{"location":"MANAGED_HOSTING_VISION/#schema-per-tenant","title":"Schema-per-Tenant","text":"<p>Invariant: Tenant A cannot read/write Tenant B's data.</p> <p>Enforcement: - RLS policies: <code>WHERE tenant_id = current_tenant()</code> - Connection pool tagged with <code>tenant_id</code> - Middleware injects <code>SET LOCAL app.tenant_id = 'ten_123'</code></p>"},{"location":"MANAGED_HOSTING_VISION/#database-per-tenant","title":"Database-per-Tenant","text":"<p>Invariant: Tenant A's database is not aware of Tenant B's existence.</p> <p>Enforcement: - Separate Postgres processes - No shared tables, no foreign keys across tenants - Network isolation (VPC per tenant)</p>"},{"location":"MANAGED_HOSTING_VISION/#cluster-per-tenant","title":"Cluster-per-Tenant","text":"<p>Invariant: Tenant A's cluster does not share hardware with Tenant B.</p> <p>Enforcement: - Dedicated VM instances - No multi-tenancy in compute layer</p>"},{"location":"MANAGED_HOSTING_VISION/#deployment-architecture","title":"Deployment Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Control Plane (Global)                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Provisioning \u2502  \u2502 Billing API    \u2502  \u2502 Metrics API  \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2193             \u2193             \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Tenant A   \u2502  \u2502 Tenant B   \u2502  \u2502 Tenant C   \u2502\n\u2502 (Schema)   \u2502  \u2502 (Database) \u2502  \u2502 (Cluster)  \u2502\n\u2502            \u2502  \u2502            \u2502  \u2502            \u2502\n\u2502 aerodb.com \u2502  \u2502 acme.aero  \u2502  \u2502 bigco.aero \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"MANAGED_HOSTING_VISION/#success-criteria","title":"Success Criteria","text":"<p>Managed hosting is successful if:</p> <ol> <li>Tenant creation &lt; 30 seconds (schema-per-tenant)</li> <li>Zero cross-tenant data leakage (100% RLS coverage)</li> <li>99.9% uptime SLA (per tenant)</li> <li>Cost-efficient: &lt; $10/month per tenant (schema-per-tenant, low traffic)</li> </ol>"},{"location":"MANAGED_HOSTING_VISION/#non-goals","title":"Non-Goals","text":"<ul> <li>Multi-region active-active: Single region per tenant (Phase 2 replication is single-leader)</li> <li>Automatic backups: Users must configure backup schedules (Phase 1 backup/restore)</li> <li>Custom domains: Tenants use <code>tenant-name.aerodb.com</code></li> </ul>"},{"location":"MANAGED_HOSTING_VISION/#prior-art","title":"Prior Art","text":"<p>Inspired by: - Supabase Hosted: Database-per-project, auto-pause on idle - PlanetScale: Schema-per-tenant, branching for dev/prod - Heroku Postgres: Managed Postgres with add-ons - Neon: Serverless Postgres with instant provisioning</p> <p>Differentiator: Built-in multi-tenancy - RLS + control plane are integrated.</p>"},{"location":"MVCC_COMPATIBILITY/","title":"MVCC_COMPATIBILITY.md","text":""},{"location":"MVCC_COMPATIBILITY/#aerodb-mvcc-compatibility-system-integration","title":"AeroDB \u2014 MVCC Compatibility &amp; System Integration","text":""},{"location":"MVCC_COMPATIBILITY/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It defines how MVCC coexists with existing Phase-1 subsystems</li> <li>Phase-1 behavior is preserved exactly</li> <li>No implementation details appear here</li> </ul>"},{"location":"MVCC_COMPATIBILITY/#1-compatibility-principles","title":"1. Compatibility Principles","text":"<p>MVCC must integrate with AeroDB such that:</p> <ul> <li>All Phase-1 subsystems continue to behave as specified</li> <li>MVCC adds semantics without altering existing guarantees</li> <li>Any incompatibility is treated as a design error</li> </ul> <p>MVCC adapts to AeroDB \u2014 not the other way around.</p>"},{"location":"MVCC_COMPATIBILITY/#2-query-engine-compatibility","title":"2. Query Engine Compatibility","text":""},{"location":"MVCC_COMPATIBILITY/#21-parser-planner","title":"2.1 Parser &amp; Planner","text":"<ul> <li>Query parsing is unchanged</li> <li>Query planning remains deterministic and bounded</li> <li>MVCC does not introduce new query syntax at this stage</li> </ul> <p>Visibility is applied after planning, not during parsing.</p>"},{"location":"MVCC_COMPATIBILITY/#22-executor-semantics","title":"2.2 Executor Semantics","text":"<ul> <li> <p>The executor evaluates queries against:</p> </li> <li> <p>A fixed read view</p> </li> <li>MVCC visibility rules</li> <li> <p>Executor behavior must be:</p> </li> <li> <p>Deterministic</p> </li> <li>Independent of execution order</li> </ul> <p>MVCC influences what is seen, never how queries are executed.</p>"},{"location":"MVCC_COMPATIBILITY/#3-index-compatibility","title":"3. Index Compatibility","text":""},{"location":"MVCC_COMPATIBILITY/#31-conceptual-index-semantics","title":"3.1 Conceptual Index Semantics","text":"<p>Indexes under MVCC are:</p> <ul> <li>Derived structures</li> <li>Visibility-aware</li> <li>Subordinate to version visibility rules</li> </ul> <p>Indexes must never surface versions invisible to the active read view.</p>"},{"location":"MVCC_COMPATIBILITY/#32-rebuild-on-start-compatibility","title":"3.2 Rebuild-on-Start Compatibility","text":"<p>Phase-1 index behavior remains unchanged:</p> <ul> <li>Indexes may be rebuilt on startup</li> <li>Rebuilds must respect MVCC visibility</li> <li>WAL replay reconstructs version chains first</li> </ul> <p>Index correctness follows MVCC correctness.</p>"},{"location":"MVCC_COMPATIBILITY/#4-schema-system-compatibility","title":"4. Schema System Compatibility","text":""},{"location":"MVCC_COMPATIBILITY/#41-schema-validation","title":"4.1 Schema Validation","text":"<ul> <li>Schema validation applies per version</li> <li> <p>Each version must:</p> </li> <li> <p>Conform to the active schema at commit time</p> </li> <li>Historical versions are validated under their commit schema</li> </ul> <p>Schema correctness is immutable once committed.</p>"},{"location":"MVCC_COMPATIBILITY/#42-schema-evolution","title":"4.2 Schema Evolution","text":"<ul> <li>Schema versioning does not alter MVCC semantics</li> <li>Visibility rules are independent of schema changes</li> <li>Schema mismatches are explicit errors</li> </ul> <p>MVCC does not \u201creinterpret\u201d old data under new schemas.</p>"},{"location":"MVCC_COMPATIBILITY/#5-backup-restore-compatibility","title":"5. Backup &amp; Restore Compatibility","text":""},{"location":"MVCC_COMPATIBILITY/#51-backup-semantics","title":"5.1 Backup Semantics","text":"<p>Backups must include:</p> <ul> <li>All versions visible at backup boundary</li> <li>MVCC metadata</li> <li>Snapshot commit boundary</li> </ul> <p>Backups remain deterministic archives.</p>"},{"location":"MVCC_COMPATIBILITY/#52-restore-semantics","title":"5.2 Restore Semantics","text":"<p>Restore must:</p> <ul> <li>Reconstruct full MVCC state</li> <li>Preserve commit identities</li> <li>Produce identical visibility outcomes</li> </ul> <p>Restore never rewrites history.</p>"},{"location":"MVCC_COMPATIBILITY/#6-observability-compatibility","title":"6. Observability Compatibility","text":"<ul> <li> <p>Observability systems:</p> </li> <li> <p>Report MVCC state</p> </li> <li>Never influence behavior</li> <li> <p>MVCC events must be observable:</p> </li> <li> <p>Version creation</p> </li> <li>Commit</li> <li>GC</li> </ul> <p>Observability remains side-effect free.</p>"},{"location":"MVCC_COMPATIBILITY/#7-configuration-compatibility","title":"7. Configuration Compatibility","text":"<ul> <li> <p>MVCC behavior is:</p> </li> <li> <p>Explicitly configured</p> </li> <li>Fully spec-governed</li> <li>No hidden defaults</li> <li>No adaptive behavior</li> </ul> <p>If MVCC is enabled, its rules apply uniformly.</p>"},{"location":"MVCC_COMPATIBILITY/#8-phase-1-behavioral-equivalence","title":"8. Phase-1 Behavioral Equivalence","text":"<p>When MVCC is enabled but unused:</p> <ul> <li>Single-version behavior is preserved</li> <li>Queries behave exactly as Phase-1</li> <li>Performance aside, results are identical</li> </ul> <p>Phase-1 semantics are a strict subset of MVCC semantics.</p>"},{"location":"MVCC_COMPATIBILITY/#9-explicitly-forbidden-compatibility-breaks","title":"9. Explicitly Forbidden Compatibility Breaks","text":"<p>MVCC must never:</p> <ul> <li>Change query results under identical inputs</li> <li>Alter WAL durability semantics</li> <li>Introduce silent schema coercion</li> <li>Affect snapshot or restore guarantees</li> <li>Bypass existing validation logic</li> </ul> <p>Any such change is a regression.</p>"},{"location":"MVCC_COMPATIBILITY/#10-compatibility-summary","title":"10. Compatibility Summary","text":"<p>MVCC integrates with AeroDB by:</p> <ul> <li>Preserving all Phase-1 guarantees</li> <li>Respecting existing subsystem contracts</li> <li>Applying visibility rules consistently</li> <li>Avoiding any reinterpretation of history</li> </ul> <p>Compatibility is correctness.</p>"},{"location":"MVCC_FAILURE_MATRIX/","title":"MVCC_FAILURE_MATRIX.md","text":""},{"location":"MVCC_FAILURE_MATRIX/#aerodb-mvcc-failure-crash-matrix","title":"AeroDB \u2014 MVCC Failure &amp; Crash Matrix","text":""},{"location":"MVCC_FAILURE_MATRIX/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It enumerates all meaningful MVCC failure points</li> <li>Every outcome is deterministic and invariant-preserving</li> <li>No implementation details appear here</li> </ul>"},{"location":"MVCC_FAILURE_MATRIX/#1-purpose-of-the-failure-matrix","title":"1. Purpose of the Failure Matrix","text":"<p>This document defines:</p> <ul> <li>Where crashes may occur</li> <li>What state may exist at each crash point</li> <li>What recovery must produce</li> </ul> <p>There are no undefined states. Every failure maps to a valid, explainable recovery outcome.</p>"},{"location":"MVCC_FAILURE_MATRIX/#2-failure-classification","title":"2. Failure Classification","text":"<p>All MVCC-related failures fall into one of four categories:</p> <ol> <li>Before commit intent</li> <li>After commit intent, before commit identity</li> <li>After commit identity, before full persistence</li> <li>After full persistence</li> </ol> <p>Each category has strict recovery semantics.</p>"},{"location":"MVCC_FAILURE_MATRIX/#3-write-lifecycle-failure-points","title":"3. Write Lifecycle Failure Points","text":""},{"location":"MVCC_FAILURE_MATRIX/#31-failure-before-commit-intent","title":"3.1 Failure Before Commit Intent","text":"<p>Crash Point</p> <ul> <li>Before any commit intent is recorded in WAL</li> </ul> <p>State at Crash</p> <ul> <li>No MVCC metadata exists</li> <li>No versions are authoritative</li> </ul> <p>Recovery Outcome</p> <ul> <li>Write does not exist</li> <li>No versions are visible</li> <li>No cleanup required</li> </ul> <p>\u2705 Invariants preserved.</p>"},{"location":"MVCC_FAILURE_MATRIX/#32-failure-after-commit-intent-before-commit-identity","title":"3.2 Failure After Commit Intent, Before Commit Identity","text":"<p>Crash Point</p> <ul> <li>Commit intent recorded</li> <li>No commit identity recorded</li> </ul> <p>State at Crash</p> <ul> <li>Potential version data may exist</li> <li>No visibility authority exists</li> </ul> <p>Recovery Outcome</p> <ul> <li>Write is discarded</li> <li>Any partial version data is ignored</li> <li>No versions become visible</li> </ul> <p>Commit intent without identity has no effect.</p>"},{"location":"MVCC_FAILURE_MATRIX/#33-failure-after-commit-identity-before-version-durability","title":"3.3 Failure After Commit Identity, Before Version Durability","text":"<p>Crash Point</p> <ul> <li>Commit identity recorded</li> <li>One or more versions not fully durable</li> </ul> <p>State at Crash</p> <ul> <li>Commit identity exists</li> <li>Version data may be incomplete</li> </ul> <p>Recovery Outcome</p> <ul> <li>Recovery must detect inconsistency</li> <li>Recovery must fail explicitly</li> <li>No partial visibility is allowed</li> </ul> <p>Silent repair is forbidden.</p>"},{"location":"MVCC_FAILURE_MATRIX/#34-failure-after-full-commit-persistence","title":"3.4 Failure After Full Commit Persistence","text":"<p>Crash Point</p> <ul> <li>Commit identity recorded</li> <li>All versions fully durable</li> </ul> <p>State at Crash</p> <ul> <li>Complete MVCC state exists</li> </ul> <p>Recovery Outcome</p> <ul> <li>All versions are visible</li> <li>Version chains are intact</li> <li>Visibility rules apply normally</li> </ul> <p>This is the success case.</p>"},{"location":"MVCC_FAILURE_MATRIX/#4-read-view-failure-scenarios","title":"4. Read View Failure Scenarios","text":""},{"location":"MVCC_FAILURE_MATRIX/#41-crash-during-read-view-creation","title":"4.1 Crash During Read View Creation","text":"<p>Crash Point</p> <ul> <li>While establishing read view</li> </ul> <p>Recovery Outcome</p> <ul> <li>Read operation is aborted</li> <li>No persistent state is affected</li> </ul> <p>Reads do not mutate MVCC state.</p>"},{"location":"MVCC_FAILURE_MATRIX/#42-crash-during-read-execution","title":"4.2 Crash During Read Execution","text":"<p>Crash Point</p> <ul> <li>While reading visible versions</li> </ul> <p>Recovery Outcome</p> <ul> <li>Read is aborted</li> <li>No visibility state is altered</li> <li>MVCC state remains unchanged</li> </ul> <p>Reads are restart-safe.</p>"},{"location":"MVCC_FAILURE_MATRIX/#5-snapshot-related-failures","title":"5. Snapshot-Related Failures","text":""},{"location":"MVCC_FAILURE_MATRIX/#51-crash-before-snapshot-boundary-selection","title":"5.1 Crash Before Snapshot Boundary Selection","text":"<p>Recovery Outcome</p> <ul> <li>Snapshot does not exist</li> <li>WAL remains authoritative</li> </ul>"},{"location":"MVCC_FAILURE_MATRIX/#52-crash-after-snapshot-boundary-before-snapshot-completion","title":"5.2 Crash After Snapshot Boundary, Before Snapshot Completion","text":"<p>Recovery Outcome</p> <ul> <li>Snapshot is discarded</li> <li>WAL replay resumes normally</li> </ul> <p>Partial snapshots are invalid.</p>"},{"location":"MVCC_FAILURE_MATRIX/#53-crash-after-snapshot-completion","title":"5.3 Crash After Snapshot Completion","text":"<p>Recovery Outcome</p> <ul> <li>Snapshot is valid</li> <li>MVCC boundary is authoritative</li> <li>WAL replay resumes after snapshot boundary</li> </ul>"},{"location":"MVCC_FAILURE_MATRIX/#6-garbage-collection-failures","title":"6. Garbage Collection Failures","text":""},{"location":"MVCC_FAILURE_MATRIX/#61-crash-before-gc-record","title":"6.1 Crash Before GC Record","text":"<p>Recovery Outcome</p> <ul> <li>No versions are removed</li> <li>GC is effectively rolled back</li> </ul>"},{"location":"MVCC_FAILURE_MATRIX/#62-crash-after-gc-record","title":"6.2 Crash After GC Record","text":"<p>Recovery Outcome</p> <ul> <li>Version removal is replayed</li> <li>Versions remain collected</li> <li>No resurrection is allowed</li> </ul>"},{"location":"MVCC_FAILURE_MATRIX/#7-wal-truncation-failures","title":"7. WAL Truncation Failures","text":""},{"location":"MVCC_FAILURE_MATRIX/#71-crash-before-truncation","title":"7.1 Crash Before Truncation","text":"<p>Recovery Outcome</p> <ul> <li>WAL remains intact</li> <li>Recovery proceeds normally</li> </ul>"},{"location":"MVCC_FAILURE_MATRIX/#72-crash-after-truncation","title":"7.2 Crash After Truncation","text":"<p>Recovery Outcome</p> <ul> <li>Snapshot provides full MVCC state</li> <li>No visibility loss occurs</li> </ul>"},{"location":"MVCC_FAILURE_MATRIX/#8-forbidden-recovery-outcomes","title":"8. Forbidden Recovery Outcomes","text":"<p>Recovery must never produce:</p> <ul> <li>Partially visible commits</li> <li>Orphaned versions</li> <li>Missing commit identities</li> <li>Reordered commits</li> <li>Healed corruption</li> </ul> <p>Any such state is a fatal error.</p>"},{"location":"MVCC_FAILURE_MATRIX/#9-determinism-guarantee","title":"9. Determinism Guarantee","text":"<p>For any failure point:</p> <ul> <li>Recovery outcome is unique</li> <li>No ambiguity exists</li> <li>No heuristic decisions are made</li> </ul> <p>Crash behavior is a function of WAL state alone.</p>"},{"location":"MVCC_FAILURE_MATRIX/#10-summary","title":"10. Summary","text":"<p>MVCC failure handling in AeroDB ensures:</p> <ul> <li>No acknowledged commit is lost</li> <li>No uncommitted state becomes visible</li> <li>No crash introduces ambiguity</li> <li>All invariants are preserved</li> </ul>"},{"location":"MVCC_GC_MODEL/","title":"MVCC_GC.md","text":""},{"location":"MVCC_GC_MODEL/#aerodb-mvcc-garbage-collection","title":"AeroDB \u2014 MVCC Garbage Collection","text":""},{"location":"MVCC_GC_MODEL/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It defines when and why versions may be reclaimed</li> <li>Garbage collection (GC) is correctness-driven, not performance-driven</li> <li>No implementation details appear here</li> </ul>"},{"location":"MVCC_GC_MODEL/#1-purpose-of-mvcc-garbage-collection","title":"1. Purpose of MVCC Garbage Collection","text":"<p>MVCC garbage collection exists to:</p> <ul> <li>Reclaim storage occupied by provably unreachable versions</li> <li>Preserve long-term system health</li> <li>Do so without ever weakening correctness</li> </ul> <p>GC is optional for progress, but mandatory for correctness in the sense that:</p> <p>A version must never be removed unless it is proven invisible to all possible reads.</p>"},{"location":"MVCC_GC_MODEL/#2-version-lifecycle-states","title":"2. Version Lifecycle States","text":"<p>Every version exists in exactly one of the following logical states.</p>"},{"location":"MVCC_GC_MODEL/#21-live","title":"2.1 Live","text":"<p>A version is Live if:</p> <ul> <li>It is visible to at least one possible read view</li> <li>Or it may become visible in the future</li> </ul> <p>Live versions are untouchable by GC.</p>"},{"location":"MVCC_GC_MODEL/#22-obsolete","title":"2.2 Obsolete","text":"<p>A version is Obsolete if:</p> <ul> <li>It has been superseded by a newer committed version</li> <li>But may still be visible to some read views</li> </ul> <p>Obsolete does not mean reclaimable.</p>"},{"location":"MVCC_GC_MODEL/#23-reclaimable","title":"2.3 Reclaimable","text":"<p>A version is Reclaimable if and only if:</p> <ul> <li>It is not visible to any possible read view</li> <li> <p>It is not required by:</p> </li> <li> <p>Any snapshot</p> </li> <li>Any checkpoint</li> <li>Recovery semantics</li> </ul> <p>Reclaimable is a proof-based state, not a heuristic.</p>"},{"location":"MVCC_GC_MODEL/#24-collected","title":"2.4 Collected","text":"<p>A version is Collected once:</p> <ul> <li>Its removal has been fully recorded</li> <li>Recovery will not resurrect it</li> <li>No reference to it remains</li> </ul> <p>Collected versions no longer exist.</p>"},{"location":"MVCC_GC_MODEL/#3-visibility-lower-bound","title":"3. Visibility Lower Bound","text":""},{"location":"MVCC_GC_MODEL/#31-global-visibility-floor","title":"3.1 Global Visibility Floor","text":"<p>At any time, the system has a visibility lower bound defined by:</p> <ul> <li>The oldest active read view</li> <li>The oldest retained snapshot boundary</li> </ul> <p>No version with:</p> <pre><code>commit_id \u2265 visibility_lower_bound\n</code></pre> <p>may be reclaimed.</p>"},{"location":"MVCC_GC_MODEL/#32-determinism-requirement","title":"3.2 Determinism Requirement","text":"<p>The visibility lower bound must be:</p> <ul> <li>Explicit</li> <li>Deterministic</li> <li>Recoverable after crash</li> </ul> <p>It must not be inferred from timing or runtime observation.</p>"},{"location":"MVCC_GC_MODEL/#4-gc-eligibility-rule-formal","title":"4. GC Eligibility Rule (Formal)","text":"<p>A version <code>V</code> with commit identity <code>C</code> is reclaimable if and only if:</p> <ol> <li><code>C &lt; visibility_lower_bound</code></li> <li>A newer version exists in the same version chain</li> <li>No snapshot requires <code>V</code></li> <li>Recovery correctness is preserved without <code>V</code></li> </ol> <p>All four conditions are mandatory.</p>"},{"location":"MVCC_GC_MODEL/#5-interaction-with-wal","title":"5. Interaction with WAL","text":""},{"location":"MVCC_GC_MODEL/#51-gc-as-a-durable-event","title":"5.1 GC as a Durable Event","text":"<ul> <li>Version removal must be WAL-recorded</li> <li>GC decisions are replayable</li> <li>Recovery must never \u201cre-collect\u201d versions implicitly</li> </ul> <p>GC without WAL representation is forbidden.</p>"},{"location":"MVCC_GC_MODEL/#52-crash-safety","title":"5.2 Crash Safety","text":"<p>If a crash occurs:</p> <ul> <li> <p>Before GC record durability:</p> </li> <li> <p>Version remains</p> </li> <li> <p>After GC record durability:</p> </li> <li> <p>Version is considered collected</p> </li> </ul> <p>There is no intermediate GC state.</p>"},{"location":"MVCC_GC_MODEL/#6-snapshot-retention-rules","title":"6. Snapshot Retention Rules","text":"<p>Snapshots impose hard retention barriers:</p> <ul> <li> <p>Any version visible at a snapshot boundary:</p> </li> <li> <p>Must be retained</p> </li> <li>GC must consider all snapshots, not only the latest</li> </ul> <p>Deleting a snapshot may lower the visibility floor, but never raises it.</p>"},{"location":"MVCC_GC_MODEL/#7-checkpoint-interaction","title":"7. Checkpoint Interaction","text":"<ul> <li> <p>Checkpoints may enable GC by:</p> </li> <li> <p>Eliminating WAL dependencies</p> </li> <li>Freezing a visibility boundary</li> <li>Checkpoints do not force GC</li> <li>GC is optional, never mandatory</li> </ul> <p>Checkpointing does not change eligibility rules.</p>"},{"location":"MVCC_GC_MODEL/#8-deterministic-gc-ordering","title":"8. Deterministic GC Ordering","text":"<p>GC must be:</p> <ul> <li>Deterministic</li> <li>Order-independent for correctness</li> <li>Safe under replay</li> </ul> <p>The exact order of reclaiming eligible versions must not affect correctness.</p>"},{"location":"MVCC_GC_MODEL/#9-explicitly-forbidden-gc-behaviors","title":"9. Explicitly Forbidden GC Behaviors","text":"<p>GC must never:</p> <ul> <li>Guess whether a version is unused</li> <li>Use wall-clock age as a criterion</li> <li>Remove the newest version of a key</li> <li>Violate snapshot retention</li> <li>Operate outside WAL authority</li> </ul> <p>Space pressure is never a justification to violate invariants.</p>"},{"location":"MVCC_GC_MODEL/#10-gc-summary","title":"10. GC Summary","text":"<p>MVCC garbage collection in AeroDB is:</p> <ul> <li>Proof-based</li> <li>Snapshot-aware</li> <li>WAL-governed</li> <li>Crash-safe</li> <li>Deterministic</li> </ul> <p>GC is allowed only when correctness is preserved beyond doubt.</p>"},{"location":"MVCC_MODEL/","title":"MVCC.md","text":""},{"location":"MVCC_MODEL/#aerodb-mvcc-conceptual-model","title":"AeroDB \u2014 MVCC Conceptual Model","text":""},{"location":"MVCC_MODEL/#status","title":"Status","text":"<ul> <li>This document defines the conceptual MVCC model</li> <li>It specifies what exists, not how it is implemented</li> <li>No algorithms, data structures, or optimizations appear here</li> <li>All Phase-1 and Phase-2 invariants apply</li> </ul>"},{"location":"MVCC_MODEL/#1-purpose-of-mvcc-in-aerodb","title":"1. Purpose of MVCC in AeroDB","text":"<p>MVCC exists to allow concurrent, correct access to data while preserving:</p> <ul> <li>Deterministic behavior</li> <li>Crash safety</li> <li>Historical correctness</li> <li>Read stability</li> </ul> <p>MVCC is the mechanism by which AeroDB reasons about time, visibility, and concurrency without introducing ambiguity or heuristics.</p>"},{"location":"MVCC_MODEL/#2-fundamental-mvcc-concepts","title":"2. Fundamental MVCC Concepts","text":""},{"location":"MVCC_MODEL/#21-version","title":"2.1 Version","text":"<p>A version is a logically immutable representation of a document at a specific point in the database\u2019s history.</p> <p>A version has:</p> <ul> <li>A complete document payload or an explicit tombstone</li> <li>A commit identity (defined later)</li> <li>Deterministic visibility semantics</li> </ul> <p>Once created, a version never changes.</p>"},{"location":"MVCC_MODEL/#22-version-chain","title":"2.2 Version Chain","text":"<p>For any logical document key:</p> <ul> <li>Versions form a total order</li> <li>Each version supersedes exactly one prior version (if any)</li> <li>There are no forks or branches</li> </ul> <p>The version chain represents the full history of a document.</p>"},{"location":"MVCC_MODEL/#23-commit-identity","title":"2.3 Commit Identity","text":"<p>Every committed version is associated with a commit identity that:</p> <ul> <li>Totally orders all commits</li> <li>Is deterministic across crashes and recovery</li> <li>Is independent of wall-clock time</li> </ul> <p>The commit identity is the only authority for ordering versions.</p>"},{"location":"MVCC_MODEL/#3-read-views","title":"3. Read Views","text":""},{"location":"MVCC_MODEL/#31-definition","title":"3.1 Definition","text":"<p>A read view is a stable description of which committed versions are visible to a read operation.</p> <p>A read view:</p> <ul> <li>Is established at read start</li> <li>Never changes during the read</li> <li>Is defined purely in terms of commit identities</li> </ul>"},{"location":"MVCC_MODEL/#32-read-view-properties","title":"3.2 Read View Properties","text":"<p>A read view guarantees:</p> <ul> <li>No partial writes are visible</li> <li>No future commits are visible</li> <li>Visibility decisions are deterministic</li> </ul> <p>Two reads with the same read view must observe identical results.</p>"},{"location":"MVCC_MODEL/#4-writes-and-version-creation","title":"4. Writes and Version Creation","text":""},{"location":"MVCC_MODEL/#41-write-semantics","title":"4.1 Write Semantics","text":"<p>A write operation:</p> <ul> <li>Does not modify existing versions</li> <li>Produces one or more new versions</li> <li>Becomes visible only after commit</li> </ul> <p>Writes are atomic with respect to visibility.</p>"},{"location":"MVCC_MODEL/#42-deletes","title":"4.2 Deletes","text":"<p>Deletes are represented as:</p> <ul> <li>Explicit tombstone versions</li> <li>Fully ordered in the version chain</li> <li>Subject to the same visibility rules as updates</li> </ul> <p>There is no implicit deletion.</p>"},{"location":"MVCC_MODEL/#5-transactions-conceptual","title":"5. Transactions (Conceptual)","text":"<p>MVCC introduces the concept of a transaction purely as a logical grouping:</p> <ul> <li>A transaction may produce multiple versions</li> <li>Visibility of all versions is atomic at commit</li> <li>Transactions do not imply locking semantics in this document</li> </ul> <p>Transaction behavior is defined by visibility rules, not execution strategy.</p>"},{"location":"MVCC_MODEL/#6-visibility-rule-conceptual","title":"6. Visibility Rule (Conceptual)","text":"<p>For a given read view and a version chain:</p> <ul> <li>The visible version is the latest committed version</li> <li>Whose commit identity is \u2264 the read view\u2019s upper bound</li> <li>And is not superseded by another visible version</li> </ul> <p>This rule is absolute and admits no exceptions.</p>"},{"location":"MVCC_MODEL/#7-interaction-with-phase-1-model","title":"7. Interaction with Phase-1 Model","text":"<p>Without MVCC:</p> <ul> <li>Each document had exactly one visible version</li> </ul> <p>With MVCC:</p> <ul> <li> <p>Phase-1 behavior is equivalent to:</p> </li> <li> <p>A single-version chain</p> </li> <li>A read view that always sees the latest commit</li> </ul> <p>Thus, MVCC strictly generalizes Phase-1 semantics without altering them.</p>"},{"location":"MVCC_MODEL/#8-crash-and-recovery-perspective","title":"8. Crash and Recovery Perspective","text":"<p>From a crash-recovery standpoint:</p> <ul> <li>A version either exists fully or not at all</li> <li>Commit identity assignment is WAL-governed</li> <li>Recovery reconstructs version chains deterministically</li> </ul> <p>There is no concept of \u201cin-doubt\u201d visibility after recovery.</p>"},{"location":"MVCC_MODEL/#9-explicit-non-goals","title":"9. Explicit Non-Goals","text":"<p>This document does not define:</p> <ul> <li>Isolation levels</li> <li>Locking or conflict detection</li> <li>Storage layout</li> <li>Garbage collection</li> <li>Performance characteristics</li> </ul> <p>Those are handled in subsequent documents.</p>"},{"location":"MVCC_MODEL/#10-conceptual-summary","title":"10. Conceptual Summary","text":"<p>MVCC in AeroDB introduces:</p> <ul> <li>Immutable version history</li> <li>Deterministic commit ordering</li> <li>Stable read views</li> <li>Explicit visibility rules</li> </ul> <p>All without compromising:</p> <ul> <li>Durability</li> <li>Determinism</li> <li>Recoverability</li> <li>Phase-1 guarantees</li> </ul>"},{"location":"MVCC_SNAPSHOT_MODEL/","title":"MVCC_SNAPSHOT_INTEGRATION.md","text":""},{"location":"MVCC_SNAPSHOT_MODEL/#aerodb-mvcc-and-snapshot-integration","title":"AeroDB \u2014 MVCC and Snapshot Integration","text":""},{"location":"MVCC_SNAPSHOT_MODEL/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It defines how MVCC interacts with snapshots and checkpoints</li> <li>Snapshot correctness is non-negotiable</li> <li>No implementation details appear here</li> </ul>"},{"location":"MVCC_SNAPSHOT_MODEL/#1-purpose-of-mvcc-snapshots","title":"1. Purpose of MVCC Snapshots","text":"<p>Snapshots in AeroDB serve two distinct roles:</p> <ol> <li>Read-only durability artifacts</li> <li>Recovery acceleration mechanisms</li> </ol> <p>With MVCC, snapshots additionally define a stable visibility boundary for historical versions.</p>"},{"location":"MVCC_SNAPSHOT_MODEL/#2-snapshot-as-an-mvcc-cut","title":"2. Snapshot as an MVCC Cut","text":""},{"location":"MVCC_SNAPSHOT_MODEL/#21-definition","title":"2.1 Definition","text":"<p>An MVCC snapshot represents:</p> <ul> <li>A complete database state</li> <li>At a specific commit identity boundary</li> <li>With all visible versions included</li> </ul> <p>Formally, a snapshot captures all versions with:</p> <pre><code>commit_id \u2264 snapshot_commit_boundary\n</code></pre> <p>No version beyond this boundary exists in the snapshot.</p>"},{"location":"MVCC_SNAPSHOT_MODEL/#22-snapshot-completeness-invariant","title":"2.2 Snapshot Completeness Invariant","text":"<p>A snapshot must include:</p> <ul> <li>All document versions visible at the boundary</li> <li>All required MVCC metadata to interpret visibility</li> <li>No dangling references to WAL-only state</li> </ul> <p>A snapshot is invalid if any visible version is missing.</p>"},{"location":"MVCC_SNAPSHOT_MODEL/#3-snapshot-creation-rules","title":"3. Snapshot Creation Rules","text":""},{"location":"MVCC_SNAPSHOT_MODEL/#31-atomicity","title":"3.1 Atomicity","text":"<ul> <li>Snapshot creation observes a single commit boundary</li> <li>That boundary is immutable for the snapshot</li> <li>Snapshot creation never observes partial commits</li> </ul>"},{"location":"MVCC_SNAPSHOT_MODEL/#32-concurrency","title":"3.2 Concurrency","text":"<ul> <li>Snapshot creation may run concurrently with writes</li> <li> <p>Concurrent commits with commit identities:</p> </li> <li> <p>\u2264 boundary \u2192 included</p> </li> <li> <p>boundary \u2192 excluded</p> </li> </ul> <p>Visibility rules remain unchanged.</p>"},{"location":"MVCC_SNAPSHOT_MODEL/#4-snapshot-usage-for-reads","title":"4. Snapshot Usage for Reads","text":""},{"location":"MVCC_SNAPSHOT_MODEL/#41-read-only-operation","title":"4.1 Read-Only Operation","text":"<p>When serving reads from a snapshot:</p> <ul> <li>Read views are derived from the snapshot boundary</li> <li>No WAL data beyond the snapshot is consulted</li> <li>Visibility is fully determined by snapshot state</li> </ul> <p>Snapshots are fully self-contained for reads.</p>"},{"location":"MVCC_SNAPSHOT_MODEL/#42-snapshot-isolation-preservation","title":"4.2 Snapshot Isolation Preservation","text":"<p>Reads served from snapshots:</p> <ul> <li>Provide the same snapshot isolation semantics</li> <li>Are indistinguishable from live reads at that boundary</li> <li>Do not introduce special cases</li> </ul>"},{"location":"MVCC_SNAPSHOT_MODEL/#5-interaction-with-checkpoints","title":"5. Interaction with Checkpoints","text":""},{"location":"MVCC_SNAPSHOT_MODEL/#51-checkpoint-semantics","title":"5.1 Checkpoint Semantics","text":"<p>A checkpoint:</p> <ul> <li>Produces a snapshot</li> <li>Establishes a WAL truncation point</li> <li>Preserves MVCC correctness</li> </ul> <p>Checkpointing does not alter MVCC rules.</p>"},{"location":"MVCC_SNAPSHOT_MODEL/#52-wal-truncation-safety","title":"5.2 WAL Truncation Safety","text":"<p>WAL entries may be truncated only if:</p> <ul> <li>Their effects are fully represented in the snapshot</li> <li>MVCC state remains reconstructible</li> <li>No version required for recovery is lost</li> </ul>"},{"location":"MVCC_SNAPSHOT_MODEL/#6-snapshot-restore-and-mvcc","title":"6. Snapshot Restore and MVCC","text":"<p>On restore:</p> <ul> <li>Snapshot MVCC state is loaded first</li> <li>WAL replay resumes strictly after snapshot boundary</li> <li>Commit identities remain monotonic</li> </ul> <p>Restore produces the same MVCC state as uninterrupted operation.</p>"},{"location":"MVCC_SNAPSHOT_MODEL/#7-garbage-collection-interaction","title":"7. Garbage Collection Interaction","text":"<p>Snapshots impose retention constraints:</p> <ul> <li> <p>Versions required by any snapshot boundary:</p> </li> <li> <p>Must not be reclaimed</p> </li> <li>GC must be snapshot-aware</li> </ul> <p>Snapshots are authoritative visibility anchors.</p>"},{"location":"MVCC_SNAPSHOT_MODEL/#8-crash-safety-during-snapshotting","title":"8. Crash Safety During Snapshotting","text":"<p>If a crash occurs during snapshot creation:</p> <ul> <li> <p>Snapshot is either:</p> </li> <li> <p>Fully valid, or</p> </li> <li>Fully discarded</li> <li>No partially written snapshot is usable</li> <li>MVCC state remains intact via WAL</li> </ul> <p>Snapshots never introduce ambiguity.</p>"},{"location":"MVCC_SNAPSHOT_MODEL/#9-explicitly-forbidden-snapshot-behaviors","title":"9. Explicitly Forbidden Snapshot Behaviors","text":"<p>Snapshots must never:</p> <ul> <li>Reference WAL state implicitly</li> <li>Omit MVCC metadata</li> <li>Contain partially visible commits</li> <li>Alter visibility semantics</li> </ul> <p>If a snapshot cannot serve correct reads alone, it is invalid.</p>"},{"location":"MVCC_SNAPSHOT_MODEL/#10-summary","title":"10. Summary","text":"<p>MVCC snapshots in AeroDB are:</p> <ul> <li>Deterministic MVCC cuts</li> <li>Self-contained and durable</li> <li>Safe for reads and recovery</li> <li>Fully consistent with Phase-1 snapshot guarantees</li> </ul>"},{"location":"MVCC_TESTING/","title":"MVCC_TESTING_STRATEGY.md","text":""},{"location":"MVCC_TESTING/#aerodb-mvcc-testing-strategy","title":"AeroDB \u2014 MVCC Testing Strategy","text":""},{"location":"MVCC_TESTING/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It defines how MVCC correctness is proven</li> <li>All tests are deterministic and reproducible</li> <li>No performance benchmarks appear here</li> </ul>"},{"location":"MVCC_TESTING/#1-testing-philosophy","title":"1. Testing Philosophy","text":"<p>MVCC testing in AeroDB exists to prove:</p> <ul> <li>Correctness under concurrency</li> <li>Determinism under all execution orders</li> <li>Crash safety at every boundary</li> <li>Invariant preservation across lifecycle events</li> </ul> <p>Tests do not attempt to infer correctness from performance or timing.</p>"},{"location":"MVCC_TESTING/#2-core-test-categories","title":"2. Core Test Categories","text":""},{"location":"MVCC_TESTING/#21-visibility-correctness-tests","title":"2.1 Visibility Correctness Tests","text":"<p>These tests verify that visibility rules are applied exactly as specified.</p> <p>Required Coverage</p> <ul> <li>Single-key reads across multiple versions</li> <li>Read views before, during, and after commits</li> <li>Tombstone visibility behavior</li> <li>Range queries with mixed version chains</li> </ul> <p>Assertions</p> <ul> <li>Visible version matches <code>MVCC_VISIBILITY.md</code></li> <li>No future commit leakage</li> <li>Stability across repeated reads</li> </ul>"},{"location":"MVCC_TESTING/#22-snapshot-isolation-tests","title":"2.2 Snapshot Isolation Tests","text":"<p>These tests verify snapshot isolation semantics.</p> <p>Required Coverage</p> <ul> <li>Concurrent reads and writes</li> <li>Reads spanning long write sequences</li> <li>Identical read views produce identical results</li> <li>Monotonic visibility across read views</li> </ul> <p>Assertions</p> <ul> <li>No non-repeatable reads</li> <li>No phantom visibility changes</li> <li>Deterministic results regardless of scheduling</li> </ul>"},{"location":"MVCC_TESTING/#3-wal-recovery-tests","title":"3. WAL &amp; Recovery Tests","text":""},{"location":"MVCC_TESTING/#31-commit-durability-tests","title":"3.1 Commit Durability Tests","text":"<p>Scenarios</p> <ul> <li>Crash before commit intent</li> <li>Crash after commit intent</li> <li>Crash after commit identity</li> <li>Crash after full persistence</li> </ul> <p>Assertions</p> <ul> <li>Visibility outcomes match <code>MVCC_FAILURE_MATRIX.md</code></li> <li>No partial commits appear</li> <li>No silent repair occurs</li> </ul>"},{"location":"MVCC_TESTING/#32-wal-replay-determinism-tests","title":"3.2 WAL Replay Determinism Tests","text":"<p>Scenarios</p> <ul> <li>Replaying identical WAL multiple times</li> <li>Replay with interleaved MVCC and non-MVCC records</li> </ul> <p>Assertions</p> <ul> <li>Identical MVCC state reconstructed</li> <li>Commit identity ordering preserved</li> </ul>"},{"location":"MVCC_TESTING/#4-snapshot-checkpoint-tests","title":"4. Snapshot &amp; Checkpoint Tests","text":""},{"location":"MVCC_TESTING/#41-snapshot-integrity-tests","title":"4.1 Snapshot Integrity Tests","text":"<p>Scenarios</p> <ul> <li>Snapshot creation during concurrent writes</li> <li>Snapshot restore without WAL</li> <li>Snapshot restore with WAL continuation</li> </ul> <p>Assertions</p> <ul> <li>Snapshot serves correct read views</li> <li>Snapshot boundaries are respected</li> <li>No missing or extra versions</li> </ul>"},{"location":"MVCC_TESTING/#42-checkpoint-interaction-tests","title":"4.2 Checkpoint Interaction Tests","text":"<p>Scenarios</p> <ul> <li>Checkpoint followed by crash</li> <li>Checkpoint followed by WAL truncation</li> <li>Checkpoint followed by restore</li> </ul> <p>Assertions</p> <ul> <li>MVCC state remains correct</li> <li>No visibility loss</li> <li>WAL truncation is safe</li> </ul>"},{"location":"MVCC_TESTING/#5-garbage-collection-tests","title":"5. Garbage Collection Tests","text":""},{"location":"MVCC_TESTING/#51-eligibility-proof-tests","title":"5.1 Eligibility Proof Tests","text":"<p>Scenarios</p> <ul> <li>Versions below visibility floor</li> <li>Versions above visibility floor</li> <li>Snapshot-retained versions</li> </ul> <p>Assertions</p> <ul> <li>Only reclaimable versions are collected</li> <li>Live or obsolete versions are retained</li> </ul>"},{"location":"MVCC_TESTING/#52-gc-crash-tests","title":"5.2 GC Crash Tests","text":"<p>Scenarios</p> <ul> <li>Crash before GC record</li> <li>Crash after GC record</li> </ul> <p>Assertions</p> <ul> <li>GC behavior is replay-safe</li> <li>No version resurrection</li> <li>No premature deletion</li> </ul>"},{"location":"MVCC_TESTING/#6-concurrency-stress-tests-deterministic","title":"6. Concurrency Stress Tests (Deterministic)","text":"<p>Concurrency tests must:</p> <ul> <li>Use controlled scheduling</li> <li>Enumerate execution interleavings</li> <li>Avoid timing-based assertions</li> </ul> <p>Scenarios</p> <ul> <li>Multiple readers + writers</li> <li>Long-lived readers with short writes</li> <li>Write-heavy sequences with GC enabled</li> </ul>"},{"location":"MVCC_TESTING/#7-crash-injection-strategy","title":"7. Crash Injection Strategy","text":"<p>MVCC tests must integrate with the existing crash harness:</p> <ul> <li> <p>Kill points at:</p> </li> <li> <p>Commit intent</p> </li> <li>Commit identity</li> <li>Version persistence</li> <li>Snapshot boundaries</li> <li>GC record points</li> <li>Deterministic recovery assertions</li> </ul> <p>Crash testing is mandatory, not optional.</p>"},{"location":"MVCC_TESTING/#8-negative-testing","title":"8. Negative Testing","text":"<p>Tests must explicitly verify failure cases:</p> <ul> <li>Corrupted MVCC metadata</li> <li>Missing WAL records</li> <li>Incomplete snapshots</li> <li>Invalid visibility boundaries</li> </ul> <p>Expected outcome: explicit failure, never silent success.</p>"},{"location":"MVCC_TESTING/#9-phase-1-regression-guard","title":"9. Phase-1 Regression Guard","text":"<p>All Phase-1 tests must be re-run with MVCC enabled.</p> <p>Assertions:</p> <ul> <li>Identical query results</li> <li>Identical durability guarantees</li> <li>No behavioral regressions</li> </ul> <p>MVCC must be transparent to Phase-1 behavior.</p>"},{"location":"MVCC_TESTING/#10-testing-summary","title":"10. Testing Summary","text":"<p>MVCC correctness is proven by:</p> <ul> <li>Deterministic unit tests</li> <li>Structured crash tests</li> <li>Explicit failure assertions</li> <li>Regression coverage</li> </ul> <p>If a behavior is untestable, it is unspecifiable.</p>"},{"location":"MVCC_VISIBILITY_RULES/","title":"MVCC_VISIBILITY.md","text":""},{"location":"MVCC_VISIBILITY_RULES/#aerodb-mvcc-visibility-isolation-semantics","title":"AeroDB \u2014 MVCC Visibility &amp; Isolation Semantics","text":""},{"location":"MVCC_VISIBILITY_RULES/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It formally defines what a reader can observe</li> <li>All rules are deterministic and invariant-driven</li> <li>No implementation details appear here</li> </ul>"},{"location":"MVCC_VISIBILITY_RULES/#1-scope-of-this-document","title":"1. Scope of This Document","text":"<p>This document defines:</p> <ul> <li>Read visibility rules</li> <li>Read view structure</li> <li>Isolation semantics provided by MVCC</li> <li>What outcomes are allowed and forbidden</li> </ul> <p>This document does not define:</p> <ul> <li>Locking strategies</li> <li>Conflict detection</li> <li>Transaction execution models</li> <li>Performance optimizations</li> </ul>"},{"location":"MVCC_VISIBILITY_RULES/#2-fundamental-definitions","title":"2. Fundamental Definitions","text":""},{"location":"MVCC_VISIBILITY_RULES/#21-commit-identity","title":"2.1 Commit Identity","text":"<p>A commit identity is a totally ordered identifier assigned to a committed write set.</p> <p>Properties:</p> <ul> <li>Strict total order</li> <li>Deterministic across crashes</li> <li>Monotonic with respect to WAL replay</li> <li>Independent of wall-clock time</li> </ul> <p>No two commits share the same commit identity.</p>"},{"location":"MVCC_VISIBILITY_RULES/#22-read-view","title":"2.2 Read View","text":"<p>A read view is defined by a single scalar value:</p> <ul> <li><code>read_upper_bound</code></li> </ul> <p>This value represents:</p> <p>\u201cThe maximum commit identity visible to this read.\u201d</p> <p>All versions with commit identities greater than this value are invisible.</p>"},{"location":"MVCC_VISIBILITY_RULES/#3-visibility-rule-formal","title":"3. Visibility Rule (Formal)","text":"<p>Given:</p> <ul> <li>A read view <code>R</code></li> <li>A logical document key <code>K</code></li> <li>A version chain <code>V\u2080 \u2026 V\u2099</code> ordered by commit identity (ascending)</li> </ul> <p>The visible version <code>V*</code> is defined as:</p> <ol> <li>Consider only versions where    <code>V.commit_id \u2264 R.read_upper_bound</code></li> <li>From those, select the version with the largest commit_id</li> <li>If that version is a tombstone, <code>K</code> is invisible</li> </ol> <p>This rule is absolute and admits no exceptions.</p>"},{"location":"MVCC_VISIBILITY_RULES/#4-isolation-level-provided","title":"4. Isolation Level Provided","text":""},{"location":"MVCC_VISIBILITY_RULES/#41-guaranteed-isolation-snapshot-isolation-deterministic","title":"4.1 Guaranteed Isolation: Snapshot Isolation (Deterministic)","text":"<p>AeroDB MVCC provides deterministic snapshot isolation with the following guarantees:</p> <ul> <li>Readers observe a stable snapshot</li> <li>Reads never block writes</li> <li>Writes never block reads for correctness</li> <li>No dirty reads</li> <li>No non-repeatable reads</li> <li>No phantom visibility changes within a read</li> </ul> <p>This isolation level is explicit and fixed.</p>"},{"location":"MVCC_VISIBILITY_RULES/#42-explicitly-not-provided","title":"4.2 Explicitly Not Provided","text":"<p>MVCC does not provide:</p> <ul> <li>Read Uncommitted</li> <li>Read Committed</li> <li>Serializable isolation (yet)</li> <li>Time-travel queries (unless explicitly added later)</li> </ul> <p>If an isolation level is not specified, it does not exist.</p>"},{"location":"MVCC_VISIBILITY_RULES/#5-visibility-across-operations","title":"5. Visibility Across Operations","text":""},{"location":"MVCC_VISIBILITY_RULES/#51-point-reads","title":"5.1 Point Reads","text":"<ul> <li>Visibility is determined exactly once</li> <li>Subsequent reads of the same key return the same version</li> <li>Repeated reads are stable</li> </ul>"},{"location":"MVCC_VISIBILITY_RULES/#52-range-queries","title":"5.2 Range Queries","text":"<ul> <li>Range queries use one read view</li> <li>All keys in the range are evaluated against the same visibility boundary</li> <li>No key may reflect a later commit than another</li> </ul>"},{"location":"MVCC_VISIBILITY_RULES/#53-index-interaction-conceptual","title":"5.3 Index Interaction (Conceptual)","text":"<p>Indexes:</p> <ul> <li>Must respect read view visibility</li> <li>Must not surface versions invisible to the read view</li> <li>Are conceptually filtered by visibility</li> </ul> <p>Index correctness is subordinate to visibility correctness.</p>"},{"location":"MVCC_VISIBILITY_RULES/#6-write-visibility","title":"6. Write Visibility","text":""},{"location":"MVCC_VISIBILITY_RULES/#61-uncommitted-writes","title":"6.1 Uncommitted Writes","text":"<ul> <li>Uncommitted versions are never visible</li> <li>Not to the writer</li> <li>Not to other readers</li> <li>Not across crashes</li> </ul> <p>There is no concept of \u201cread your own uncommitted write.\u201d</p>"},{"location":"MVCC_VISIBILITY_RULES/#62-committed-writes","title":"6.2 Committed Writes","text":"<ul> <li>All versions from a committed write set become visible atomically</li> <li>Visibility begins strictly after commit identity assignment</li> <li>Partial visibility is forbidden</li> </ul>"},{"location":"MVCC_VISIBILITY_RULES/#7-cross-transaction-observations","title":"7. Cross-Transaction Observations","text":"<p>Given two read operations <code>R1</code> and <code>R2</code>:</p> <ul> <li>If <code>R1.read_upper_bound == R2.read_upper_bound</code>   \u2192 They must observe identical visibility</li> <li>If <code>R1.read_upper_bound &lt; R2.read_upper_bound</code>   \u2192 <code>R2</code> may see strictly more versions, never fewer</li> </ul> <p>Visibility is monotonic across read views.</p>"},{"location":"MVCC_VISIBILITY_RULES/#8-crash-safety-visibility","title":"8. Crash Safety &amp; Visibility","text":"<p>After a crash and recovery:</p> <ul> <li>All committed versions with commit identities \u2264 replay boundary are visible</li> <li>No version may appear without its commit record</li> <li>Visibility rules are reapplied identically</li> </ul> <p>Crashes do not introduce new visibility states.</p>"},{"location":"MVCC_VISIBILITY_RULES/#9-forbidden-visibility-behaviors","title":"9. Forbidden Visibility Behaviors","text":"<p>MVCC must never allow:</p> <ul> <li>Partial visibility of a transaction</li> <li>Time-based visibility</li> <li>Thread-dependent visibility</li> <li>Heuristic snapshot selection</li> <li>Visibility influenced by index state</li> <li>Visibility differences between equivalent queries</li> </ul> <p>If it cannot be expressed as a visibility rule, it is invalid.</p>"},{"location":"MVCC_VISIBILITY_RULES/#10-visibility-summary","title":"10. Visibility Summary","text":"<p>AeroDB MVCC visibility is:</p> <ul> <li>Deterministic</li> <li>Snapshot-based</li> <li>Commit-identity-driven</li> <li>Crash-safe</li> <li>Explicitly limited</li> </ul> <p>There is exactly one read model.</p>"},{"location":"MVCC_WAL_INTEGRATION/","title":"MVCC_WAL_INTERACTION.md","text":""},{"location":"MVCC_WAL_INTEGRATION/#aerodb-mvcc-and-wal-interaction","title":"AeroDB \u2014 MVCC and WAL Interaction","text":""},{"location":"MVCC_WAL_INTEGRATION/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It defines how MVCC state is made durable and recoverable</li> <li>WAL is the sole source of truth</li> <li>No implementation-level encoding is specified</li> </ul>"},{"location":"MVCC_WAL_INTEGRATION/#1-role-of-the-wal-in-mvcc","title":"1. Role of the WAL in MVCC","text":"<p>In AeroDB, the Write-Ahead Log (WAL) is:</p> <ul> <li>The only authority on committed state</li> <li>The source of deterministic ordering</li> <li>The mechanism by which MVCC survives crashes</li> </ul> <p>All MVCC-relevant state must be represented in the WAL.</p>"},{"location":"MVCC_WAL_INTEGRATION/#2-commit-identity-assignment","title":"2. Commit Identity Assignment","text":""},{"location":"MVCC_WAL_INTEGRATION/#21-deterministic-assignment","title":"2.1 Deterministic Assignment","text":"<ul> <li>Commit identities are assigned exactly once</li> <li>Assignment occurs as part of commit</li> <li> <p>The ordering of commit identities is:</p> </li> <li> <p>Total</p> </li> <li>Strict</li> <li>Replayable</li> </ul> <p>No commit identity exists outside the WAL.</p>"},{"location":"MVCC_WAL_INTEGRATION/#22-monotonicity","title":"2.2 Monotonicity","text":"<ul> <li>Commit identities are strictly increasing</li> <li>Gaps are allowed only if explicitly represented</li> <li>Ordering must be reconstructible solely from WAL order</li> </ul> <p>Commit identity order is derived, not inferred.</p>"},{"location":"MVCC_WAL_INTEGRATION/#3-wal-records-and-mvcc-state","title":"3. WAL Records and MVCC State","text":""},{"location":"MVCC_WAL_INTEGRATION/#31-required-mvcc-wal-semantics","title":"3.1 Required MVCC WAL Semantics","text":"<p>The WAL must record, in an unambiguous sequence:</p> <ol> <li>Intent to commit a write set</li> <li>The versions created by that write set</li> <li>The commit identity assignment</li> </ol> <p>Recovery must be able to reconstruct:</p> <ul> <li>Exact version chains</li> <li>Exact commit ordering</li> <li>Visibility boundaries</li> </ul>"},{"location":"MVCC_WAL_INTEGRATION/#32-atomic-visibility-guarantee","title":"3.2 Atomic Visibility Guarantee","text":"<ul> <li>Visibility is tied to commit identity durability</li> <li>A version becomes visible only after its commit identity is durable</li> <li>WAL fsync is the visibility barrier</li> </ul> <p>If a commit identity is not durable, the commit does not exist.</p>"},{"location":"MVCC_WAL_INTEGRATION/#4-crash-scenarios","title":"4. Crash Scenarios","text":""},{"location":"MVCC_WAL_INTEGRATION/#41-crash-before-commit-record","title":"4.1 Crash Before Commit Record","text":"<p>If a crash occurs:</p> <ul> <li> <p>Before commit identity is persisted:</p> </li> <li> <p>No versions are visible</p> </li> <li>No partial MVCC state survives</li> <li>Recovery discards any incomplete version data</li> </ul>"},{"location":"MVCC_WAL_INTEGRATION/#42-crash-after-commit-record","title":"4.2 Crash After Commit Record","text":"<p>If a crash occurs:</p> <ul> <li> <p>After commit identity persistence:</p> </li> <li> <p>All versions associated with that commit are visible</p> </li> <li>Recovery must reconstruct full version chains</li> </ul> <p>There is no intermediate state.</p>"},{"location":"MVCC_WAL_INTEGRATION/#5-interaction-with-checkpointing","title":"5. Interaction with Checkpointing","text":"<ul> <li>Checkpoints represent a stable MVCC cut</li> <li>All versions visible at checkpoint time must be included</li> <li>Commit identities beyond the checkpoint boundary are excluded</li> </ul> <p>Checkpointing does not alter MVCC semantics.</p>"},{"location":"MVCC_WAL_INTEGRATION/#6-interaction-with-snapshots","title":"6. Interaction with Snapshots","text":"<ul> <li> <p>Snapshots capture:</p> </li> <li> <p>Version data</p> </li> <li>MVCC metadata</li> <li>Commit identity boundary</li> <li> <p>Snapshots must be sufficient to:</p> </li> <li> <p>Serve read views</p> </li> <li>Resume WAL replay</li> </ul> <p>Snapshots are self-contained MVCC states.</p>"},{"location":"MVCC_WAL_INTEGRATION/#7-wal-replay-rules","title":"7. WAL Replay Rules","text":"<p>During recovery:</p> <ol> <li>WAL is replayed in strict order</li> <li>Commit identities are re-established deterministically</li> <li>Version chains are reconstructed</li> <li>Visibility rules are reapplied</li> </ol> <p>Recovery does not:</p> <ul> <li>Reassign commit identities</li> <li>Infer missing data</li> <li>Skip MVCC records</li> </ul>"},{"location":"MVCC_WAL_INTEGRATION/#8-garbage-collection-interaction","title":"8. Garbage Collection Interaction","text":"<ul> <li>GC decisions must be WAL-represented</li> <li>Version removal must be replayable</li> <li> <p>GC must never:</p> </li> <li> <p>Remove versions needed for recovery</p> </li> <li>Alter commit identity ordering</li> </ul> <p>GC is subordinate to WAL correctness.</p>"},{"location":"MVCC_WAL_INTEGRATION/#9-explicitly-forbidden-wal-behaviors","title":"9. Explicitly Forbidden WAL Behaviors","text":"<p>The WAL must never:</p> <ul> <li>Contain ambiguous commit boundaries</li> <li>Implicitly encode MVCC state</li> <li>Allow out-of-order visibility</li> <li>Allow visibility without durability</li> </ul> <p>If MVCC state is not in the WAL, it does not exist.</p>"},{"location":"MVCC_WAL_INTEGRATION/#10-summary","title":"10. Summary","text":"<p>MVCC relies on WAL to provide:</p> <ul> <li>Deterministic commit ordering</li> <li>Crash-safe visibility</li> <li>Recoverable version history</li> </ul> <p>The WAL remains the single source of truth.</p>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/","title":"Phase 11: File Storage Access Model","text":"<p>Document Type: Access Control Specification Phase: 11 - File Storage Status: Active</p>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#access-control-philosophy","title":"Access Control Philosophy","text":"<p>File storage uses bucket-level policies + RLS context integration to control access. This provides a simpler model than per-file ACLs while maintaining security.</p>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#bucket-policies","title":"Bucket Policies","text":""},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#policy-types","title":"Policy Types","text":""},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#1-public","title":"1. Public","text":"<p>Rule: Anyone can read, only owner can write/delete</p> <p>Use Cases: - Public documentation - Marketing assets - Open-source project files - Blog images</p> <p>Example: <pre><code>Bucket {\n    name: \"public_docs\",\n    policy: BucketPolicy::Public,\n    ...\n}\n</code></pre></p> <p>Access Matrix:</p> Operation Anonymous Authenticated Owner Service Role Read \u2705 \u2705 \u2705 \u2705 Write \u274c \u274c \u2705 \u2705 Delete \u274c \u274c \u2705 \u2705"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#2-private","title":"2. Private","text":"<p>Rule: Only owner can read/write/delete</p> <p>Use Cases: - User-uploaded files - Private documents - Personal photos - Sensitive data</p> <p>Example: <pre><code>Bucket {\n    name: \"user_uploads\",\n    policy: BucketPolicy::Private,\n    ...\n}\n</code></pre></p> <p>Access Matrix:</p> Operation Anonymous Authenticated Owner Service Role Read \u274c \u274c \u2705 \u2705 Write \u274c \u274c \u2705 \u2705 Delete \u274c \u274c \u2705 \u2705"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#3-authenticated","title":"3. Authenticated","text":"<p>Rule: Any authenticated user can read/write, owner can delete</p> <p>Use Cases: - Shared team folders - Collaborative workspaces - Internal company resources</p> <p>Example: <pre><code>Bucket {\n    name: \"team_shared\",\n    policy: BucketPolicy::Authenticated,\n    ...\n}\n</code></pre></p> <p>Access Matrix:</p> Operation Anonymous Authenticated Owner Service Role Read \u274c \u2705 \u2705 \u2705 Write \u274c \u2705 \u2705 \u2705 Delete \u274c \u274c \u2705 \u2705"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#rls-context-integration","title":"RLS Context Integration","text":"<p>Every file operation requires an RLS context (from Phase 8 auth):</p> <pre><code>pub struct RlsContext {\n    pub user_id: Option&lt;Uuid&gt;,\n    pub is_authenticated: bool,\n    pub can_bypass_rls: bool,  // Service role\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#permission-check-flow","title":"Permission Check Flow","text":"<pre><code>pub fn check_read(&amp;self, bucket: &amp;Bucket, context: &amp;RlsContext) -&gt; Result&lt;()&gt; {\n    // Service role bypasses all checks\n    if context.can_bypass_rls {\n        return Ok(());\n    }\n\n    match bucket.policy {\n        BucketPolicy::Public =&gt; {\n            // Anyone can read\n            Ok(())\n        }\n        BucketPolicy::Authenticated =&gt; {\n            if context.is_authenticated {\n                Ok(())\n            } else {\n                Err(StorageError::Unauthorized)\n            }\n        }\n        BucketPolicy::Private =&gt; {\n            // Must be owner\n            if let Some(owner_id) = &amp;bucket.owner_id {\n                if Some(owner_id) == context.user_id.as_ref() {\n                    Ok(())\n                } else {\n                    Err(StorageError::Unauthorized)\n                }\n            } else {\n                // System bucket, only service role\n                Err(StorageError::Unauthorized)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#signed-urls","title":"Signed URLs","text":""},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#purpose","title":"Purpose","text":"<p>Provide temporary, pre-authenticated access without requiring a session.</p>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#use-cases","title":"Use Cases","text":"<ol> <li>Direct browser upload (bypass API server)</li> <li>Share files with unauthenticated users</li> <li>Embed images in emails (public link)</li> <li>Third-party integrations (temporary access)</li> </ol>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#generation","title":"Generation","text":"<p>Request: <pre><code>POST /storage/v1/object/sign/avatars/user123.jpg?expires_in=3600\nAuthorization: Bearer &lt;JWT&gt;\n</code></pre></p> <p>Response: <pre><code>{\n  \"url\": \"https://api.aerodb.io/storage/v1/object/avatars/user123.jpg?token=eyJhbGc...&amp;expires=1675123456\",\n  \"expires_at\": \"2026-02-06T10:00:00Z\"\n}\n</code></pre></p>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#signature-algorithm","title":"Signature Algorithm","text":"<pre><code>pub fn generate_signed_url(\n    bucket: &amp;str,\n    path: &amp;str,\n    expires_at: DateTime&lt;Utc&gt;,\n    secret: &amp;str,\n) -&gt; String {\n    // Message: bucket + path + expiration timestamp\n    let message = format!(\"{}/{}/{}\", bucket, path, expires_at.timestamp());\n\n    // HMAC-SHA256 signature\n    let mut hasher = Sha256::new();\n    hasher.update(secret);\n    hasher.update(message.as_bytes());\n    let signature = format!(\"{:x}\", hasher.finalize());\n\n    // URL with signature\n    format!(\n        \"/{}/{}?token={}&amp;expires={}\",\n        bucket, path, signature, expires_at.timestamp()\n    )\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#verification","title":"Verification","text":"<pre><code>pub fn verify_signed_url(\n    url: &amp;str,\n    secret: &amp;str,\n) -&gt; Result&lt;()&gt; {\n    let params = parse_query_params(url)?;\n    let token = params.get(\"token\")?;\n    let expires = params.get(\"expires\")?.parse::&lt;i64&gt;()?;\n\n    // Check expiration\n    let expires_at = DateTime::from_timestamp(expires, 0)?;\n    if Utc::now() &gt; expires_at {\n        return Err(StorageError::UrlExpired);\n    }\n\n    // Verify signature\n    let expected = generate_signature(bucket, path, expires_at, secret);\n\n    // Constant-time comparison (prevent timing attacks)\n    if constant_time_eq(token, &amp;expected) {\n        Ok(())\n    } else {\n        Err(StorageError::InvalidSignature)\n    }\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#security-properties","title":"Security Properties","text":"Property Implementation Time-limited Expires at timestamp checked on every access Tamper-proof HMAC signature prevents modification Single-path Signature tied to specific bucket + path Revocable Secret rotation invalidates all URLs (future) No replay (future) Nonce or single-use tokens"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#service-role-bypass","title":"Service Role Bypass","text":"<p>Service role is a special administrative role that bypasses all RLS checks.</p>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#when-to-use","title":"When to Use","text":"<ul> <li>Background jobs (orphan cleanup, migrations)</li> <li>Admin operations (bulk delete, audit)</li> <li>System-level access (backups, replication)</li> </ul>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#how-to-bypass","title":"How to Bypass","text":"<pre><code>let service_context = RlsContext {\n    user_id: None,\n    is_authenticated: true,\n    can_bypass_rls: true,  // \u2b05\ufe0f Service role flag\n};\n\nstorage.upload(\"private_bucket\", \"file.txt\", data, &amp;service_context)?;\n// Succeeds even if service_context.user_id != bucket.owner_id\n</code></pre>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#security","title":"Security","text":"<ul> <li>JWT must have <code>role=service</code> claim</li> <li>Only issued to trusted backend services</li> <li>Never exposed to clients</li> <li>Logged explicitly for audit</li> </ul>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#access-control-examples","title":"Access Control Examples","text":""},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#example-1-public-read-owner-write","title":"Example 1: Public Read, Owner Write","text":"<p>Scenario: Blog images</p> <pre><code>Bucket {\n    name: \"blog_images\",\n    policy: BucketPolicy::Public,\n    owner_id: Some(admin_user_id),\n}\n</code></pre> <p>Behavior: - Anonymous users: Can download - Authenticated users: Can download - Admin user: Can upload, download, delete - Other users: Can download only</p>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#example-2-authenticated-collaboration","title":"Example 2: Authenticated Collaboration","text":"<p>Scenario: Team document folder</p> <pre><code>Bucket {\n    name: \"team_docs\",\n    policy: BucketPolicy::Authenticated,\n    owner_id: Some(team_lead_id),\n}\n</code></pre> <p>Behavior: - Anonymous users: Blocked - Any authenticated user: Can upload, download - Team lead: Can upload, download, delete - Other team members: Can upload, download (not delete)</p>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#example-3-private-user-uploads","title":"Example 3: Private User Uploads","text":"<p>Scenario: User avatars</p> <pre><code>Bucket {\n    name: \"user_avatars\",\n    policy: BucketPolicy::Private,\n    owner_id: None,  // Per-file ownership\n}\n</code></pre> <p>Per-File Ownership: <pre><code>Object {\n    id: \"...\",\n    bucket_id: \"user_avatars\",\n    path: \"user123.jpg\",\n    owner_id: Some(user123_id),  // \u2b05\ufe0f File owner\n}\n</code></pre></p> <p>Behavior: - User 123: Can upload, download, delete <code>user123.jpg</code> - User 456: Blocked from <code>user123.jpg</code> - Service role: Full access to all</p>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#example-4-temporary-guest-access","title":"Example 4: Temporary Guest Access","text":"<p>Scenario: Share photo with friend (no account)</p> <pre><code>// 1. Owner generates signed URL (valid 24 hours)\nlet url = storage.generate_signed_url(\n    \"user_avatars\",\n    \"user123.jpg\",\n    Utc::now() + Duration::hours(24),\n)?;\n\n// 2. Send URL to friend\nsend_email(friend_email, url);\n\n// 3. Friend accesses without login\nGET https://api.aerodb.io/storage/v1/object/user_avatars/user123.jpg?token=...&amp;expires=...\n\u2192 200 OK (signature valid, not expired)\n</code></pre>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#permission-denial-responses","title":"Permission Denial Responses","text":""},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#403-forbidden-rls-denial","title":"403 Forbidden (RLS Denial)","text":"<pre><code>HTTP/1.1 403 Forbidden\nContent-Type: application/json\n\n{\n  \"error\": \"403 Forbidden\",\n  \"message\": \"Access denied: bucket policy does not allow this operation\",\n  \"code\": \"STORAGE_UNAUTHORIZED\"\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#401-unauthorized-no-auth","title":"401 Unauthorized (No Auth)","text":"<pre><code>HTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer\n\n{\n  \"error\": \"401 Unauthorized\",\n  \"message\": \"Authentication required\",\n  \"code\": \"AUTH_REQUIRED\"\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#410-gone-expired-signed-url","title":"410 Gone (Expired Signed URL)","text":"<pre><code>HTTP/1.1 410 Gone\nContent-Type: application/json\n\n{\n  \"error\": \"410 Gone\",\n  \"message\": \"Signed URL expired at 2026-02-06T09:00:00Z\",\n  \"code\": \"URL_EXPIRED\"\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#future-enhancements","title":"Future Enhancements","text":""},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#per-file-acls","title":"Per-File ACLs","text":"<p>Allow fine-grained access control per file (not just bucket-level):</p> <pre><code>Object {\n    acl: vec![\n        AccessRule { user_id: \"user456\", permission: \"read\" },\n        AccessRule { group_id: \"team_a\", permission: \"write\" },\n    ],\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#signed-url-single-use","title":"Signed URL Single-Use","text":"<p>Prevent replay attacks with nonce:</p> <pre><code>SignedUrl {\n    token: \"...\",\n    nonce: \"one-time-uuid\",\n    expires_at: \"...\",\n}\n</code></pre> <p>On first use, mark nonce as consumed.</p>"},{"location":"OBJECT_STORAGE_ACCESS_MODEL/#secret-rotation","title":"Secret Rotation","text":"<p>Rotate HMAC secret to invalidate old signed URLs:</p> <pre><code>Config {\n    current_secret: \"new-secret\",\n    previous_secret: Some(\"old-secret\"),  // Grace period\n}\n</code></pre> <p>Verify with both secrets, generate with current only.</p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/","title":"Phase 11: File Storage Architecture","text":"<p>Document Type: Technical Architecture Phase: 11 - File Storage Status: Active</p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#system-overview","title":"System Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Client Applications                       \u2502\n\u2502                   (REST API, SDKs, Admin UI)                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                  \u2502    REST API Layer   \u2502\n                  \u2502  (Phase 9)          \u2502\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                    \u2502                    \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Auth/RLS     \u2502  \u2502  File Storage   \u2502  \u2502   Database     \u2502\n\u2502   (Phase 8)    \u2502  \u2502    Service      \u2502  \u2502   (Executor)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502                   \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502   Storage    \u2502   \u2502    Metadata     \u2502\n            \u2502   Backend    \u2502   \u2502   Collections   \u2502\n            \u2502(FS, S3, etc) \u2502   \u2502 (storage_*)     \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#component-architecture","title":"Component Architecture","text":""},{"location":"OBJECT_STORAGE_ARCHITECTURE/#1-file-storage-service","title":"1. File Storage Service","text":"<p>Location: <code>src/file_storage/</code></p> <p>Responsibilities: - Coordinate file operations (upload, download, delete) - Enforce bucket policies and RLS - Validate MIME types and size limits - Generate/verify signed URLs - Ensure metadata-file consistency</p> <p>Does NOT: - Store metadata directly (uses Database Executor) - Manage WebSocket connections - Handle authentication (delegates to Auth module)</p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#2-storage-backend-abstraction","title":"2. Storage Backend Abstraction","text":"<pre><code>pub trait StorageBackend {\n    async fn write(&amp;self, path: &amp;str, data: &amp;[u8]) -&gt; Result&lt;()&gt;;\n    async fn read(&amp;self, path: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;\n    async fn delete(&amp;self, path: &amp;str) -&gt; Result&lt;()&gt;;\n    async fn exists(&amp;self, path: &amp;str) -&gt; Result&lt;bool&gt;;\n    async fn size(&amp;self, path: &amp;str) -&gt; Result&lt;u64&gt;;\n}\n</code></pre> <p>Implementations:</p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#local-filesystem-srcfile_storagelocalrs","title":"Local Filesystem (<code>src/file_storage/local.rs</code>)","text":"<pre><code>pub struct LocalBackend {\n    root_dir: PathBuf,  // e.g., /var/lib/aerodb/storage\n}\n</code></pre> <p>Path Mapping: <pre><code>Bucket ID: 550e8400-e29b-41d4-a716-446655440000\nFile path: users/123/avatar.jpg\nPhysical: /var/lib/aerodb/storage/550e8400.../users/123/avatar.jpg\n</code></pre></p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#s3-compatible-backend-future-srcfile_storages3rs","title":"S3-Compatible Backend (Future: <code>src/file_storage/s3.rs</code>)","text":"<pre><code>pub struct S3Backend {\n    endpoint: String,\n    bucket: String,\n    credentials: Credentials,\n}\n</code></pre> <p>Benefits of Abstraction: - Switch backends without code changes - Test with local, deploy with S3 - Multiple backends per environment</p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#3-metadata-storage","title":"3. Metadata Storage","text":"<p>Collections: <code>storage_buckets</code>, <code>storage_objects</code></p> <p>Integration: <pre><code>// FileStorage does NOT directly access collections\n// Instead, uses Database Executor\npub struct FileStorage {\n    backend: Box&lt;dyn StorageBackend&gt;,\n    executor: Arc&lt;Executor&gt;,  // \u2b05\ufe0f For metadata queries\n    permission_checker: PermissionChecker,\n}\n</code></pre></p> <p>Metadata Operations: <pre><code>// Insert metadata (transactional)\nlet query = Insert::new(\"storage_objects\")\n    .values(metadata_as_document)?;\nexecutor.execute(query, &amp;rls_context)?;\n\n// Query metadata\nlet query = Select::new(\"storage_objects\")\n    .filter(Eq::new(\"bucket_id\", bucket_id))?;\nlet results = executor.execute(query, &amp;rls_context)?;\n</code></pre></p> <p>Why Executor Integration: - Metadata participates in MVCC - Replication includes metadata - RLS applied to metadata queries - Transactional consistency</p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#module-structure","title":"Module Structure","text":"<pre><code>src/file_storage/\n\u251c\u2500\u2500 mod.rs              # Module entry, exports\n\u251c\u2500\u2500 errors.rs           # Storage error types\n\u251c\u2500\u2500 bucket.rs           # Bucket management (CRUD)\n\u251c\u2500\u2500 file.rs             # File operations (upload, download, delete)\n\u251c\u2500\u2500 permissions.rs      # RLS enforcement, policy checks\n\u251c\u2500\u2500 backend.rs          # StorageBackend trait\n\u251c\u2500\u2500 local.rs            # Local filesystem implementation\n\u251c\u2500\u2500 s3.rs               # S3-compatible implementation (future)\n\u2514\u2500\u2500 signed_url.rs       # Signed URL generation/verification\n</code></pre>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#data-flow","title":"Data Flow","text":""},{"location":"OBJECT_STORAGE_ARCHITECTURE/#upload-flow","title":"Upload Flow","text":"<pre><code>1. Client \u2192 REST API\n   POST /storage/v1/object/avatars/user123.jpg\n   Headers: Authorization, Content-Type\n   Body: &lt;file bytes&gt;\n\n2. REST API \u2192 Auth Module\n   Extract JWT \u2192 RlsContext\n\n3. REST API \u2192 File Storage Service\n   upload(bucket=\"avatars\", path=\"user123.jpg\", data, context)\n\n4. File Storage Service:\n   a. Load bucket from metadata (via Executor)\n   b. Check permissions (PermissionChecker)\n   c. Validate MIME type (bucket.allowed_mime_types)\n   d. Validate size (bucket.max_file_size)\n   e. Calculate checksum (SHA-256)\n\n5. File Storage Service \u2192 Storage Backend\n   backend.write(physical_path, data)\n\n6. File Storage Service \u2192 Database Executor\n   executor.execute(INSERT INTO storage_objects ...)\n\n7. If step 6 fails:\n   backend.delete(physical_path)  // Cleanup\n\n8. File Storage Service \u2192 REST API\n   Return StorageObject\n\n9. REST API \u2192 Client\n   201 Created {id, bucket, path, size, ...}\n</code></pre> <p>Atomicity Guarantee: - File written to disk - Metadata inserted to DB - If either fails, both rollback</p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#download-flow","title":"Download Flow","text":"<pre><code>1. Client \u2192 REST API\n   GET /storage/v1/object/avatars/user123.jpg\n   Headers: Authorization\n\n2. REST API \u2192 Auth Module\n   Extract JWT \u2192 RlsContext\n\n3. REST API \u2192 File Storage Service\n   download(bucket=\"avatars\", path=\"user123.jpg\", context)\n\n4. File Storage Service \u2192 Database Executor\n   Query metadata: SELECT * FROM storage_objects WHERE ...\n\n5. File Storage Service:\n   a. Check permissions (PermissionChecker.check_read)\n\n6. File Storage Service \u2192 Storage Backend\n   data = backend.read(physical_path)\n\n7. File Storage Service:\n   a. (Optional) Verify checksum\n\n8. File Storage Service \u2192 REST API\n   Return (data, content_type)\n\n9. REST API \u2192 Client\n   200 OK\n   Headers: Content-Type, Content-Length\n   Body: &lt;file bytes&gt;\n</code></pre>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#delete-flow","title":"Delete Flow","text":"<pre><code>1. Client \u2192 REST API\n   DELETE /storage/v1/object/avatars/user123.jpg\n\n2. Auth \u2192 RlsContext\n\n3. File Storage Service:\n   a. Query metadata\n   b. Check permissions (owner only)\n   c. Delete metadata from DB\n   d. Delete file from disk\n\n4. If disk delete fails:\n   - Metadata already removed\n   - Orphan file handled by cleanup job\n\n5. Return 204 No Content\n</code></pre>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#signed-url-flow","title":"Signed URL Flow","text":"<p>Generation: <pre><code>1. Client \u2192 REST API\n   POST /storage/v1/object/sign/avatars/user123.jpg?expires_in=3600\n\n2. Auth \u2192 RlsContext (must be authenticated)\n\n3. File Storage Service:\n   a. Check user can access file\n   b. Generate HMAC signature\n   c. Create URL with token + expiration\n\n4. Return signed URL to client\n</code></pre></p> <p>Usage: <pre><code>1. Client (unauthenticated) \u2192 REST API\n   GET /storage/v1/object/avatars/user123.jpg?token=...&amp;expires=...\n\n2. File Storage Service:\n   a. Extract token, expires from query params\n   b. Verify expiration (now &lt; expires)\n   c. Verify signature (constant-time comparison)\n   d. If valid, serve file (bypass RLS)\n\n3. Return file bytes\n</code></pre></p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#integration-points","title":"Integration Points","text":""},{"location":"OBJECT_STORAGE_ARCHITECTURE/#with-authentication-phase-8","title":"With Authentication (Phase 8)","text":"<pre><code>// Every storage operation requires RLS context\nlet context = extract_rls_context(&amp;request)?;\n\n// Service role bypass\nif context.can_bypass_rls {\n    // Skip permission checks (admin operations)\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#with-rest-api-phase-9","title":"With REST API (Phase 9)","text":"<p>Endpoints Added: <pre><code>POST   /storage/v1/bucket\nGET    /storage/v1/bucket\nDELETE /storage/v1/bucket/{name}\n\nPOST   /storage/v1/object/{bucket}/{path}\nGET    /storage/v1/object/{bucket}/{path}\nDELETE /storage/v1/object/{bucket}/{path}\n\nPOST   /storage/v1/object/sign/{bucket}/{path}\n</code></pre></p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#with-real-time-phase-10","title":"With Real-Time (Phase 10)","text":"<p>Events Emitted: <pre><code>// After successful upload\nemit_event(Event::StorageObjectCreated {\n    bucket_id,\n    path,\n    owner_id,\n    timestamp: Utc::now(),\n});\n\n// Clients can subscribe\nsubscription.filter(\"storage.object.created\", {bucket: \"avatars\"})\n</code></pre></p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#with-executor-core","title":"With Executor (Core)","text":"<p>Metadata Queries: <pre><code>// All metadata operations go through Executor\nlet query = Select::new(\"storage_objects\")\n    .filter(Eq::new(\"bucket_id\", bucket_id))?;\n\nlet results = executor.execute(query, &amp;rls_context)?;\n</code></pre></p> <p>Why Not Direct Collection Access: - RLS enforcement - MVCC visibility - Transaction support - Replication</p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#orphan-cleanup-job","title":"Orphan Cleanup Job","text":"<p>Architecture: <pre><code>pub struct OrphanCleanupJob {\n    backend: Arc&lt;dyn StorageBackend&gt;,\n    executor: Arc&lt;Executor&gt;,\n    interval: Duration,  // Default: 1 hour\n}\n\nimpl OrphanCleanupJob {\n    pub async fn run(&amp;self) {\n        loop {\n            sleep(self.interval).await;\n\n            // Find orphan files (file exists, no metadata)\n            let orphan_files = self.find_orphan_files().await?;\n            for file in orphan_files {\n                self.backend.delete(&amp;file)?;\n                log::warn!(\"Cleaned orphan file: {}\", file);\n            }\n\n            // Find orphan metadata (metadata exists, no file)\n            let orphan_metadata = self.find_orphan_metadata().await?;\n            for metadata_id in orphan_metadata {\n                self.executor.execute(\n                    Delete::new(\"storage_objects\")\n                        .filter(Eq::new(\"id\", metadata_id))\n                )?;\n                log::warn!(\"Cleaned orphan metadata: {}\", metadata_id);\n            }\n        }\n    }\n}\n</code></pre></p> <p>Scheduling: Background thread, started with AeroDB instance</p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#error-handling","title":"Error Handling","text":"<p>Error Propagation: <pre><code>pub async fn upload(\n    bucket: &amp;str,\n    path: &amp;str,\n    data: Vec&lt;u8&gt;,\n    context: &amp;RlsContext,\n) -&gt; Result&lt;StorageObject, StorageError&gt; {\n    // Each operation can fail with specific error\n    let bucket_meta = self.load_bucket(bucket)?;            // NotFound\n    self.check_permissions(&amp;bucket_meta, context)?;         // Unauthorized\n    self.validate_mime(&amp;bucket_meta, &amp;content_type)?;       // UnsupportedMediaType\n    self.validate_size(&amp;bucket_meta, data.len())?;          // PayloadTooLarge\n\n    let physical_path = self.backend.write(path, &amp;data)?;   // IoError\n\n    match self.insert_metadata(path, ...) {\n        Ok(obj) =&gt; Ok(obj),\n        Err(e) =&gt; {\n            self.backend.delete(&amp;physical_path)?;           // Cleanup\n            Err(e)\n        }\n    }\n}\n</code></pre></p> <p>HTTP Mapping: <pre><code>impl From&lt;StorageError&gt; for HttpStatus {\n    fn from(err: StorageError) -&gt; HttpStatus {\n        match err {\n            StorageError::NotFound =&gt; 404,\n            StorageError::Unauthorized =&gt; 403,\n            StorageError::UnsupportedMediaType =&gt; 415,\n            StorageError::PayloadTooLarge =&gt; 413,\n            StorageError::IoError(_) =&gt; 500,\n            ...\n        }\n    }\n}\n</code></pre></p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#performance-considerations","title":"Performance Considerations","text":""},{"location":"OBJECT_STORAGE_ARCHITECTURE/#streaming-future","title":"Streaming (Future)","text":"<p>Current: Load entire file into memory <pre><code>let data = backend.read(path)?;  // Loads all bytes\n</code></pre></p> <p>Future: Stream for large files <pre><code>let stream = backend.read_stream(path)?;\nwhile let Some(chunk) = stream.next().await {\n    // Send chunk to client\n}\n</code></pre></p>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#caching-future","title":"Caching (Future)","text":"<ul> <li>Metadata cache (reduce DB queries)</li> <li>File content cache (CDN integration)</li> <li>Checksum cache (avoid recalculation)</li> </ul>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#concurrency","title":"Concurrency","text":"<ul> <li>File operations are NOT serialized</li> <li>Concurrent uploads to different files: OK</li> <li>Concurrent uploads to same file: Last write wins (current), versioning (future)</li> </ul>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#security-architecture","title":"Security Architecture","text":""},{"location":"OBJECT_STORAGE_ARCHITECTURE/#defense-in-depth","title":"Defense in Depth","text":"<ol> <li>Authentication: JWT validation (Phase 8)</li> <li>Authorization: Bucket policy + RLS enforcement</li> <li>Validation: MIME type, size limits (fail fast)</li> <li>Isolation: Physical paths use bucket ID (prevent path traversal)</li> <li>Signed URLs: Time-limited, HMAC-signed</li> <li>Audit: All operations logged with user context</li> </ol>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#threat-mitigation","title":"Threat Mitigation","text":"Threat Mitigation Path traversal Validate path (no <code>..</code>), use bucket ID in physical path Unauthorized access RLS enforcement on every operation Large file DoS Size limits enforced before write Malicious MIME types MIME type validation (future: antivirus scan) Signed URL abuse Expiration + signature verification"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#observability","title":"Observability","text":""},{"location":"OBJECT_STORAGE_ARCHITECTURE/#metrics","title":"Metrics","text":"<pre><code>storage_upload_total{bucket, status}\nstorage_download_total{bucket, status}\nstorage_upload_bytes_total{bucket}\nstorage_download_bytes_total{bucket}\nstorage_orphan_files_total\nstorage_backend_latency_seconds{operation, backend}\n</code></pre>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#logs","title":"Logs","text":"<pre><code>{\n  \"level\": \"INFO\",\n  \"service\": \"file_storage\",\n  \"operation\": \"upload\",\n  \"bucket\": \"avatars\",\n  \"path\": \"user123.jpg\",\n  \"size\": 12345,\n  \"user_id\": \"uuid\",\n  \"duration_ms\": 45\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_ARCHITECTURE/#alerts","title":"Alerts","text":"<ul> <li>Orphan count &gt; 1000</li> <li>Upload error rate &gt; 5%</li> <li>Backend latency &gt; 1s (p99)</li> </ul>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/","title":"Phase 11: Bucket Model","text":"<p>Document Type: Data Model Specification Phase: 11 - File Storage Status: Active</p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#overview","title":"Overview","text":"<p>Buckets are top-level containers for files. They define: - Access policy (public/private/authenticated) - MIME type restrictions (e.g., only images) - Size limits (e.g., max 5MB per file) - Ownership (who can manage the bucket)</p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#bucket-structure","title":"Bucket Structure","text":"<pre><code>pub struct Bucket {\n    pub id: Uuid,\n    pub name: String,\n    pub owner_id: Option&lt;Uuid&gt;,\n    pub policy: BucketPolicy,\n    pub config: BucketConfig,\n    pub created_at: DateTime&lt;UTC&gt;,\n    pub updated_at: DateTime&lt;Utc&gt;,\n}\n\npub enum BucketPolicy {\n    Public,        // Anyone read,owner write\n    Private,       // Owner only\n    Authenticated, // Any authed user\n}\n\npub struct BucketConfig {\n    pub allowed_mime_types: Vec&lt;String&gt;,  // Empty = allow all\n    pub max_file_size: u64,                // Bytes, 0 = unlimited\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#field-specifications","title":"Field Specifications","text":""},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#id","title":"id","text":"<ul> <li>Type: UUID v4</li> <li>Purpose: Primary key, immutable</li> <li>Generation: Server-side on creation</li> </ul>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#name","title":"name","text":"<ul> <li>Type: String</li> <li>Constraints:</li> <li>Unique across all buckets</li> <li>3-63 characters</li> <li>Lowercase alphanumeric + hyphens</li> <li>Cannot start/end with hyphen</li> <li>Regex: <code>^[a-z0-9][a-z0-9-]*[a-z0-9]$</code></li> </ul> <p>Valid Names: <pre><code>\u2705 avatars\n\u2705 user-uploads\n\u2705 public-docs-2026\n\u274c Avatars  (uppercase)\n\u274c av      (too short)\n\u274c -avatars (starts with hyphen)\n\u274c user_uploads (underscore)\n</code></pre></p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#owner_id","title":"owner_id","text":"<ul> <li>Type: UUID (nullable)</li> <li>Purpose: Who can manage this bucket</li> <li>Null Semantics:</li> <li><code>NULL</code> = system bucket (no single owner)</li> <li><code>Some(user_id)</code> = user-owned bucket</li> </ul>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#policy","title":"policy","text":"<ul> <li>Type: Enum (Public, Private, Authenticated)</li> <li>Default: Private (secure by default)</li> <li>Immutable: No (can be changed, but dangerous)</li> </ul>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#allowed_mime_types","title":"allowed_mime_types","text":"<ul> <li>Type: String array</li> <li>Default: <code>[]</code> (empty = allow all)</li> <li>Format: MIME type patterns</li> <li>Exact: <code>image/jpeg</code></li> <li>Wildcard: <code>image/*</code></li> <li>Multiple: <code>[\"image/jpeg\", \"image/png\", \"image/webp\"]</code></li> </ul> <p>Examples: <pre><code>// Only JPEG/PNG images\nallowed_mime_types: vec![\"image/jpeg\", \"image/png\"]\n\n// Any image\nallowed_mime_types: vec![\"image/*\"]\n\n// PDFs and Word docs\nallowed_mime_types: vec![\"application/pdf\", \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"]\n\n// Allow all\nallowed_mime_types: vec![]\n</code></pre></p> <p>Enforcement: Upload request with <code>Content-Type: video/mp4</code> to bucket allowing only <code>image/*</code>: <pre><code>\u2192 415 Unsupported Media Type\n</code></pre></p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#max_file_size","title":"max_file_size","text":"<ul> <li>Type: u64 (bytes)</li> <li>Default: 0 (unlimited, but global limit still applies)</li> <li>Purpose: Prevent accidentally large uploads</li> </ul> <p>Examples: <pre><code>max_file_size: 5_242_880       // 5 MB\nmax_file_size: 104_857_600     // 100 MB\nmax_file_size: 0               // Unlimited (use global limit)\n</code></pre></p> <p>Enforcement: Upload 10MB file to bucket with 5MB limit: <pre><code>\u2192 413 Payload Too Large\n</code></pre></p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#bucket-operations","title":"Bucket Operations","text":""},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#create-bucket","title":"Create Bucket","text":"<p>Request: <pre><code>POST /storage/v1/bucket\nAuthorization: Bearer &lt;JWT&gt;\nContent-Type: application/json\n\n{\n  \"name\": \"avatars\",\n  \"policy\": \"private\",\n  \"allowed_mime_types\": [\"image/jpeg\", \"image/png\"],\n  \"max_file_size\": 5242880\n}\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 201 Created\nContent-Type: application/json\n\n{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"name\": \"avatars\",\n  \"owner_id\": \"789e0123-e45b-67d8-9012-345678901234\",\n  \"policy\": \"private\",\n  \"config\": {\n    \"allowed_mime_types\": [\"image/jpeg\", \"image/png\"],\n    \"max_file_size\": 5242880\n  },\n  \"created_at\": \"2026-02-06T09:00:00Z\",\n  \"updated_at\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p> <p>Errors: - <code>409 Conflict</code> - Bucket name already exists - <code>400 Bad Request</code> - Invalid name format - <code>401 Unauthorized</code> - No authentication</p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#list-buckets","title":"List Buckets","text":"<p>Request: <pre><code>GET /storage/v1/bucket\nAuthorization: Bearer &lt;JWT&gt;\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  {\n    \"id\": \"550e8400-...\",\n    \"name\": \"avatars\",\n    \"policy\": \"private\",\n    \"file_count\": 42,\n    \"total_size\": 1234567\n  },\n  {\n    \"id\": \"660f9500-...\",\n    \"name\": \"public-docs\",\n    \"policy\": \"public\",\n    \"file_count\": 128,\n    \"total_size\": 9876543\n  }\n]\n</code></pre></p> <p>Filtering: - Owner's buckets: Filter by <code>owner_id = current_user_id()</code> - Public buckets: Filter by <code>policy = 'public'</code> - Service role: See all buckets</p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#get-bucket","title":"Get Bucket","text":"<p>Request: <pre><code>GET /storage/v1/bucket/avatars\nAuthorization: Bearer &lt;JWT&gt;\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"id\": \"550e8400-...\",\n  \"name\": \"avatars\",\n  \"owner_id\": \"789e0123-...\",\n  \"policy\": \"private\",\n  \"config\": {\n    \"allowed_mime_types\": [\"image/jpeg\", \"image/png\"],\n    \"max_file_size\": 5242880\n  },\n  \"file_count\": 42,\n  \"total_size\": 1234567,\n  \"created_at\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#update-bucket","title":"Update Bucket","text":"<p>Request: <pre><code>PATCH /storage/v1/bucket/avatars\nAuthorization: Bearer &lt;JWT&gt;\nContent-Type: application/json\n\n{\n  \"max_file_size\": 10485760  // Increase to 10MB\n}\n</code></pre></p> <p>Response: <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"id\": \"550e8400-...\",\n  \"config\": {\n    \"max_file_size\": 10485760\n  },\n  \"updated_at\": \"2026-02-06T09:15:00Z\"\n}\n</code></pre></p> <p>Authorization: - Must be bucket owner - Service role can update any bucket</p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#delete-bucket","title":"Delete Bucket","text":"<p>Request: <pre><code>DELETE /storage/v1/bucket/avatars\nAuthorization: Bearer &lt;JWT&gt;\n</code></pre></p> <p>Success (Empty Bucket): <pre><code>HTTP/1.1 204 No Content\n</code></pre></p> <p>Error (Non-Empty Bucket): <pre><code>HTTP/1.1 409 Conflict\nContent-Type: application/json\n\n{\n  \"error\": \"409 Conflict\",\n  \"message\": \"Bucket not empty (42 files)\",\n  \"code\": \"BUCKET_NOT_EMPTY\"\n}\n</code></pre></p> <p>Force Delete (Future): <pre><code>DELETE /storage/v1/bucket/avatars?force=true\n\u2192 Deletes bucket AND all files\n</code></pre></p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#validation-rules","title":"Validation Rules","text":""},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#name-validation","title":"Name Validation","text":"<pre><code>pub fn validate_bucket_name(name: &amp;str) -&gt; Result&lt;()&gt; {\n    if name.len() &lt; 3 || name.len() &gt; 63 {\n        return Err(StorageError::InvalidBucketName(\"Length must be 3-63\"));\n    }\n\n    let regex = Regex::new(r\"^[a-z0-9][a-z0-9-]*[a-z0-9]$\").unwrap();\n    if !regex.is_match(name) {\n        return Err(StorageError::InvalidBucketName(\"Invalid characters\"));\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#mime-validation","title":"MIME Validation","text":"<pre><code>pub fn is_mime_allowed(&amp;self, content_type: &amp;str) -&gt; bool {\n    if self.config.allowed_mime_types.is_empty() {\n        return true;  // Allow all\n    }\n\n    for pattern in &amp;self.config.allowed_mime_types {\n        if pattern.ends_with(\"/*\") {\n            // Wildcard: image/* matches image/jpeg\n            let prefix = &amp;pattern[..pattern.len() - 2];\n            if content_type.starts_with(prefix) {\n                return true;\n            }\n        } else {\n            // Exact match\n            if content_type == pattern {\n                return true;\n            }\n        }\n    }\n\n    false\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#size-validation","title":"Size Validation","text":"<pre><code>pub fn is_size_allowed(&amp;self, size: u64) -&gt; bool {\n    if self.config.max_file_size == 0 {\n        return true;  // Unlimited (global limit still applies)\n    }\n\n    size &lt;= self.config.max_file_size\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#bucket-lifecycle","title":"Bucket Lifecycle","text":""},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#creation-flow","title":"Creation Flow","text":"<pre><code>1. Client POST /storage/v1/bucket\n2. Server validates name (unique, format)\n3. Server creates bucket with owner_id = current_user\n4. Server inserts into storage_buckets table\n5. Server returns bucket details\n</code></pre>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#deletion-flow","title":"Deletion Flow","text":"<pre><code>1. Client DELETE /storage/v1/bucket/avatars\n2. Server checks if empty (file_count = 0)\n3. If not empty \u2192 409 Conflict\n4. If empty \u2192 Delete from storage_buckets\n5. Cascade delete metadata (foreign key)\n</code></pre>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#default-buckets","title":"Default Buckets","text":"<p>Some buckets may be created by default:</p> <pre><code>// System bucket for internal use\nBucket {\n    name: \"system\",\n    owner_id: None,\n    policy: BucketPolicy::Private,\n    config: BucketConfig {\n        allowed_mime_types: vec![],\n        max_file_size: 0,\n    },\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#invariants","title":"Invariants","text":""},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#bkt-i1-name-uniqueness","title":"BKT-I1: Name Uniqueness","text":"<p>No two buckets have the same name</p> <p>Enforcement: UNIQUE constraint on <code>name</code> field</p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#bkt-i2-policy-consistency","title":"BKT-I2: Policy Consistency","text":"<p>Bucket policy matches file access behavior</p> <p>Verification: Permission tests for each policy type</p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#bkt-i3-config-validation","title":"BKT-I3: Config Validation","text":"<p>MIME and size limits enforced on upload</p> <p>Enforcement: Pre-upload validation checks</p>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#examples","title":"Examples","text":""},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#image-storage-bucket","title":"Image Storage Bucket","text":"<pre><code>{\n  \"name\": \"user-avatars\",\n  \"policy\": \"private\",\n  \"allowed_mime_types\": [\"image/jpeg\", \"image/png\", \"image/webp\"],\n  \"max_file_size\": 5242880\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#document-archive-public","title":"Document Archive (Public)","text":"<pre><code>{\n  \"name\": \"public-docs\",\n  \"policy\": \"public\",\n  \"allowed_mime_types\": [\"application/pdf\"],\n  \"max_file_size\": 10485760\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_BUCKET_MODEL/#team-workspace","title":"Team Workspace","text":"<pre><code>{\n  \"name\": \"team-shared\",\n  \"policy\": \"authenticated\",\n  \"allowed_mime_types\": [],\n  \"max_file_size\": 104857600\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/","title":"Phase 11: File Storage Failure Model","text":"<p>Document Type: Failure Model Phase: 11 - File Storage Status: Active</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#error-classification","title":"Error Classification","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#client-errors-4xx","title":"Client Errors (4xx)","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#400-bad-request","title":"400 Bad Request","text":"<p>Causes: - Mal formed upload request - Invalid path characters - Missing required headers</p> <p>Example: <pre><code>POST /storage/v1/object/avatars/../etc/passwd\n\u2192 400: Invalid path (contains ..)\n</code></pre></p> <p>Recovery: Client must fix request</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#403-forbidden","title":"403 Forbidden","text":"<p>Causes: - RLS policy denies access - User not bucket owner (private bucket) - Invalid signed URL signature</p> <p>Example: <pre><code>GET /storage/v1/object/private_bucket/file.txt\nAuthorization: Bearer &lt;user_b_token&gt;\n\u2192 403: Access denied (bucket owner is user_a)\n</code></pre></p> <p>Recovery: Authenticate as authorized user or request signed URL</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#404-not-found","title":"404 Not Found","text":"<p>Causes: - Bucket doesn't exist - File doesn't exist - Metadata exists but file missing (orphan)</p> <p>Example: <pre><code>GET /storage/v1/object/nonexistent/file.txt\n\u2192 404: Bucket not found\n</code></pre></p> <p>Recovery: Verify bucket/path or create bucket</p> <p>Special Case - Orphan Metadata: <pre><code>Metadata in DB: \u2713\nFile on disk: \u2717\n\u2192 404 + log warning + trigger cleanup job\n</code></pre></p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#409-conflict","title":"409 Conflict","text":"<p>Causes: - Bucket name already exists - Bucket not empty (on delete)</p> <p>Example: <pre><code>POST /storage/v1/bucket {\"name\": \"avatars\"}\n\u2192 409: Bucket already exists\n</code></pre></p> <p>Recovery: Choose different name or delete existing bucket</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#413-payload-too-large","title":"413 Payload Too Large","text":"<p>Causes: - File exceeds bucket <code>max_file_size</code> - File exceeds global <code>storage.max_file_size</code></p> <p>Example: <pre><code>POST /storage/v1/object/avatars/huge.jpg\nContent-Length: 150000000  (150MB)\nBucket limit: 5MB\n\u2192 413: File too large (150MB, max 5MB)\n</code></pre></p> <p>Timing: Validation BEFORE disk write (fail fast)</p> <p>Recovery: Resize file or request limit increase</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#415-unsupported-media-type","title":"415 Unsupported Media Type","text":"<p>Causes: - MIME type not in bucket's <code>allowed_mime_types</code></p> <p>Example: <pre><code>POST /storage/v1/object/images/doc.pdf\nContent-Type: application/pdf\nBucket allows: image/*\n\u2192 415: Invalid MIME type (application/pdf not allowed)\n</code></pre></p> <p>Timing: Validation BEFORE disk write</p> <p>Recovery: Convert file or upload to different bucket</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#server-errors-5xx","title":"Server Errors (5xx)","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#500-internal-server-error","title":"500 Internal Server Error","text":"<p>Causes: - Database connection failure - Unexpected panic - Checksum mismatch (data corruption)</p> <p>Example: <pre><code>GET /storage/v1/object/docs/file.txt\n(Downloaded file checksum != stored checksum)\n\u2192 500: Checksum mismatch (data corruption detected)\n</code></pre></p> <p>Recovery:  - Retry (transient errors) - Alert ops team (persistent errors) - Re-upload file (corruption)</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#503-service-unavailable","title":"503 Service Unavailable","text":"<p>Causes: - Database maintenance - Backend storage unavailable - Server overloaded</p> <p>Example: <pre><code>POST /storage/v1/object/uploads/file.txt\n(Connection pool exhausted)\n\u2192 503: Service temporarily unavailable\nRetry-After: 30\n</code></pre></p> <p>Recovery: Retry with exponential backoff</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#507-insufficient-storage","title":"507 Insufficient Storage","text":"<p>Causes: - Disk full - Quota exceeded (future)</p> <p>Example: <pre><code>POST /storage/v1/object/large_files/huge.bin\n\u2192 507: Insufficient storage space\n</code></pre></p> <p>Timing: Detected during disk write</p> <p>Recovery: - Clean up old files - Request storage increase - Upgrade tier (future)</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#failure-scenarios","title":"Failure Scenarios","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#1-upload-atomic-failure","title":"1. Upload Atomic Failure","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#scenario-disk-write-succeeds-db-insert-fails","title":"Scenario: Disk write succeeds, DB insert fails","text":"<pre><code>1. Write file to disk \u2192 OK\n2. Insert metadata to DB \u2192 ERROR (connection lost)\n</code></pre> <p>State: - File on disk: \u2713 - Metadata in DB: \u2717</p> <p>Recovery: <pre><code>async fn upload(path, data) -&gt; Result&lt;Object&gt; {\n    let file_path = write_to_disk(path, data)?;\n\n    match insert_metadata(path, data.len()) {\n        Ok(obj) =&gt; Ok(obj),\n        Err(e) =&gt; {\n            // Cleanup orphan file\n            let _ = delete_from_disk(&amp;file_path);\n            Err(e)\n        }\n    }\n}\n</code></pre></p> <p>Invariant: FS-F1 (Upload Failure Cleanup)</p> <p>Detection: No metadata means upload failed, file cleaned up</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#2-delete-partial-failure","title":"2. Delete Partial Failure","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#scenario-metadata-deleted-file-delete-fails","title":"Scenario: Metadata deleted, file delete fails","text":"<pre><code>1. Delete metadata from DB \u2192 OK\n2. Delete file from disk \u2192 ERROR (permission denied)\n</code></pre> <p>State: - File on disk: \u2713 (orphan) - Metadata in DB: \u2717</p> <p>Recovery: <pre><code>Orphan cleanup job (runs every hour):\n  1. Scan filesystem\n  2. Find files without metadata\n  3. Delete orphan files\n  4. Log cleanup actions\n</code></pre></p> <p>Invariant: FS-O1 (Bounded Orphan Window)</p> <p>User Impact: Delete operation succeeds (from their perspective)</p> <p>Ops Impact: Orphan file consumes disk space until cleanup</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#3-concurrent-upload-collision","title":"3. Concurrent Upload Collision","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#scenario-two-clients-upload-to-same-path","title":"Scenario: Two clients upload to same path","text":"<pre><code>Client A: POST /storage/v1/object/avatars/user123.jpg\nClient B: POST /storage/v1/object/avatars/user123.jpg\n</code></pre> <p>Behavior: - Both write to disk (last write wins) - DB transaction serializes metadata insert - Second insert fails with unique constraint violation</p> <p>Result: <pre><code>Client A: 200 OK\nClient B: 409 Conflict (path already exists)\n</code></pre></p> <p>Future: Versioning to keep both uploads</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#4-download-during-delete","title":"4. Download During Delete","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#scenario-client-downloads-while-another-client-deletes","title":"Scenario: Client downloads while another client deletes","text":"<pre><code>Time  Client A (Download)        Client B (Delete)\nT1    GET /avatars/user123.jpg\nT2                                DELETE /avatars/user123.jpg\nT3    (Read file from disk)\n</code></pre> <p>Race Outcomes:</p> Timing Result Delete before read 404 (expected) Delete during read Partial download or error Read completes before delete 200 OK (expected) <p>Mitigation: File locking (future) or versioning</p> <p>Current: Best-effort, no guarantees during concurrent access</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#5-signed-url-expiration-race","title":"5. Signed URL Expiration Race","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#scenario-url-expires-during-upload","title":"Scenario: URL expires during upload","text":"<pre><code>T1: Client gets signed URL (expires at T10)\nT2-T9: Client uploads large file\nT10: URL expires\nT11: Upload completes\n</code></pre> <p>Behavior: - Upload started with valid URL \u2192 Allow completion - Server checks signature at START, not END</p> <p>Alternative: Strict expiration (reject mid-upload)</p> <p>Decision: Allow completion for better UX (current)</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#cascading-failures","title":"Cascading Failures","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#database-unavailable","title":"Database Unavailable","text":"<p>Impact: - All operations fail (no metadata) - Existing downloads may still work (file exists)</p> <p>Mitigation: - DB connection pooling with retry - Circuit breaker pattern - Graceful degradation (read-only mode)</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#storage-backend-unavailable","title":"Storage Backend Unavailable","text":"<p>Impact: - Uploads fail immediately - Downloads fail - Metadata operations still work</p> <p>Mitigation: - Health check before operations - Multiple storage backends (future) - Cached file serving (future CDN)</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#authentication-service-down","title":"Authentication Service Down","text":"<p>Impact: - New uploads/downloads blocked - Signed URLs still work (JWT self-contained) - Service role operations still work</p> <p>Mitigation: - JWT caching - Service role bypass for critical ops</p>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#orphan-cleanup-job","title":"Orphan Cleanup Job","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#detection-logic","title":"Detection Logic","text":"<pre><code>-- Find orphan files (file exists, no metadata)\nSELECT path FROM enumerate_filesystem()\nWHERE path NOT IN (\n  SELECT bucket_id || '/' || path \n  FROM storage_objects\n);\n\n-- Find orphan metadata (metadata exists, no file)\nSELECT bucket_id, path \nFROM storage_objects\nWHERE NOT file_exists(bucket_id || '/' || path);\n</code></pre>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#cleanup-actions","title":"Cleanup Actions","text":"<pre><code>async fn cleanup_orphans() {\n    // Orphan files: Delete from disk\n    for file in detect_orphan_files() {\n        delete_from_disk(&amp;file)?;\n        log_cleanup(\"orphan_file\", &amp;file);\n    }\n\n    // Orphan metadata: Delete from DB\n    for metadata in detect_orphan_metadata() {\n        delete_from_db(&amp;metadata.id)?;\n        log_cleanup(\"orphan_metadata\", &amp;metadata.path);\n    }\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#scheduling","title":"Scheduling","text":"<ul> <li>Frequency: Every 1 hour</li> <li>Grace period: 5 minutes (allow recent uploads to complete)</li> <li>Max cleanup per run: 1000 files (prevent overload)</li> </ul>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#error-logging","title":"Error Logging","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#structured-logs","title":"Structured Logs","text":"<pre><code>{\n  \"level\": \"ERROR\",\n  \"service\": \"file_storage\",\n  \"operation\": \"upload\",\n  \"error\": \"507 Insufficient Storage\",\n  \"bucket\": \"large_files\",\n  \"path\": \"video.mp4\",\n  \"size_bytes\": 104857600,\n  \"user_id\": \"uuid\",\n  \"request_id\": \"uuid\",\n  \"timestamp\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#metrics","title":"Metrics","text":"<ul> <li><code>storage_upload_errors_total{error=\"413\"}</code></li> <li><code>storage_download_errors_total{error=\"404\"}</code></li> <li><code>storage_orphan_files_cleaned_total</code></li> <li><code>storage_orphan_metadata_cleaned_total</code></li> </ul>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#alerts","title":"Alerts","text":"<ul> <li>CRITICAL: Orphan count &gt; 1000</li> <li>WARNING: Error rate &gt; 5% for 5 minutes</li> <li>INFO: Cleanup job completed</li> </ul>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#client-retry-strategy","title":"Client Retry Strategy","text":""},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#recommended-approach","title":"Recommended Approach","text":"<pre><code>async function uploadWithRetry(file, maxRetries = 3) {\n  for (let attempt = 0; attempt &lt; maxRetries; attempt++) {\n    try {\n      return await uploadFile(file);\n    } catch (error) {\n      if (error.status &gt;= 400 &amp;&amp; error.status &lt; 500) {\n        // Client error - don't retry\n        throw error;\n      }\n\n      if (attempt === maxRetries - 1) {\n        throw error;\n      }\n\n      // Exponential backoff: 2^attempt seconds\n      await sleep(1000 * Math.pow(2, attempt));\n    }\n  }\n}\n</code></pre>"},{"location":"OBJECT_STORAGE_FAILURE_MODEL/#idempotency","title":"Idempotency","text":"<ul> <li>Upload: NOT idempotent (creates new version)</li> <li>Download: Idempotent (read-only)</li> <li>Delete: Idempotent (delete nonexistent = success)</li> </ul>"},{"location":"OBJECT_STORAGE_INVARIANTS/","title":"Phase 11: File Storage Invariants","text":"<p>Document Type: Invariants Specification Phase: 11 - File Storage Status: Active</p>"},{"location":"OBJECT_STORAGE_INVARIANTS/#core-invariants","title":"Core Invariants","text":""},{"location":"OBJECT_STORAGE_INVARIANTS/#fs-i1-metadata-consistency","title":"FS-I1: Metadata Consistency","text":"<p>File exists on disk \u27fa Metadata exists in database</p> <p>Formal Statement: <pre><code>\u2200 file f, bucket b:\n  exists_on_disk(f, b) \u27fa exists_in_db(metadata(f, b))\n</code></pre></p> <p>Implications: - Upload MUST be atomic: file written AND metadata inserted - Delete MUST be atomic: file removed AND metadata deleted - Orphan detection: scheduled job finds files without metadata or metadata without files</p> <p>Violation Consequences: - Orphan files waste storage - Orphan metadata causes 404 on download - Both violate user expectations</p> <p>Enforcement: 1. Atomic operations via transaction or two-phase commit 2. Background cleanup job runs every 1 hour 3. Metadata queries check file existence before returning</p>"},{"location":"OBJECT_STORAGE_INVARIANTS/#fs-i2-atomic-operations","title":"FS-I2: Atomic Operations","text":"<p>Upload/Delete succeed completely or not at all</p> <p>Formal Statement: <pre><code>Operation(upload | delete) \u2192 (complete \u2227 consistent) \u2228 (rollback \u2227 unchanged)\n</code></pre></p> <p>Upload Atomicity: <pre><code>BEGIN\n  1. Write file to disk \u2192 disk_result\n  2. Insert metadata to DB \u2192 db_result\n  IF disk_result = OK \u2227 db_result = OK:\n    COMMIT\n  ELSE:\n    DELETE file from disk (if written)\n    ROLLBACK DB transaction\n    RETURN error\nEND\n</code></pre></p> <p>Delete Atomicity: <pre><code>BEGIN\n  1. Load metadata from DB \u2192 metadata\n  2. Delete metadata from DB \u2192 db_result\n  3. Delete file from disk \u2192 disk_result\n  IF db_result = OK \u2227 disk_result = OK:\n    COMMIT\n  ELSE:\n    ROLLBACK DB transaction\n    RETURN error (metadata may still exist)\nEND\n</code></pre></p> <p>Enforcement: - Transactional metadata operations - Cleanup on partial failure - Idempotent retry logic</p>"},{"location":"OBJECT_STORAGE_INVARIANTS/#fs-i3-rls-enforcement","title":"FS-I3: RLS Enforcement","text":"<p>All file access goes through RLS check</p> <p>Formal Statement: <pre><code>\u2200 operation op, file f, user u:\n  perform(op, f, u) \u2192 first_check_rls(u, f.bucket) = allow\n</code></pre></p> <p>Policy Types: <pre><code>Public:         allow if true\nAuthenticated:  allow if u.is_authenticated\nPrivate:        allow if u.id = f.owner_id\nService:        allow if u.role = service_role\n</code></pre></p> <p>Enforcement Points: 1. Upload: Check write permission to bucket 2. Download: Check read permission to bucket 3. Delete: Check delete permission to bucket 4. List: Filter results by read permission</p> <p>Bypass Mechanism: Only service role can bypass RLS. This is explicit: <pre><code>if context.can_bypass_rls() {\n    // Service role - bypass RLS\n} else {\n    // Apply RLS based on bucket policy\n}\n</code></pre></p> <p>Violation Consequences: - Data leakage if not enforced - Unauthorized modification/deletion - Security breach</p>"},{"location":"OBJECT_STORAGE_INVARIANTS/#fs-i4-path-uniqueness","title":"FS-I4: Path Uniqueness","text":"<p>No two objects in same bucket have same path</p> <p>Formal Statement: <pre><code>\u2200 objects o1, o2 in bucket b:\n  o1.path = o2.path \u2192 o1.id = o2.id\n</code></pre></p> <p>Implications: - Bucket + path is unique key - Upload to existing path overwrites (future: versioning) - List results have no duplicates</p> <p>Enforcement: <pre><code>CREATE UNIQUE INDEX idx_storage_objects_bucket_path \nON storage_objects(bucket_id, path);\n</code></pre></p> <p>Violation Consequences: - Ambiguous file resolution - Undefined behavior on download - Data loss on concurrent upload</p>"},{"location":"OBJECT_STORAGE_INVARIANTS/#failure-invariants","title":"Failure Invariants","text":""},{"location":"OBJECT_STORAGE_INVARIANTS/#fs-f1-upload-failure-cleanup","title":"FS-F1: Upload Failure Cleanup","text":"<p>Failed upload cleans up partial file</p> <p>Guarantee: <pre><code>upload_fails(f) \u2192 \u00acexists_on_disk(f) \u2227 \u00acexists_in_db(metadata(f))\n</code></pre></p> <p>Failure Scenarios: 1. Disk write fails: No metadata inserted 2. Metadata insert fails: File deleted from disk 3. Network timeout: Partial file deleted, no metadata 4. Invalid MIME type: Validation before any write 5. Size limit exceeded: Validation before any write</p> <p>Cleanup Strategy: <pre><code>fn upload_with_cleanup(path, data, context) -&gt; Result&lt;Object&gt; {\n    // Validate BEFORE writing\n    validate_size(data.len())?;\n    validate_mime(data.content_type)?;\n\n    // Atomic operation\n    let file_path = write_to_disk(path, data)?;\n    match insert_metadata(path, context) {\n        Ok(obj) =&gt; Ok(obj),\n        Err(e) =&gt; {\n            delete_from_disk(file_path); // Cleanup\n            Err(e)\n        }\n    }\n}\n</code></pre></p>"},{"location":"OBJECT_STORAGE_INVARIANTS/#fs-f2-delete-failure-safe","title":"FS-F2: Delete Failure Safe","text":"<p>Delete failure leaves system in consistent state</p> <p>Guarantee: <pre><code>delete_fails(f) \u2192 \n  (exists_on_disk(f) \u2227 exists_in_db(metadata(f))) \u2228\n  (\u00acexists_on_disk(f) \u2227 \u00acexists_in_db(metadata(f)))\n</code></pre></p> <p>Failure Scenarios: 1. Metadata delete fails: File still exists, metadata exists (retry) 2. File delete fails: Metadata removed, file orphaned (cleanup job handles) 3. File not found: Metadata removed (idempotent)</p> <p>Recovery Strategy: - If metadata delete fails: Entire operation fails, nothing changes - If file delete fails after metadata removed: Orphan cleanup job removes file - Idempotent: Deleting non-existent file succeeds</p>"},{"location":"OBJECT_STORAGE_INVARIANTS/#orphan-detection-invariants","title":"Orphan Detection Invariants","text":""},{"location":"OBJECT_STORAGE_INVARIANTS/#fs-o1-bounded-orphan-window","title":"FS-O1: Bounded Orphan Window","text":"<p>Orphans detected within cleanup interval</p> <p>Formal Statement: <pre><code>orphan_created(f) \u2192 detected(f) within cleanup_interval\n</code></pre></p> <p>Default: cleanup_interval = 1 hour</p> <p>Detection Logic: <pre><code>-- Files without metadata\nSELECT path FROM filesystem \nWHERE path NOT IN (SELECT path FROM storage_objects);\n\n-- Metadata without files  \nSELECT path FROM storage_objects\nWHERE NOT exists_on_filesystem(bucket_id || '/' || path);\n</code></pre></p>"},{"location":"OBJECT_STORAGE_INVARIANTS/#fs-o2-cleanup-determinism","title":"FS-O2: Cleanup Determinism","text":"<p>Cleanup job is idempotent</p> <p>Guarantee: <pre><code>cleanup() \u2192 cleanup() produces same result\n</code></pre></p> <p>Enforcement: - Read-only scan - Explicit delete confirmations - Logged actions for audit</p>"},{"location":"OBJECT_STORAGE_INVARIANTS/#signed-url-invariants","title":"Signed URL Invariants","text":""},{"location":"OBJECT_STORAGE_INVARIANTS/#fs-s1-time-limited-access","title":"FS-S1: Time-Limited Access","text":"<p>Expired signed URLs are rejected</p> <p>Formal Statement: <pre><code>\u2200 url u: \n  now() &gt; u.expires_at \u2192 access(u) = REJECTED\n</code></pre></p> <p>Enforcement: <pre><code>fn verify_signed_url(url: &amp;SignedUrl) -&gt; Result&lt;()&gt; {\n    if Utc::now() &gt; url.expires_at {\n        return Err(StorageError::UrlExpired);\n    }\n    verify_signature(url)?;\n    Ok(())\n}\n</code></pre></p>"},{"location":"OBJECT_STORAGE_INVARIANTS/#fs-s2-signature-integrity","title":"FS-S2: Signature Integrity","text":"<p>Only validly signed URLs accepted</p> <p>Formal Statement: <pre><code>\u2200 url u:\n  access(u) = ALLOWED \u2192 signature_valid(u, secret)\n</code></pre></p> <p>Signature Generation: <pre><code>HMAC-SHA256(secret, bucket || path || expires_at)\n</code></pre></p> <p>Enforcement: - Constant-time comparison - Secret rotation support (future) - No access without valid signature</p>"},{"location":"OBJECT_STORAGE_INVARIANTS/#invariant-testing-matrix","title":"Invariant Testing Matrix","text":"Invariant Unit Test Integration Test Stress Test FS-I1 \u2705 Metadata sync \u2705 E2E upload \u2705 10k files FS-I2 \u2705 Atomic ops \u2705 Failure injection \u2705 Concurrent ops FS-I3 \u2705 RLS enforcement \u2705 Multi-user \u2705 1k users FS-I4 \u2705 Path collision \u2705 Concurrent upload \u2705 Rapid overwrites FS-F1 \u2705 Cleanup on error \u2705 Network timeout - FS-F2 \u2705 Delete idempotency \u2705 Partial failure - FS-O1 \u2705 Orphan detection \u2705 Cleanup job - FS-S1 \u2705 Expiration check \u2705 Time simulation - FS-S2 \u2705 Signature verify \u2705 Tamper detection -"},{"location":"OBJECT_STORAGE_INVARIANTS/#invariant-monitoring","title":"Invariant Monitoring","text":""},{"location":"OBJECT_STORAGE_INVARIANTS/#runtime-checks","title":"Runtime Checks","text":"<ul> <li>Metadata consistency check on startup</li> <li>Orphan count metric</li> <li>Failed upload cleanup counter</li> </ul>"},{"location":"OBJECT_STORAGE_INVARIANTS/#alerts","title":"Alerts","text":"<ul> <li>Orphan count &gt; 100 \u2192 WARNING</li> <li>Metadata-file mismatch &gt; 10 \u2192 CRITICAL</li> <li>RLS bypass attempts \u2192 SECURITY</li> </ul>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/","title":"Phase 11: File Storage Metadata Model","text":"<p>Document Type: Data Model Specification Phase: 11 - File Storage Status: Active</p>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#overview","title":"Overview","text":"<p>File metadata is stored in AeroDB collections, while file contents live on the storage backend (local FS or S3). This separation enables: - Queryable metadata via SQL/REST API - MVCC visibility for metadata - Transactional consistency - Replication of metadata - RLS enforcement on metadata queries</p>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#collections","title":"Collections","text":""},{"location":"OBJECT_STORAGE_METADATA_MODEL/#storage_buckets","title":"storage_buckets","text":"<p>Stores bucket definitions and policies.</p> <pre><code>CREATE COLLECTION storage_buckets (\n    id           TEXT PRIMARY KEY,      -- Bucket ID (UUID)\n    name         TEXT UNIQUE NOT NULL,  -- Bucket name (user-facing)\n    owner_id     TEXT,                  -- Owner user ID (NULL = system)\n    policy       TEXT NOT NULL,         -- \"public\" | \"private\" | \"authenticated\"\n    allowed_mime_types TEXT[],          -- Empty array = allow all\n    max_file_size      BIGINT NOT NULL, -- Bytes, 0 = unlimited\n    created_at   TIMESTAMP NOT NULL,\n    updated_at   TIMESTAMP NOT NULL\n);\n\nCREATE INDEX idx_buckets_name ON storage_buckets(name);\nCREATE INDEX idx_buckets_owner ON storage_buckets(owner_id);\n</code></pre> <p>Example Row: <pre><code>{\n  \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"name\": \"avatars\",\n  \"owner_id\": null,\n  \"policy\": \"private\",\n  \"allowed_mime_types\": [\"image/jpeg\", \"image/png\", \"image/webp\"],\n  \"max_file_size\": 5242880,\n  \"created_at\": \"2026-02-06T09:00:00Z\",\n  \"updated_at\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#storage_objects","title":"storage_objects","text":"<p>Stores file metadata (NOT the file contents).</p> <pre><code>CREATE COLLECTION storage_objects (\n    id            TEXT PRIMARY KEY,       -- Object ID (UUID)\n    bucket_id     TEXT NOT NULL           -- Foreign key to storage_buckets.id\n                  REFERENCES storage_buckets(id) ON DELETE CASCADE,\n    path          TEXT NOT NULL,          -- Path within bucket (e.g., \"users/123/avatar.jpg\")\n    size          BIGINT NOT NULL,        -- File size in bytes\n    content_type  TEXT NOT NULL,          -- MIME type (e.g., \"image/jpeg\")\n    checksum      TEXT NOT NULL,          -- SHA-256 hash of contents\n    owner_id      TEXT,                   -- Owner user ID (for RLS)\n    metadata      JSONB DEFAULT '{}',     -- Custom metadata (extensible)\n    created_at    TIMESTAMP NOT NULL,\n    updated_at    TIMESTAMP NOT NULL,\n\n    CONSTRAINT uniq_bucket_path UNIQUE (bucket_id, path)\n);\n\nCREATE INDEX idx_objects_bucket ON storage_objects(bucket_id);\nCREATE INDEX idx_objects_owner ON storage_objects(owner_id);\nCREATE INDEX idx_objects_path ON storage_objects(bucket_id, path);\nCREATE INDEX idx_objects_created ON storage_objects(created_at);\n</code></pre> <p>Example Row: <pre><code>{\n  \"id\": \"123e4567-e89b-12d3-a456-426614174000\",\n  \"bucket_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"path\": \"users/456/avatar.jpg\",\n  \"size\": 12345,\n  \"content_type\": \"image/jpeg\",\n  \"checksum\": \"a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a\",\n  \"owner_id\": \"789e0123-e45b-67d8-9012-345678901234\",\n  \"metadata\": {\n    \"width\": 512,\n    \"height\": 512,\n    \"uploaded_from\": \"ios_app\"\n  },\n  \"created_at\": \"2026-02-06T09:00:00Z\",\n  \"updated_at\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#metadata-fields","title":"Metadata Fields","text":""},{"location":"OBJECT_STORAGE_METADATA_MODEL/#id-object-id","title":"id (Object ID)","text":"<ul> <li>Type: UUID</li> <li>Purpose: Primary key, unique across all objects</li> <li>Generation: Server-side on upload</li> </ul>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#bucket_id","title":"bucket_id","text":"<ul> <li>Type: UUID (foreign key)</li> <li>Purpose: Links object to bucket</li> <li>Constraint: Must exist in <code>storage_buckets</code></li> <li>Cascade: Delete bucket \u2192 Delete all objects</li> </ul>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#path","title":"path","text":"<ul> <li>Type: String</li> <li>Purpose: File path within bucket</li> <li>Format: <code>folder/subfolder/filename.ext</code></li> <li>Uniqueness: (bucket_id, path) is unique</li> <li>Validation:</li> <li>No leading/trailing slashes</li> <li>No <code>..</code> (path traversal)</li> <li>Max length: 1024 characters</li> </ul> <p>Example Paths: <pre><code>\u2705 users/123/avatar.jpg\n\u2705 documents/2026/Q1/report.pdf\n\u2705 images/products/laptop-hero.webp\n\u274c /absolute/path.jpg  (leading slash)\n\u274c ../etc/passwd       (path traversal)\n\u274c ../../evil.txt      (path traversal)\n</code></pre></p>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#size","title":"size","text":"<ul> <li>Type: BIGINT (64-bit integer)</li> <li>Purpose: File size in bytes</li> <li>Range: 0 to 2^63 - 1</li> <li>Usage:</li> <li>Display to user (\"12.3 KB\")</li> <li>Quota enforcement (future)</li> <li>Storage billing (future)</li> </ul>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#content_type","title":"content_type","text":"<ul> <li>Type: String (MIME type)</li> <li>Purpose: File type</li> <li>Examples:</li> <li><code>image/jpeg</code></li> <li><code>application/pdf</code></li> <li><code>video/mp4</code></li> <li>Validation: Must match bucket's <code>allowed_mime_types</code></li> </ul>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#checksum","title":"checksum","text":"<ul> <li>Type: String (hex-encoded SHA-256)</li> <li>Purpose: Verify file integrity</li> <li>Length: 64 characters</li> <li>Calculation: <pre><code>use sha2::{Sha256, Digest};\nlet mut hasher = Sha256::new();\nhasher.update(&amp;file_contents);\nlet checksum = format!(\"{:x}\", hasher.finalize());\n</code></pre></li> <li>Usage:</li> <li>Detect corruption</li> <li>Deduplication (future)</li> <li>Content-addressable storage (future)</li> </ul>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#owner_id","title":"owner_id","text":"<ul> <li>Type: UUID (user ID)</li> <li>Purpose: RLS enforcement (who uploaded the file)</li> <li>Nullable: Yes (system-uploaded files have NULL owner)</li> <li>RLS Query: <pre><code>SELECT * FROM storage_objects \nWHERE owner_id = current_user_id();\n</code></pre></li> </ul>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#metadata-jsonb","title":"metadata (JSONB)","text":"<ul> <li>Type: JSON object</li> <li>Purpose: Extensible custom metadata</li> <li>Schema: Unstructured (application-defined)</li> <li>Examples: <pre><code>{\n  \"width\": 1920,\n  \"height\": 1080,\n  \"camera\": \"iPhone 13\",\n  \"location\": \"SF\",\n  \"tags\": [\"vacation\", \"beach\"]\n}\n</code></pre></li> <li>Queryable: <pre><code>SELECT * FROM storage_objects \nWHERE metadata-&gt;&gt;'camera' = 'iPhone 13';\n</code></pre></li> </ul>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#created_at-updated_at","title":"created_at / updated_at","text":"<ul> <li>Type: TIMESTAMP (UTC)</li> <li>Purpose: Audit trail</li> <li>Auto-managed: Server sets on insert/update</li> </ul>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#filesystem-mapping","title":"Filesystem Mapping","text":"<p>Metadata path \u2192 Filesystem path:</p> <pre><code>Metadata: bucket_id=\"550e84...\", path=\"users/123/avatar.jpg\"\nFilesystem: &lt;storage_root&gt;/550e8400-e29b-41d4-a716-446655440000/users/123/avatar.jpg\n</code></pre> <p>Separation Benefits: - Bucket rename doesn't move files - Path collision handled at DB level - Filesystem layout is implementation detail</p>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#invariants-metadata-specific","title":"Invariants (Metadata-Specific)","text":""},{"location":"OBJECT_STORAGE_METADATA_MODEL/#met-i1-referential-integrity","title":"MET-I1: Referential Integrity","text":"<p>Every object references a valid bucket</p> <p>Enforcement: <pre><code>FOREIGN KEY (bucket_id) REFERENCES storage_buckets(id) ON DELETE CASCADE\n</code></pre></p> <p>Implication: Deleting bucket deletes all objects</p>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#met-i2-path-uniqueness","title":"MET-I2: Path Uniqueness","text":"<p>No two objects in same bucket have same path</p> <p>Enforcement: <pre><code>CONSTRAINT uniq_bucket_path UNIQUE (bucket_id, path)\n</code></pre></p> <p>Implication: Upload to existing path fails with 409 Conflict</p>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#met-i3-checksum-match","title":"MET-I3: Checksum Match","text":"<p>Checksum in metadata matches file on disk</p> <p>Verification: <pre><code>async fn verify_checksum(obj: &amp;StorageObject) -&gt; Result&lt;()&gt; {\n    let file_data = read_from_disk(&amp;obj.path)?;\n    let actual = StorageObject::calculate_checksum(&amp;file_data);\n\n    if actual != obj.checksum {\n        return Err(StorageError::ChecksumMismatch);\n    }\n\n    Ok(())\n}\n</code></pre></p> <p>When to verify: - On download (optional, performance tradeoff) - Health check (periodic) - Migration (S3 upload)</p>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#querying-metadata","title":"Querying Metadata","text":""},{"location":"OBJECT_STORAGE_METADATA_MODEL/#list-files-in-bucket","title":"List Files in Bucket","text":"<pre><code>SELECT id, path, size, content_type, created_at \nFROM storage_objects \nWHERE bucket_id = ?\nORDER BY created_at DESC\nLIMIT 100;\n</code></pre>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#find-large-files","title":"Find Large Files","text":"<pre><code>SELECT bucket_id, path, size \nFROM storage_objects \nWHERE size &gt; 10485760  -- 10MB\nORDER BY size DESC;\n</code></pre>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#search-by-mime-type","title":"Search by MIME Type","text":"<pre><code>SELECT * FROM storage_objects \nWHERE content_type LIKE 'image/%';\n</code></pre>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#users-files-rls-applied","title":"User's Files (RLS Applied)","text":"<pre><code>SELECT * FROM storage_objects \nWHERE owner_id = current_user_id();\n</code></pre>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#custom-metadata-search","title":"Custom Metadata Search","text":"<pre><code>SELECT * FROM storage_objects \nWHERE metadata-&gt;&gt;'camera' = 'iPhone 13'\n  AND metadata-&gt;&gt;'location' = 'SF';\n</code></pre>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#storage-usage-analytics","title":"Storage Usage Analytics","text":""},{"location":"OBJECT_STORAGE_METADATA_MODEL/#bucket-storage","title":"Bucket Storage","text":"<pre><code>SELECT \n  b.name AS bucket,\n  COUNT(o.id) AS file_count,\n  SUM(o.size) AS total_bytes,\n  SUM(o.size) / 1024 / 1024 AS total_mb\nFROM storage_buckets b\nLEFT JOIN storage_objects o ON b.id = o.bucket_id\nGROUP BY b.id, b.name\nORDER BY total_bytes DESC;\n</code></pre>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#user-storage-quota","title":"User Storage Quota","text":"<pre><code>SELECT \n  owner_id,\n  COUNT(*) AS file_count,\n  SUM(size) AS total_bytes\nFROM storage_objects\nWHERE owner_id IS NOT NULL\nGROUP BY owner_id\nHAVING SUM(size) &gt; 1073741824  -- 1GB\nORDER BY total_bytes DESC;\n</code></pre>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#metadata-events-real-time","title":"Metadata Events (Real-Time)","text":"<p>File operations emit events to AeroDB event log:</p> <pre><code>{\n  \"type\": \"storage.object.created\",\n  \"object_id\": \"123e4567-...\",\n  \"bucket\": \"avatars\",\n  \"path\": \"users/456/avatar.jpg\",\n  \"size\": 12345,\n  \"content_type\": \"image/jpeg\",\n  \"owner_id\": \"789e0123-...\",\n  \"timestamp\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre> <p>Event types: - <code>storage.object.created</code> - <code>storage.object.updated</code> (overwrite) - <code>storage.object.deleted</code> - <code>storage.bucket.created</code> - <code>storage.bucket.deleted</code></p> <p>Clients can subscribe: <pre><code>const subscription = supabase\n  .channel('storage-changes')\n  .on('storage.object.created', { bucket: 'avatars' }, handleUpload)\n  .subscribe();\n</code></pre></p>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#migration-strategy","title":"Migration Strategy","text":""},{"location":"OBJECT_STORAGE_METADATA_MODEL/#from-no-metadata-to-metadata","title":"From No Metadata to Metadata","text":"<pre><code>-- Scan filesystem, create metadata for existing files\nINSERT INTO storage_objects (id, bucket_id, path, size, content_type, checksum)\nSELECT \n  gen_random_uuid(),\n  bucket_id_from_path(file_path),\n  relative_path(file_path),\n  file_size(file_path),\n  detect_mime_type(file_path),\n  sha256(file_path)\nFROM enumerate_filesystem();\n</code></pre>"},{"location":"OBJECT_STORAGE_METADATA_MODEL/#metadata-versioning","title":"Metadata Versioning","text":"<p>Future: Add <code>version</code> field to track overwrite history <pre><code>ALTER TABLE storage_objects ADD COLUMN version INTEGER DEFAULT 1;\n</code></pre></p>"},{"location":"OBJECT_STORAGE_READINESS/","title":"Phase 11: File Storage Readiness Checklist","text":"<p>Document Type: Readiness Checklist Phase: 11 - File Storage Status: In Progress</p>"},{"location":"OBJECT_STORAGE_READINESS/#documentation-checklist","title":"Documentation Checklist","text":"<ul> <li> OBJECT_STORAGE_VISION.md - Goals and philosophy</li> <li> OBJECT_STORAGE_ARCHITECTURE.md - Backend abstraction design</li> <li> OBJECT_STORAGE_BUCKET_MODEL.md - Bucket policies and validation</li> <li> OBJECT_STORAGE_ACCESS_MODEL.md - Signed URLs and RLS</li> <li> OBJECT_STORAGE_METADATA_MODEL.md - File metadata in AeroDB</li> <li> OBJECT_STORAGE_INVARIANTS.md - Storage invariants (FS-I1, FS-I2, FS-I3, FS-I4)</li> <li> OBJECT_STORAGE_FAILURE_MODEL.md - Failure handling and recovery</li> <li> OBJECT_STORAGE_TESTING_STRATEGY.md - Test coverage plan</li> <li> OBJECT_STORAGE_READINESS.md - Freeze criteria (this document)</li> </ul> <p>Status: \u2705 All 9 documents complete</p>"},{"location":"OBJECT_STORAGE_READINESS/#implementation-checklist","title":"Implementation Checklist","text":""},{"location":"OBJECT_STORAGE_READINESS/#core-modules","title":"Core Modules","text":"<ul> <li> <code>src/file_storage/mod.rs</code> - Module entry point</li> <li> <code>src/file_storage/errors.rs</code> - Storage error types</li> <li> <code>src/file_storage/bucket.rs</code> - Bucket management</li> <li> <code>src/file_storage/file.rs</code> - File CRUD operations</li> <li> <code>src/file_storage/permissions.rs</code> - RLS integration</li> <li> <code>src/file_storage/backend.rs</code> - Storage backend trait</li> <li> <code>src/file_storage/local.rs</code> - Local filesystem backend</li> <li> <code>src/file_storage/signed_url.rs</code> - Signed URL generation/validation</li> </ul>"},{"location":"OBJECT_STORAGE_READINESS/#api-endpoints","title":"API Endpoints","text":"<ul> <li> POST <code>/storage/v1/object/{bucket}/{path}</code> - Upload file</li> <li> GET <code>/storage/v1/object/{bucket}/{path}</code> - Download file</li> <li> DELETE <code>/storage/v1/object/{bucket}/{path}</code> - Delete file</li> <li> POST <code>/storage/v1/object/copy</code> - Copy file (future)</li> <li> POST <code>/storage/v1/object/move</code> - Move file (future)</li> <li> POST <code>/storage/v1/bucket</code> - Create bucket</li> <li> GET <code>/storage/v1/bucket</code> - List buckets</li> <li> DELETE <code>/storage/v1/bucket/{name}</code> - Delete bucket</li> </ul>"},{"location":"OBJECT_STORAGE_READINESS/#metadata-storage","title":"Metadata Storage","text":"<ul> <li> <code>storage_objects</code> collection schema</li> <li> <code>storage_buckets</code> collection schema</li> <li> Executor integration for metadata queries</li> <li> Atomic file + metadata operations</li> <li> Orphan cleanup background job</li> </ul>"},{"location":"OBJECT_STORAGE_READINESS/#permissions","title":"Permissions","text":"<ul> <li> Public bucket policy (anyone can read)</li> <li> Private bucket policy (owner only)</li> <li> Authenticated bucket policy (any authed user)</li> <li> Per-file RLS context integration</li> <li> Signed URL HMAC generation</li> <li> Signed URL expiration enforcement</li> <li> Service role bypass</li> </ul>"},{"location":"OBJECT_STORAGE_READINESS/#test-checklist","title":"Test Checklist","text":""},{"location":"OBJECT_STORAGE_READINESS/#unit-tests","title":"Unit Tests","text":"<ul> <li> Bucket creation and validation (&gt; 10 tests)</li> <li> File upload/download/delete (&gt; 15 tests)</li> <li> Permission enforcement (&gt; 10 tests)</li> <li> Signed URL generation/validation (&gt; 8 tests)</li> <li> Local backend operations (&gt; 8 tests)</li> <li> Error handling (&gt; 10 tests)</li> </ul> <p>Target: &gt; 60 unit tests, &gt; 90% coverage</p>"},{"location":"OBJECT_STORAGE_READINESS/#integration-tests","title":"Integration Tests","text":"<ul> <li> End-to-end upload \u2192 metadata \u2192 download</li> <li> RLS enforcement with real auth contexts</li> <li> Concurrent file operations</li> <li> Metadata consistency checks</li> <li> Bucket deletion with files</li> </ul> <p>Target: &gt; 15 integration tests</p>"},{"location":"OBJECT_STORAGE_READINESS/#stress-tests","title":"Stress Tests","text":"<ul> <li> 10k files in single bucket</li> <li> 100MB file upload/download</li> <li> 1k concurrent uploads</li> <li> Rapid create/delete cycles</li> </ul>"},{"location":"OBJECT_STORAGE_READINESS/#invariant-validation","title":"Invariant Validation","text":"<p>Each invariant must have tests proving it holds:</p> Invariant Test Coverage Status FS-I1: Metadata Consistency Integration tests \u2b1c FS-I2: Atomic Operations Failure injection tests \u2b1c FS-I3: RLS Enforcement Permission tests \u2b1c FS-I4: Path Uniqueness Bucket tests \u2b1c FS-F1: Upload Failure Cleanup Error tests \u2b1c FS-F2: Delete Failure Safe Error tests \u2b1c"},{"location":"OBJECT_STORAGE_READINESS/#performance-benchmarks","title":"Performance Benchmarks","text":"Metric Target Actual Status Upload (1MB, local FS) &gt; 50 MB/s - \u2b1c Download (1MB, local FS) &gt; 100 MB/s - \u2b1c Metadata query (p99) &lt; 10ms - \u2b1c Signed URL generation &lt; 5ms - \u2b1c List 1000 files &lt; 50ms - \u2b1c"},{"location":"OBJECT_STORAGE_READINESS/#integration-points","title":"Integration Points","text":""},{"location":"OBJECT_STORAGE_READINESS/#aerodb-core","title":"AeroDB Core","text":"<ul> <li> Executor integration for metadata storage</li> <li> WAL integration for atomic operations (future)</li> <li> RLS context from auth module</li> <li> Error mapping to HTTP status codes</li> </ul>"},{"location":"OBJECT_STORAGE_READINESS/#rest-api","title":"REST API","text":"<ul> <li> Storage endpoints registered</li> <li> Multipart upload support (future)</li> <li> Range request support (future)</li> </ul>"},{"location":"OBJECT_STORAGE_READINESS/#authentication","title":"Authentication","text":"<ul> <li> RLS context passed to all operations</li> <li> Service role bypass tested</li> <li> Signed URL JWT validation</li> </ul>"},{"location":"OBJECT_STORAGE_READINESS/#deployment-checklist","title":"Deployment Checklist","text":""},{"location":"OBJECT_STORAGE_READINESS/#configuration","title":"Configuration","text":"<ul> <li> <code>storage.backend</code> = \"local\" | \"s3\" (future)</li> <li> <code>storage.local.root_dir</code> path</li> <li> <code>storage.max_file_size</code> global limit</li> <li> <code>storage.cleanup_interval</code> for orphans</li> </ul>"},{"location":"OBJECT_STORAGE_READINESS/#migration","title":"Migration","text":"<ul> <li> Create <code>storage_objects</code> schema</li> <li> Create <code>storage_buckets</code> schema</li> <li> Index on <code>bucket_id</code> + <code>path</code></li> </ul>"},{"location":"OBJECT_STORAGE_READINESS/#monitoring","title":"Monitoring","text":"<ul> <li> Metrics: upload/download throughput</li> <li> Metrics: storage usage per bucket</li> <li> Metrics: orphan file count</li> <li> Logs: file operations with user context</li> </ul>"},{"location":"OBJECT_STORAGE_READINESS/#freeze-criteria","title":"Freeze Criteria","text":"<p>Phase 11 can be frozen when:</p> <ol> <li>\u2705 All 9 documentation files complete and peer-reviewed</li> <li>\u2b1c All 8 core modules implemented</li> <li>\u2b1c All 8 API endpoints working</li> <li>\u2b1c Metadata stored in AeroDB via executor</li> <li>\u2b1c All 6 invariants have test coverage</li> <li>\u2b1c &gt; 60 unit tests passing</li> <li>\u2b1c &gt; 15 integration tests passing</li> <li>\u2b1c Performance benchmarks meet targets</li> <li>\u2b1c RLS enforcement verified</li> <li>\u2b1c Orphan cleanup job implemented</li> </ol> <p>Current Status: \ud83d\udd34 NOT READY</p>"},{"location":"OBJECT_STORAGE_READINESS/#known-limitations-deferred","title":"Known Limitations (Deferred)","text":"<ul> <li>S3-compatible backend (future Phase 11.1)</li> <li>Multipart uploads for large files (&gt;100MB)</li> <li>Resumable uploads</li> <li>CDN integration</li> <li>Image transformations/thumbnails</li> <li>Storage quota enforcement per user/project</li> <li>Signed URL single-use tokens</li> </ul> <p>These are explicitly deferred to keep Phase 11 focused on core file storage.</p>"},{"location":"OBJECT_STORAGE_READINESS/#risk-assessment","title":"Risk Assessment","text":"Risk Mitigation Owner Metadata-file inconsistency Atomic ops + cleanup job Core team Orphan files on crash Background cleanup + WAL integration Core team Signed URL security HMAC with rotation Security team Large file memory usage Streaming upload/download Performance team Concurrent access races File locking or versioning Core team"},{"location":"OBJECT_STORAGE_READINESS/#sign-off-required","title":"Sign-Off Required","text":"<ul> <li> Lead Engineer: Core implementation review</li> <li> Security: RLS and signed URL review</li> <li> QA: Test coverage and edge cases</li> <li> Docs: All 9 documents complete and accurate</li> <li> Performance: Benchmarks meet targets</li> </ul>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/","title":"Phase 11: File Storage Testing Strategy","text":"<p>Document Type: Testing Strategy Phase: 11 - File Storage Status: Active</p>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#test-coverage-goals","title":"Test Coverage Goals","text":"Component Target Focus Areas Bucket operations 95% CRUD, validation, concurrency File CRUD 95% Upload, download, delete, move, copy Permissions 98% RLS enforcement, public/private, signed URLs Signed URLs 90% Generation, validation, expiration Backend abstraction 90% Local FS, future S3 Metadata storage 95% DB integration, consistency"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#unit-tests","title":"Unit Tests","text":""},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#bucket-management-tests","title":"Bucket Management Tests","text":"<pre><code>#[test]\nfn test_create_bucket_with_policy()\nfn test_duplicate_bucket_name_errors()\nfn test_delete_non_empty_bucket_fails()\nfn test_bucket_mime_type_validation()\nfn test_bucket_size_limit_enforcement()\nfn test_bucket_owner_assignment()\n</code></pre>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#file-operations-tests","title":"File Operations Tests","text":"<pre><code>#[test]\nfn test_upload_to_public_bucket()\nfn test_upload_to_private_bucket_as_owner()\nfn test_upload_to_private_bucket_unauthorized()\nfn test_download_respects_rls()\nfn test_delete_requires_ownership()\nfn test_file_metadata_stored_in_db()\nfn test_atomic_upload_failure_cleanup()\nfn test_checksum_verification()\n</code></pre>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#permission-tests","title":"Permission Tests","text":"<pre><code>#[test]\nfn test_public_bucket_anonymous_read()\nfn test_private_bucket_owner_only()\nfn test_authenticated_bucket_any_user()\nfn test_rls_context_integration()\nfn test_service_role_bypass()\n</code></pre>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#signed-url-tests","title":"Signed URL Tests","text":"<pre><code>#[test]\nfn test_signed_url_generation()\nfn test_signed_url_expiration()\nfn test_invalid_signature_rejected()\nfn test_expired_url_rejected()\nfn test_url_single_use_enforcement() // future\n</code></pre>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#integration-tests","title":"Integration Tests","text":""},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#end-to-end-scenarios","title":"End-to-End Scenarios","text":"<ol> <li>Complete Upload Flow</li> <li> <p>Create bucket \u2192 Upload file \u2192 Verify metadata in DB \u2192 Download \u2192 Verify content</p> </li> <li> <p>Permission Enforcement</p> </li> <li>Upload as user A \u2192 Attempt download as user B \u2192 Verify rejection</li> <li> <p>Upload as user A \u2192 Download as user A \u2192 Verify success</p> </li> <li> <p>Signed URL Flow</p> </li> <li>Generate signed URL \u2192 Access anonymously \u2192 Verify content</li> <li> <p>Wait for expiration \u2192 Access again \u2192 Verify rejection</p> </li> <li> <p>Concurrent Operations</p> </li> <li>Multiple uploads to same bucket</li> <li>Upload during bucket deletion</li> <li> <p>Delete during download</p> </li> <li> <p>Failure Recovery</p> </li> <li>Upload with network interruption \u2192 Verify cleanup</li> <li>Delete with missing file \u2192 Verify metadata removal</li> <li>Orphan cleanup job execution</li> </ol>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#stress-tests","title":"Stress Tests","text":""},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#volume-testing","title":"Volume Testing","text":"<ul> <li>10k files in single bucket</li> <li>1k concurrent uploads</li> <li>100MB file upload/download</li> <li>Rapid create/delete cycles</li> </ul>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#metadata-consistency","title":"Metadata Consistency","text":"<ul> <li>Verify file exists \u27fa metadata exists</li> <li>Concurrent metadata queries</li> <li>Transaction rollback handling</li> </ul>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#failure-injection","title":"Failure Injection","text":"Scenario Expected Behavior Disk full during upload Error 507, partial file cleaned up Database down Error 500, no orphan files Network timeout Graceful timeout, cleanup Invalid MIME type Error 415 before write Exceeds size limit Error 413 before write Missing bucket Error 404, no file created"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#rls-testing","title":"RLS Testing","text":""},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#ownership-based-access","title":"Ownership-Based Access","text":"<pre><code>#[test]\nfn test_file_owner_can_read()\nfn test_non_owner_cannot_read_private()\nfn test_service_role_bypasses_rls()\nfn test_rls_filters_list_results()\n</code></pre>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#policy-enforcement","title":"Policy Enforcement","text":"<pre><code>#[test]\nfn test_public_bucket_any_read()\nfn test_authenticated_bucket_authed_only()\nfn test_private_bucket_owner_only()\n</code></pre>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#performance-benchmarks","title":"Performance Benchmarks","text":""},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#target-metrics","title":"Target Metrics","text":"<ul> <li>Upload throughput: &gt; 50 MB/s (local FS)</li> <li>Download throughput: &gt; 100 MB/s (local FS)</li> <li>Metadata query: &lt; 10ms (p99)</li> <li>Signed URL generation: &lt; 5ms</li> </ul>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#benchmark-tests","title":"Benchmark Tests","text":"<pre><code>#[bench]\nfn bench_upload_1mb_file()\nfn bench_download_1mb_file()\nfn bench_generate_signed_url()\nfn bench_list_1000_files()\n</code></pre>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#coverage-validation","title":"Coverage Validation","text":"<p>Run with coverage: <pre><code>cargo tarpaulin --lib --packages aerodb --out Lcov -- file_storage::\n</code></pre></p> <p>Acceptance: &gt; 90% line coverage, &gt; 85% branch coverage</p>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#test-data-management","title":"Test Data Management","text":""},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#fixtures","title":"Fixtures","text":"<ul> <li>Sample files (text, binary, large)</li> <li>Test user contexts (owner, non-owner, anonymous, service role)</li> <li>Bucket configurations (public, private, authenticated, MIME filters)</li> </ul>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#cleanup","title":"Cleanup","text":"<p>All tests use <code>TempDir</code> for isolation. No shared state.</p>"},{"location":"OBJECT_STORAGE_TESTING_STRATEGY/#invariant-validation","title":"Invariant Validation","text":"<p>Each test category validates specific invariants:</p> <ul> <li>FS-I1 (Metadata Consistency): Integration tests verify file \u27fa metadata</li> <li>FS-I2 (Atomic Operations): Failure injection tests verify cleanup</li> <li>FS-I3 (RLS Enforcement): Permission tests verify blocking</li> <li>FS-I4 (Path Uniqueness): Bucket tests verify collision detection</li> </ul>"},{"location":"OBJECT_STORAGE_VISION/","title":"Phase 11: File Storage Vision","text":"<p>Document Type: Vision Statement Phase: 11 - File Storage Status: Active</p>"},{"location":"OBJECT_STORAGE_VISION/#goal","title":"Goal","text":"<p>Provide S3-compatible file storage with RLS-based access control, enabling applications to store and retrieve files (images, documents, videos) with the same permission model and correctness guarantees as database records.</p>"},{"location":"OBJECT_STORAGE_VISION/#core-philosophy","title":"Core Philosophy","text":""},{"location":"OBJECT_STORAGE_VISION/#1-metadata-in-database","title":"1. Metadata in Database","text":"<p>File metadata lives in AeroDB collections, enjoying all the benefits of AeroDB: - Transactional consistency - MVCC visibility - Replication to followers - Queryable via SQL/REST API</p> <p>Example: <pre><code>SELECT * FROM storage_objects \nWHERE bucket_id = 'avatars' \n  AND owner_id = current_user_id()\n  AND size &lt; 1000000;\n</code></pre></p>"},{"location":"OBJECT_STORAGE_VISION/#2-rls-for-files","title":"2. RLS for Files","text":"<p>Files use the same permission model as collections: - Public buckets (anyone can read) - Private buckets (owner only) - Authenticated buckets (any authenticated user) - Per-file owner_id for fine-grained control</p> <p>Invariant: No file access without RLS check</p>"},{"location":"OBJECT_STORAGE_VISION/#3-backend-abstraction","title":"3. Backend Abstraction","text":"<p>Storage backend is pluggable: - Local filesystem (Phase 11) - S3-compatible (future Phase 11.1) - CDN integration (future)</p> <p>Application code is backend-agnostic</p>"},{"location":"OBJECT_STORAGE_VISION/#4-signed-urls","title":"4. Signed URLs","text":"<p>Time-limited, pre-authenticated URLs for: - Sharing files with unauthenticated users - Direct browser upload/download (bypass API) - Temporary access without session</p> <p>Example: <pre><code>https://api.aerodb.io/storage/v1/object/sign/avatars/user123.jpg\n  ?token=eyJhbGc...\n  &amp;expires=1675123456\n</code></pre></p>"},{"location":"OBJECT_STORAGE_VISION/#5-explicit-buckets","title":"5. Explicit Buckets","text":"<p>No implicit storage locations. Applications must: 1. Create bucket with policy 2. Upload to bucket 3. Manage bucket lifecycle</p> <p>Anti-Pattern: Auto-create buckets on first upload (implicit, surprising)</p>"},{"location":"OBJECT_STORAGE_VISION/#design-principles","title":"Design Principles","text":""},{"location":"OBJECT_STORAGE_VISION/#simplicity-over-features","title":"Simplicity Over Features","text":"<p>Include: - Upload, download, delete - Public/private buckets - Signed URLs - MIME type validation - Size limits</p> <p>Exclude (defer): - Image transformations/thumbnails - Video transcoding - Multipart uploads - Resumable uploads - Object versioning - CDN integration - Replication across regions</p> <p>Rationale: Focus on core file storage. Transformations are a separate phase.</p>"},{"location":"OBJECT_STORAGE_VISION/#fail-safe-defaults","title":"Fail-Safe Defaults","text":"<p>Buckets default to private (secure by default) <pre><code>BucketConfig::default().policy == BucketPolicy::Private\n</code></pre></p> <p>Uploads validate before writing (fail fast) <pre><code>// 1. Check size BEFORE disk I/O\nif file.size &gt; bucket.max_file_size {\n    return Err(413);\n}\n\n// 2. Check MIME BEFORE disk I/O\nif !bucket.is_mime_allowed(file.content_type) {\n    return Err(415);\n}\n\n// 3. THEN write to disk\n</code></pre></p>"},{"location":"OBJECT_STORAGE_VISION/#metadata-consistency","title":"Metadata Consistency","text":"<p>Invariant FS-I1: File exists \u27fa Metadata exists</p> <p>Implementation: - Atomic operations (file + metadata) - Background cleanup job for orphans - Health check on startup</p> <p>Why it matters: - Users expect metadata queries to reflect reality - Download 404 on phantom metadata is confusing - Orphan files waste storage</p>"},{"location":"OBJECT_STORAGE_VISION/#success-criteria","title":"Success Criteria","text":"<p>Phase 11 is successful when:</p>"},{"location":"OBJECT_STORAGE_VISION/#functional","title":"Functional","text":"<ol> <li>\u2705 Upload files up to 100MB</li> <li>\u2705 Download files with RLS enforcement</li> <li>\u2705 Delete files atomically (file + metadata)</li> <li>\u2705 Generate signed URLs valid for 1 hour</li> <li>\u2705 Public buckets allow anonymous read</li> <li>\u2705 Private buckets enforce ownership</li> <li>\u2705 MIME type filtering works</li> <li>\u2705 Size limits enforced</li> </ol>"},{"location":"OBJECT_STORAGE_VISION/#non-functional","title":"Non-Functional","text":"<ol> <li>\u2705 Upload throughput &gt; 50 MB/s (local FS, p50)</li> <li>\u2705 Download throughput &gt; 100 MB/s (local FS, p50)</li> <li>\u2705 Metadata query latency &lt; 10ms (p99)</li> <li>\u2705 Orphan files cleaned within 1 hour</li> <li>\u2705 No data loss on crash (atomic operations)</li> </ol>"},{"location":"OBJECT_STORAGE_VISION/#security","title":"Security","text":"<ol> <li>\u2705 All file access goes through RLS</li> <li>\u2705 Signed URLs expire correctly</li> <li>\u2705 Invalid signatures rejected</li> <li>\u2705 Service role bypass is explicit</li> </ol>"},{"location":"OBJECT_STORAGE_VISION/#integration-with-aerodb","title":"Integration with AeroDB","text":""},{"location":"OBJECT_STORAGE_VISION/#authentication-phase-8","title":"Authentication (Phase 8)","text":"<pre><code>// Every storage operation gets RLS context\nlet context = extract_rls_context(&amp;request)?;\nstorage.upload(bucket, path, data, &amp;context)?;\n</code></pre>"},{"location":"OBJECT_STORAGE_VISION/#rest-api-phase-9","title":"REST API (Phase 9)","text":"<pre><code>POST   /storage/v1/object/{bucket}/{path}  - Upload\nGET    /storage/v1/object/{bucket}/{path}  - Download\nDELETE /storage/v1/object/{bucket}/{path}  - Delete\nPOST   /storage/v1/bucket                  - Create bucket\n</code></pre>"},{"location":"OBJECT_STORAGE_VISION/#real-time-phase-10","title":"Real-Time (Phase 10)","text":"<p>File events emitted to event log: <pre><code>{\n  \"type\": \"storage.object.created\",\n  \"bucket\": \"avatars\",\n  \"path\": \"user123.jpg\",\n  \"owner_id\": \"uuid\",\n  \"timestamp\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p> <p>Clients can subscribe to storage events.</p>"},{"location":"OBJECT_STORAGE_VISION/#examples","title":"Examples","text":""},{"location":"OBJECT_STORAGE_VISION/#upload-avatar","title":"Upload Avatar","text":"<pre><code>curl -X POST \\\n  -H \"Authorization: Bearer $JWT\" \\\n  -H \"Content-Type: image/jpeg\" \\\n  --data-binary @avatar.jpg \\\n  https://api.aerodb.io/storage/v1/object/avatars/user123.jpg\n</code></pre> <p>Response: <pre><code>{\n  \"id\": \"uuid\",\n  \"bucket\": \"avatars\",\n  \"path\": \"user123.jpg\",\n  \"size\": 12345,\n  \"content_type\": \"image/jpeg\",\n  \"owner_id\": \"uuid\",\n  \"created_at\": \"2026-02-06T09:00:00Z\"\n}\n</code></pre></p>"},{"location":"OBJECT_STORAGE_VISION/#create-public-bucket","title":"Create Public Bucket","text":"<pre><code>curl -X POST \\\n  -H \"Authorization: Bearer $JWT\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"public_docs\",\n    \"policy\": \"public\",\n    \"allowed_mime_types\": [\"application/pdf\"],\n    \"max_file_size\": 10485760\n  }' \\\n  https://api.aerodb.io/storage/v1/bucket\n</code></pre>"},{"location":"OBJECT_STORAGE_VISION/#generate-signed-url","title":"Generate Signed URL","text":"<pre><code>curl -X POST \\\n  -H \"Authorization: Bearer $JWT\" \\\n  https://api.aerodb.io/storage/v1/object/sign/avatars/user123.jpg?expires_in=3600\n</code></pre> <p>Response: <pre><code>{\n  \"url\": \"https://api.aerodb.io/storage/v1/object/sign/avatars/user123.jpg?token=eyJhbGc...&amp;expires=1675123456\",\n  \"expires_at\": \"2026-02-06T10:00:00Z\"\n}\n</code></pre></p>"},{"location":"OBJECT_STORAGE_VISION/#future-phases","title":"Future Phases","text":""},{"location":"OBJECT_STORAGE_VISION/#phase-111-s3-compatible-backend","title":"Phase 11.1: S3-Compatible Backend","text":"<ul> <li>Configure S3 endpoint, bucket, credentials</li> <li>Transparent to application code</li> <li>Same metadata-in-DB approach</li> </ul>"},{"location":"OBJECT_STORAGE_VISION/#phase-112-image-transformations","title":"Phase 11.2: Image Transformations","text":"<ul> <li>Resize, crop, format conversion</li> <li>On-the-fly or pre-computed</li> <li>Cached results</li> </ul>"},{"location":"OBJECT_STORAGE_VISION/#phase-113-cdn-integration","title":"Phase 11.3: CDN Integration","text":"<ul> <li>Edge caching for public files</li> <li>Signed URLs with CDN</li> <li>Cache invalidation</li> </ul>"},{"location":"OBJECT_STORAGE_VISION/#phase-114-versioning","title":"Phase 11.4: Versioning","text":"<ul> <li>Keep multiple versions of same path</li> <li>Delete = soft delete (mark version)</li> <li>Restore previous versions</li> </ul>"},{"location":"OBJECT_STORAGE_VISION/#explicit-non-goals","title":"Explicit Non-Goals","text":"<p>What Phase 11 does NOT do:</p>"},{"location":"OBJECT_STORAGE_VISION/#no-file-locking","title":"No File Locking","text":"<p>Files can be overwritten concurrently. Last write wins. Future: Optimistic concurrency control with ETag</p>"},{"location":"OBJECT_STORAGE_VISION/#no-streaming-uploads","title":"No Streaming Uploads","text":"<p>Entire file must fit in memory during upload. Future: Multipart/resumable uploads for large files</p>"},{"location":"OBJECT_STORAGE_VISION/#no-automatic-backups","title":"No Automatic Backups","text":"<p>Files are NOT included in AeroDB snapshots/WAL. Future: S3 lifecycle policies or external backup</p>"},{"location":"OBJECT_STORAGE_VISION/#no-search","title":"No Search","text":"<p>Cannot full-text search file contents. Use: Store extracted text in AeroDB collection</p>"},{"location":"OBJECT_STORAGE_VISION/#no-access-logs","title":"No Access Logs","text":"<p>No per-file access audit trail. Future: Integrate with Phase 8 audit log</p>"},{"location":"OBJECT_STORAGE_VISION/#risks-and-mitigations","title":"Risks and Mitigations","text":"Risk Mitigation Orphan files consume disk Cleanup job runs hourly Large files OOM server Size limits enforced Malicious uploads (virus) Antivirus scan (future) Signed URL abuse Expiration + rate limiting Concurrent access races Documented, versioning (future) Metadata-file desync Atomic ops + health checks"},{"location":"OBJECT_STORAGE_VISION/#stakeholders","title":"Stakeholders","text":"<ul> <li>Application developers: Simple file upload API</li> <li>End users: Fast, reliable file access</li> <li>Security team: RLS enforcement, signed URLs</li> <li>Ops team: Observable, reliable storage</li> <li>AeroDB core: Consistent with database philosophy</li> </ul>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/","title":"PHASE 5 \u2014 FAILURE MATRIX (REPLICATION IMPLEMENTATION)","text":""},{"location":"OBSERVABILITY_FAILURE_MATRIX/#status","title":"Status","text":"<ul> <li>Phase: 5</li> <li>Authority: Normative</li> <li>Scope: All replication failure scenarios</li> <li>Depends on:</li> <li><code>OBSERVABILITY_VISION.md</code></li> <li><code>OBSERVABILITY_INVARIANTS.md</code></li> <li><code>OBSERVABILITY_IMPLEMENTATION_ORDER.md</code></li> <li><code>REPLICATION_RUNTIME_ARCHITECTURE.md</code></li> <li><code>REPL_*</code> specifications</li> <li><code>MVCC_*</code> specifications</li> <li><code>CORE_INVARIANTS.md</code></li> <li><code>FAILURE_MODEL_PHASE3.md</code></li> </ul> <p>This document defines exact expected outcomes for failures during replication implementation and operation.</p> <p>If runtime behavior under failure does not match this matrix, the implementation is incorrect.</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#1-purpose","title":"1. Purpose","text":"<p>Replication failures are expected, not exceptional.</p> <p>This matrix: - Enumerates all relevant failure points - Specifies required outcomes - Forbids silent progress - Preserves determinism and explainability</p> <p>This document is exhaustive for Phase 5.</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#2-failure-handling-principles","title":"2. Failure Handling Principles","text":""},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-1-fail-closed","title":"F-1: Fail Closed","text":"<p>If replication correctness cannot be proven: - Replication MUST stop - Reads MUST be refused (if unsafe) - Failure MUST be surfaced</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-2-no-partial-visibility","title":"F-2: No Partial Visibility","text":"<p>At no point may: - Partially applied WAL be visible - Unvalidated WAL affect state - Mixed snapshot/WAL state leak</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-3-deterministic-recovery","title":"F-3: Deterministic Recovery","text":"<p>Given identical persisted state: - Recovery behavior MUST be identical - Outcomes MUST be reproducible</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#3-failure-axes","title":"3. Failure Axes","text":"<p>Failures are classified along four axes:</p> <ol> <li>Location \u2014 which component failed</li> <li>Time \u2014 when failure occurred</li> <li>Persistence \u2014 what was durably written</li> <li>Visibility \u2014 what may be exposed</li> </ol> <p>All axes must be considered.</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#4-primary-side-failures","title":"4. Primary-Side Failures","text":""},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-p1-primary-crash-before-wal-fsync","title":"F-P1: Primary Crash Before WAL fsync","text":"<p>Condition - Primary crashes after assigning CommitId - WAL record NOT durably fsynced</p> <p>Required Outcome - Write is lost (never acknowledged) - WAL record does not appear - Replica never receives the record</p> <p>Explainability - Recovery explanation references missing WAL durability</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-p2-primary-crash-after-wal-fsync","title":"F-P2: Primary Crash After WAL fsync","text":"<p>Condition - WAL record durably written - Crash before replication shipment</p> <p>Required Outcome - WAL is replayed on primary recovery - Replicas may receive WAL later - CommitId continuity preserved</p> <p>Explainability - Recovery explanation shows WAL replay range</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#5-replica-wal-receiver-failures","title":"5. Replica WAL Receiver Failures","text":""},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-r1-receiver-crash-before-wal-persist","title":"F-R1: Receiver Crash Before WAL Persist","text":"<p>Condition - WAL segment partially received - No durable write</p> <p>Required Outcome - WAL segment discarded - No validation attempted - No state mutation</p> <p>Post-Recovery - Receiver resumes from last durable offset</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-r2-receiver-crash-after-wal-persist","title":"F-R2: Receiver Crash After WAL Persist","text":"<p>Condition - WAL bytes durably stored - Validation not completed</p> <p>Required Outcome - WAL segment available for validation - No application performed</p> <p>Explainability - DX shows received-but-unvalidated state</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#6-wal-validation-failures","title":"6. WAL Validation Failures","text":""},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-v1-checksum-validation-failure","title":"F-V1: Checksum Validation Failure","text":"<p>Condition - WAL checksum mismatch</p> <p>Required Outcome - WAL segment rejected - Replication blocked - Replica refuses reads</p> <p>Explainability - Explanation references checksum rule violation</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-v2-continuity-failure-gap-or-overlap","title":"F-V2: Continuity Failure (Gap or Overlap)","text":"<p>Condition - WAL segment does not continue prefix</p> <p>Required Outcome - WAL rejected - Replica state unchanged - Explicit failure surfaced</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#7-wal-application-failures","title":"7. WAL Application Failures","text":""},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-a1-crash-during-wal-application","title":"F-A1: Crash During WAL Application","text":"<p>Condition - WAL partially applied to storage - Crash occurs mid-application</p> <p>Required Outcome - On recovery:   - Partial application rolled back or ignored   - WAL replay resumes deterministically - No partial visibility</p> <p>Explainability - Recovery explanation shows replay restart point</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-a2-crash-after-wal-apply-before-metadata-persist","title":"F-A2: Crash After WAL Apply Before Metadata Persist","text":"<p>Condition - Storage mutated - Replica metadata not yet updated</p> <p>Required Outcome - Recovery reconciles storage and metadata - WAL re-applied idempotently or safely ignored</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#8-snapshot-bootstrap-failures","title":"8. Snapshot Bootstrap Failures","text":""},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-s1-crash-during-snapshot-transfer","title":"F-S1: Crash During Snapshot Transfer","text":"<p>Condition - Snapshot partially transferred</p> <p>Required Outcome - Snapshot discarded - Replica remains uninitialized - No WAL applied</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-s2-crash-after-snapshot-transfer-before-validation","title":"F-S2: Crash After Snapshot Transfer Before Validation","text":"<p>Condition - Snapshot data present - Validation incomplete</p> <p>Required Outcome - Snapshot invalidated - Bootstrap restarts from scratch</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-s3-snapshotwal-boundary-mismatch","title":"F-S3: Snapshot/WAL Boundary Mismatch","text":"<p>Condition - WAL resume offset does not match snapshot cut</p> <p>Required Outcome - Hard failure - Replica refuses to proceed</p> <p>Explainability - Explanation references snapshot/WAL continuity violation</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#9-replica-recovery-failures","title":"9. Replica Recovery Failures","text":""},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-rc1-crash-during-replica-recovery","title":"F-RC1: Crash During Replica Recovery","text":"<p>Condition - Replica crashes during its own recovery</p> <p>Required Outcome - Recovery restarts from last durable state - Outcome identical to single crash</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-rc2-corrupt-replica-metadata","title":"F-RC2: Corrupt Replica Metadata","text":"<p>Condition - Replica metadata checksum failure</p> <p>Required Outcome - Replica refuses to start - Requires operator intervention</p> <p>Explainability - Explicit corruption explanation</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#10-read-safety-failures","title":"10. Read-Safety Failures","text":""},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-rs1-read-requested-while-unsafe","title":"F-RS1: Read Requested While Unsafe","text":"<p>Condition - Replica not read-safe - Read requested</p> <p>Required Outcome - Read refused - Explicit reason returned</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-rs2-state-change-during-read-evaluation","title":"F-RS2: State Change During Read Evaluation","text":"<p>Condition - Replica state changes mid-read</p> <p>Required Outcome - Read re-evaluated or refused - No mixed-state read allowed</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#11-observability-failures","title":"11. Observability Failures","text":""},{"location":"OBSERVABILITY_FAILURE_MATRIX/#f-o1-dx-endpoint-during-failure","title":"F-O1: DX Endpoint During Failure","text":"<p>Condition - DX endpoint queried during replication failure</p> <p>Required Outcome - Partial state allowed - Must be labeled incomplete - No inference or guessing</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#12-forbidden-failure-responses","title":"12. Forbidden Failure Responses","text":"<p>Explicitly forbidden:</p> <ul> <li>Silent retry loops</li> <li>Background \u201ceventual catch-up\u201d</li> <li>Serving stale reads without proof</li> <li>Auto-resetting failure state</li> <li>Masking checksum or continuity errors</li> </ul> <p>If any appear, the implementation is invalid.</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#13-testing-requirements-mapping","title":"13. Testing Requirements (Mapping)","text":"<p>Each failure scenario MUST have: - At least one deterministic test - Crash-injection coverage where applicable - Explanation validation</p> <p>No failure is \u201ctoo rare to test\u201d.</p>"},{"location":"OBSERVABILITY_FAILURE_MATRIX/#14-final-rule","title":"14. Final Rule","text":"<p>Replication failures must be louder than replication success.</p> <p>If failure behavior is unclear, correctness is already lost.</p> <p>END OF DOCUMENT</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/","title":"PHASE 5 \u2014 IMPLEMENTATION ORDER (REPLICATION)","text":""},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#status","title":"Status","text":"<ul> <li>Phase: 5</li> <li>Authority: Normative</li> <li>Scope: Replication implementation sequencing</li> <li>Depends on:</li> <li><code>OBSERVABILITY_VISION.md</code></li> <li><code>OBSERVABILITY_INVARIANTS.md</code></li> <li><code>REPL_*</code> specifications</li> <li><code>MVCC_*</code> specifications</li> <li><code>CORE_*</code> specifications</li> </ul> <p>This document defines the only allowed implementation order for Phase 5 replication.</p> <p>If implementation proceeds out of order, correctness proofs no longer hold.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#1-purpose","title":"1. Purpose","text":"<p>Replication is a cross-cutting concern: - WAL - Storage - MVCC - Recovery - Concurrency - Failure handling</p> <p>Incorrect sequencing causes: - Hidden invariant violations - \u201cTemporary\u201d unsafe states - Non-reproducible bugs</p> <p>This document exists to prevent partial correctness.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#2-absolute-rule","title":"2. Absolute Rule","text":"<p>You MUST complete each stage fully before starting the next.</p> <p>\u201cPartially implemented\u201d stages are forbidden.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#3-phase-5-implementation-stages-authoritative-order","title":"3. Phase 5 Implementation Stages (Authoritative Order)","text":"<p>There are 7 stages. They MUST be implemented in order.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#stage-1-replication-configuration-role-declaration","title":"STAGE 1 \u2014 Replication Configuration &amp; Role Declaration","text":""},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#goal","title":"Goal","text":"<p>Establish static replication identity.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-implement","title":"Must Implement","text":"<ul> <li>Node role: <code>Primary</code> or <code>Replica</code></li> <li>Immutable role at startup</li> <li>Replica identity (ID, UUID, or stable token)</li> <li>Replication disabled path (default-safe)</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-not-implement-yet","title":"Must NOT Implement Yet","text":"<ul> <li>Networking</li> <li>WAL shipping</li> <li>Replica threads</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#required-invariants","title":"Required Invariants","text":"<ul> <li>P5-I1 (No semantic redefinition)</li> <li>P5-I16 (Replication removable)</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#completion-criteria","title":"Completion Criteria","text":"<ul> <li>Primary runs identically with replication disabled</li> <li>Replica mode refuses all writes</li> <li>Role is observable via DX</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#stage-2-replica-wal-receiver-ingress-only","title":"STAGE 2 \u2014 Replica WAL Receiver (Ingress Only)","text":""},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#goal_1","title":"Goal","text":"<p>Allow a replica to receive WAL bytes, but not apply them.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-implement_1","title":"Must Implement","text":"<ul> <li>WAL segment receiver</li> <li>Sequential append buffer</li> <li>Strict ordering enforcement</li> <li>No validation beyond framing</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-not-implement-yet_1","title":"Must NOT Implement Yet","text":"<ul> <li>WAL checksum validation</li> <li>WAL application</li> <li>CommitId advancement</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#required-invariants_1","title":"Required Invariants","text":"<ul> <li>P5-I4 (WAL prefix rule)</li> <li>P5-I10 (Explicit failure over progress)</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#completion-criteria_1","title":"Completion Criteria","text":"<ul> <li>WAL bytes can be received and stored</li> <li>WAL gaps cause hard failure</li> <li>Replica state remains unchanged</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#stage-3-wal-validation-layer","title":"STAGE 3 \u2014 WAL Validation Layer","text":""},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#goal_2","title":"Goal","text":"<p>Prove WAL correctness before application.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-implement_2","title":"Must Implement","text":"<ul> <li>Checksum validation</li> <li>Continuity validation</li> <li>Segment boundary handling</li> <li>Explicit invalid-WAL failure paths</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-not-implement-yet_2","title":"Must NOT Implement Yet","text":"<ul> <li>WAL application</li> <li>Storage mutation</li> <li>MVCC updates</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#required-invariants_2","title":"Required Invariants","text":"<ul> <li>P5-I5 (Validate before apply)</li> <li>P5-I11 (Crash safety)</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#completion-criteria_2","title":"Completion Criteria","text":"<ul> <li>Invalid WAL is detected deterministically</li> <li>No WAL-derived state becomes visible</li> <li>Validation is restart-safe</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#stage-4-wal-application-replica-storage","title":"STAGE 4 \u2014 WAL Application (Replica Storage)","text":""},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#goal_3","title":"Goal","text":"<p>Apply validated WAL to replica storage.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-implement_3","title":"Must Implement","text":"<ul> <li>WAL replay into append-only storage</li> <li>Deterministic replay ordering</li> <li>Crash-safe replay checkpoints</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-not-implement-yet_3","title":"Must NOT Implement Yet","text":"<ul> <li>Replica read serving</li> <li>Snapshot bootstrap</li> <li>MVCC snapshot exposure</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#required-invariants_3","title":"Required Invariants","text":"<ul> <li>P5-I4 (Prefix rule)</li> <li>P5-I6 (CommitId authority isolation)</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#completion-criteria_3","title":"Completion Criteria","text":"<ul> <li>Replica storage matches primary-derived state</li> <li>Crash + replay produces identical state</li> <li>CommitId advancement is observable but read-blocked</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#stage-5-snapshot-bootstrap-cold-start","title":"STAGE 5 \u2014 Snapshot Bootstrap (Cold Start)","text":""},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#goal_4","title":"Goal","text":"<p>Allow a replica to start from a snapshot instead of empty state.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-implement_4","title":"Must Implement","text":"<ul> <li>Snapshot transfer protocol</li> <li>Snapshot integrity validation</li> <li>Exact MVCC cut handling</li> <li>WAL resume offset calculation</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-not-implement-yet_4","title":"Must NOT Implement Yet","text":"<ul> <li>Replica reads</li> <li>Optimizations</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#required-invariants_4","title":"Required Invariants","text":"<ul> <li>P5-I8 (Snapshot is a cut)</li> <li>P5-I9 (Snapshot + WAL continuity)</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#completion-criteria_4","title":"Completion Criteria","text":"<ul> <li>Replica can bootstrap from snapshot</li> <li>WAL resumes exactly after snapshot cut</li> <li>No reads are served during bootstrap</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#stage-6-replica-recovery","title":"STAGE 6 \u2014 Replica Recovery","text":""},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#goal_5","title":"Goal","text":"<p>Make replication restart-safe.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-implement_5","title":"Must Implement","text":"<ul> <li>Crash recovery for replica</li> <li>WAL replay resumption</li> <li>Partial state cleanup</li> <li>Deterministic recovery path</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-not-implement-yet_5","title":"Must NOT Implement Yet","text":"<ul> <li>Read safety shortcuts</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#required-invariants_5","title":"Required Invariants","text":"<ul> <li>P5-I11 (Crash safety)</li> <li>P5-I4 (Prefix rule restored)</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#completion-criteria_5","title":"Completion Criteria","text":"<ul> <li>Replica recovers identically after crash</li> <li>No partial WAL application leaks</li> <li>Recovery explanation is available</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#stage-7-replica-read-safety-gate","title":"STAGE 7 \u2014 Replica Read Safety Gate","text":""},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#goal_6","title":"Goal","text":"<p>Allow reads only when provably safe.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-implement_6","title":"Must Implement","text":"<ul> <li>Read-safety predicate</li> <li>MVCC snapshot checks</li> <li>Explicit refusal paths</li> <li>Explanation of read safety</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#must-not-implement","title":"Must NOT Implement","text":"<ul> <li>Read-your-own-writes</li> <li>Stale reads without proof</li> <li>Heuristic lag allowances</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#required-invariants_6","title":"Required Invariants","text":"<ul> <li>P5-I12 (Read safety proven)</li> <li>MVCC invariants</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#completion-criteria_6","title":"Completion Criteria","text":"<ul> <li>Unsafe reads are refused</li> <li>Safe reads behave identically to primary reads</li> <li><code>/v1/explain/replication</code> proves safety</li> </ul>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#4-forbidden-shortcuts-explicit","title":"4. Forbidden Shortcuts (Explicit)","text":"<p>The following are illegal:</p> <ul> <li>Implementing reads before recovery</li> <li>Applying WAL before validation</li> <li>Serving reads during bootstrap</li> <li>Inferring safety from time or lag</li> <li>\u201cTemporary\u201d invariant violations</li> </ul> <p>If a shortcut seems necessary, the design is wrong.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#5-observability-requirements-per-stage","title":"5. Observability Requirements Per Stage","text":"<p>Each stage MUST expose: - Current replication state - Blocking reasons - Failure causes</p> <p>Hidden progress is forbidden.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#6-testing-order-mirrors-implementation","title":"6. Testing Order (Mirrors Implementation)","text":"<p>Tests MUST be added in the same order:</p> <ol> <li>Role enforcement tests</li> <li>WAL ingress tests</li> <li>WAL validation failure tests</li> <li>WAL replay crash tests</li> <li>Snapshot bootstrap tests</li> <li>Replica recovery tests</li> <li>Read safety tests</li> </ol> <p>Skipping test order is not allowed.</p>"},{"location":"OBSERVABILITY_IMPLEMENTATION_ORDER/#7-final-rule","title":"7. Final Rule","text":"<p>Replication correctness comes from sequencing, not from cleverness.</p> <p>If the order is respected, correctness follows.</p> <p>If the order is violated, bugs become invisible.</p> <p>END OF DOCUMENT</p>"},{"location":"OBSERVABILITY_INVARIANTS/","title":"PHASE 5 \u2014 INVARIANTS (REPLICATION IMPLEMENTATION)","text":""},{"location":"OBSERVABILITY_INVARIANTS/#status","title":"Status","text":"<ul> <li>Phase: 5</li> <li>Authority: Normative</li> <li>Scope: All replication implementation code</li> <li>Depends on:</li> <li><code>OBSERVABILITY_VISION.md</code></li> <li><code>REPL_INVARIANTS.md</code></li> <li><code>REPL_PROOFS.md</code></li> <li><code>MVCC_*</code> documents</li> <li><code>CORE_INVARIANTS.md</code></li> <li><code>FAILURE_MODEL_PHASE3.md</code></li> </ul> <p>This document defines the implementation-time invariants that MUST hold at all times during Phase 5.</p> <p>These invariants are not new semantics. They are enforcement rules to ensure the implementation does not violate already-frozen replication semantics.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#1-purpose","title":"1. Purpose","text":"<p>Replication implementations fail most often due to:</p> <ul> <li>\u201cTemporary\u201d invariant violations</li> <li>Incomplete ordering guarantees</li> <li>Hidden state during concurrency</li> <li>Assumptions about network or timing</li> </ul> <p>This document exists to make such failures illegal.</p> <p>If an invariant cannot be maintained continuously, the implementation approach is invalid.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#2-phase-5-invariant-hierarchy","title":"2. Phase 5 Invariant Hierarchy","text":"<p>Phase 5 invariants are subordinate to:</p> <ol> <li><code>CORE_INVARIANTS.md</code></li> <li><code>MVCC_*</code> invariants</li> <li><code>REPL_INVARIANTS.md</code></li> </ol> <p>If any Phase 5 invariant conflicts with the above, Phase 5 loses.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#3-global-phase-5-invariants","title":"3. Global Phase 5 Invariants","text":""},{"location":"OBSERVABILITY_INVARIANTS/#p5-i1-no-semantic-redefinition","title":"P5-I1: No Semantic Redefinition","text":"<p>Phase 5 code MUST NOT:</p> <ul> <li>Change replication meaning</li> <li>Add new replication states</li> <li>Infer behavior not present in specs</li> <li>Introduce \u201ctemporary\u201d semantics</li> </ul> <p>Replication behavior is defined elsewhere. Phase 5 implements it exactly.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#p5-i2-continuous-invariant-enforcement","title":"P5-I2: Continuous Invariant Enforcement","text":"<p>All replication invariants MUST hold:</p> <ul> <li>During steady state</li> <li>During startup</li> <li>During shutdown</li> <li>During crash windows</li> <li>During partial failure</li> <li>During recovery</li> </ul> <p>There is no \u201cinitialization exception\u201d.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#p5-i3-explicit-state-machines-only","title":"P5-I3: Explicit State Machines Only","text":"<p>All replication logic MUST be implemented as:</p> <ul> <li>Explicit state machines</li> <li>With enumerated states</li> <li>With explicit transitions</li> <li>With documented invariants per state</li> </ul> <p>Implicit states are forbidden.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#4-wal-related-invariants","title":"4. WAL-Related Invariants","text":""},{"location":"OBSERVABILITY_INVARIANTS/#p5-i4-wal-prefix-rule-continuous","title":"P5-I4: WAL Prefix Rule (Continuous)","text":"<p>At all times:</p> <p>The replica WAL MUST be a strict prefix of the primary WAL.</p> <p>This invariant MUST hold:</p> <ul> <li>During WAL reception</li> <li>During WAL validation</li> <li>During WAL application</li> <li>During replica recovery</li> </ul> <p>Partial or speculative WAL application is forbidden.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#p5-i5-wal-validation-before-application","title":"P5-I5: WAL Validation Before Application","text":"<p>A replica MUST NOT:</p> <ul> <li>Apply WAL records</li> <li>Expose WAL-derived state</li> <li>Advance replica CommitId</li> </ul> <p>Until:</p> <ul> <li>WAL checksum is validated</li> <li>WAL ordering is verified</li> <li>WAL continuity is confirmed</li> </ul> <p>Validation precedes application, always.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#5-commitid-mvcc-invariants","title":"5. CommitId &amp; MVCC Invariants","text":""},{"location":"OBSERVABILITY_INVARIANTS/#p5-i6-commitid-authority-isolation","title":"P5-I6: CommitId Authority Isolation","text":"<p>Only the Primary may:</p> <ul> <li>Assign CommitIds</li> <li>Advance global CommitId</li> </ul> <p>Replicas MUST:</p> <ul> <li>Treat CommitIds as immutable facts</li> <li>Never infer missing CommitIds</li> <li>Never synthesize CommitIds</li> </ul>"},{"location":"OBSERVABILITY_INVARIANTS/#p5-i7-mvcc-rules-are-identical-on-replicas","title":"P5-I7: MVCC Rules Are Identical on Replicas","text":"<p>Replica reads MUST obey:</p> <ul> <li>Identical MVCC visibility rules</li> <li>Identical snapshot semantics</li> </ul> <p>No replica-specific MVCC shortcuts are allowed.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#6-snapshot-bootstrap-invariants","title":"6. Snapshot &amp; Bootstrap Invariants","text":""},{"location":"OBSERVABILITY_INVARIANTS/#p5-i8-snapshot-bootstrap-is-a-cut","title":"P5-I8: Snapshot Bootstrap Is a Cut","text":"<p>Snapshot bootstrap MUST:</p> <ul> <li>Represent a precise MVCC cut</li> <li>Be durably complete before use</li> <li>Be validated before WAL resume</li> </ul> <p>Replica MUST NOT serve reads during bootstrap.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#p5-i9-snapshot-wal-continuity","title":"P5-I9: Snapshot + WAL Continuity","text":"<p>After bootstrap:</p> <ul> <li>WAL resume MUST start exactly after snapshot cut</li> <li>No WAL gaps are allowed</li> <li>No WAL replay overlap is allowed</li> </ul> <p>Any mismatch is a hard failure.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#7-failure-handling-invariants","title":"7. Failure Handling Invariants","text":""},{"location":"OBSERVABILITY_INVARIANTS/#p5-i10-explicit-failure-over-progress","title":"P5-I10: Explicit Failure Over Progress","text":"<p>If replication cannot safely proceed:</p> <ul> <li>It MUST stop</li> <li>It MUST surface the failure</li> <li>It MUST refuse unsafe reads</li> </ul> <p>Continuing \u201cas best as possible\u201d is forbidden.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#p5-i11-crash-safety","title":"P5-I11: Crash Safety","text":"<p>After any crash:</p> <ul> <li>Replica state MUST be derivable</li> <li>WAL prefix invariant MUST be restored</li> <li>No partial application may remain visible</li> </ul> <p>Recovery MUST be deterministic.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#8-read-safety-invariants","title":"8. Read-Safety Invariants","text":""},{"location":"OBSERVABILITY_INVARIANTS/#p5-i12-read-safety-is-proven-not-assumed","title":"P5-I12: Read Safety Is Proven, Not Assumed","text":"<p>A replica may serve reads ONLY IF:</p> <ul> <li>WAL prefix condition holds</li> <li>Snapshot CommitId \u2264 replica CommitId</li> <li>No in-flight application exists</li> </ul> <p>If safety cannot be proven, reads are forbidden.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#9-concurrency-invariants","title":"9. Concurrency Invariants","text":""},{"location":"OBSERVABILITY_INVARIANTS/#p5-i13-no-concurrent-authority","title":"P5-I13: No Concurrent Authority","text":"<p>Replication code MUST NOT:</p> <ul> <li>Mutate shared authoritative state concurrently</li> <li>Rely on timing to serialize actions</li> <li>Use locks as semantic boundaries without state checks</li> </ul> <p>Concurrency MUST be controlled via explicit states.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#10-observability-explanation-invariants","title":"10. Observability &amp; Explanation Invariants","text":""},{"location":"OBSERVABILITY_INVARIANTS/#p5-i14-replication-state-is-observable","title":"P5-I14: Replication State Is Observable","text":"<p>All replication states MUST be:</p> <ul> <li>Observable via DX APIs</li> <li>Explainable via explanation engine</li> </ul> <p>Hidden replication state is forbidden.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#p5-i15-explanations-reflect-reality","title":"P5-I15: Explanations Reflect Reality","text":"<p>Replication explanations MUST:</p> <ul> <li>Reference real WAL offsets</li> <li>Reference real CommitIds</li> <li>Reference real state machine states</li> </ul> <p>No synthetic explanations allowed.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#11-disablement-invariants","title":"11. Disablement Invariants","text":""},{"location":"OBSERVABILITY_INVARIANTS/#p5-i16-replication-is-removable","title":"P5-I16: Replication Is Removable","text":"<p>Replication MUST be:</p> <ul> <li>Disableable at startup</li> <li>Removable at compile time</li> </ul> <p>Disabling replication MUST:</p> <ul> <li>Not affect primary behavior</li> <li>Not affect durability</li> <li>Not affect MVCC semantics</li> </ul>"},{"location":"OBSERVABILITY_INVARIANTS/#12-testing-invariants","title":"12. Testing Invariants","text":""},{"location":"OBSERVABILITY_INVARIANTS/#p5-i17-every-invariant-is-testable","title":"P5-I17: Every Invariant Is Testable","text":"<p>For each Phase 5 invariant:</p> <ul> <li>At least one test MUST exist</li> <li>Crash tests MUST cover it</li> <li>Recovery tests MUST validate it</li> </ul> <p>If an invariant cannot be tested, the implementation is incomplete.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#13-forbidden-implementation-patterns","title":"13. Forbidden Implementation Patterns","text":"<p>The following are explicitly forbidden:</p> <ul> <li>Heuristic retries</li> <li>Time-based assumptions</li> <li>\u201cEventually consistent\u201d behavior</li> <li>Background best-effort cleanup</li> <li>Silent error handling</li> <li>Partial progress masking failures</li> </ul> <p>If code requires these, the design is wrong.</p>"},{"location":"OBSERVABILITY_INVARIANTS/#14-final-rule","title":"14. Final Rule","text":"<p>Replication correctness is not about making progress. It is about never being wrong.</p> <p>If replication cannot proceed safely, it must stop and explain why.</p> <p>END OF DOCUMENT</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/","title":"PHASE 5 \u2014 OBSERVABILITY MAPPING (REPLICATION)","text":""},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#status","title":"Status","text":"<ul> <li>Phase: 5</li> <li>Authority: Normative</li> <li>Scope: Replication observability &amp; explanation integration</li> <li>Depends on:</li> <li><code>DX_OBSERVABILITY_API.md</code></li> <li><code>DX_EXPLANATION_MODEL.md</code></li> <li><code>REPLICATION_RUNTIME_ARCHITECTURE.md</code></li> <li><code>OBSERVABILITY_INVARIANTS.md</code></li> <li><code>OBSERVABILITY_FAILURE_MATRIX.md</code></li> </ul> <p>This document defines how replication runtime state is exposed via existing Phase 4 observability and explanation mechanisms.</p> <p>Phase 5 MUST NOT introduce new observability concepts. It must reuse and extend Phase 4 surfaces.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#1-purpose","title":"1. Purpose","text":"<p>Replication is complex and failure-prone. Without observability, replication correctness becomes unverifiable.</p> <p>This document ensures that: - Replication state is never hidden - Blocking conditions are visible - Read safety decisions are explainable - Failures can be diagnosed without logs</p> <p>Observability is not optional in Phase 5.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#2-core-principle","title":"2. Core Principle","text":""},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#o5-1-replication-is-a-first-class-observable-system","title":"O5-1: Replication Is a First-Class Observable System","text":"<p>Every meaningful replication state MUST be: - Observable - Snapshot-bound - Deterministic - Explainable</p> <p>If replication cannot explain itself, it must refuse to proceed.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#3-mapping-to-dx-observability-api","title":"3. Mapping to DX Observability API","text":"<p>Phase 5 MUST use existing DX endpoints.</p> <p>No new endpoints are introduced unless strictly required.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#31-v1replication-primary-endpoint","title":"3.1 <code>/v1/replication</code> \u2014 Primary Endpoint","text":"<p>This endpoint is the authoritative replication view.</p> <p>It MUST expose:</p> Field Meaning <code>role</code> <code>primary</code> or <code>replica</code> <code>replica_state</code> Global replica state machine state <code>replica_commit_id</code> Last applied CommitId <code>primary_commit_id</code> Last known primary CommitId <code>wal_received_offset</code> Highest received WAL offset <code>wal_validated_offset</code> Highest validated WAL offset <code>wal_applied_offset</code> Highest applied WAL offset <code>snapshot_bootstrap_state</code> NotStarted / InProgress / Complete <code>read_safety</code> Safe / Unsafe <code>blocking_reason</code> Explicit reason if blocked <p>No field may be inferred heuristically.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#32-v1wal-replica-context","title":"3.2 <code>/v1/wal</code> \u2014 Replica Context","text":"<p>When queried on a replica, <code>/v1/wal</code> MUST:</p> <ul> <li>Distinguish between:</li> <li>Received WAL</li> <li>Validated WAL</li> <li>Applied WAL</li> <li>Show offsets for each stage</li> <li>Clearly mark gaps or validation failures</li> </ul>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#33-v1mvcc-replica-context","title":"3.3 <code>/v1/mvcc</code> \u2014 Replica Context","text":"<p>On replicas, <code>/v1/mvcc</code> MUST:</p> <ul> <li>Show replica CommitId</li> <li>Show active snapshots (if any)</li> <li>Explicitly state if reads are blocked</li> </ul> <p>Replica MVCC is not special. It must look identical to primary MVCC when read-safe.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#4-mapping-to-explanation-endpoints","title":"4. Mapping to Explanation Endpoints","text":"<p>Replication explanations MUST use Phase 4 explanation model.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#41-v1explainreplication","title":"4.1 <code>/v1/explain/replication</code>","text":"<p>Explanation Type: <code>replication.safety</code></p> <p>This endpoint MUST explain:</p> <ul> <li>Why the replica is safe or unsafe for reads</li> <li>Which invariants are satisfied</li> <li>Which invariant (if any) is violated</li> </ul> <p>Evidence MUST include: - WAL prefix comparison - CommitId comparison - Replica global state</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#42-v1explainrecovery-replica","title":"4.2 <code>/v1/explain/recovery</code> (Replica)","text":"<p>When invoked on a replica, this endpoint MUST:</p> <ul> <li>Explain replica recovery steps</li> <li>Include WAL replay range</li> <li>Include snapshot usage (if any)</li> <li>Include failure reasons if recovery halted</li> </ul>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#43-v1explainread-replica","title":"4.3 <code>/v1/explain/read</code> (Replica)","text":"<p>For replica reads, this endpoint MUST:</p> <ul> <li>Use identical MVCC rules</li> <li>Explicitly state why read is allowed or refused</li> <li>Reference replica state and CommitId</li> </ul> <p>No replica-specific shortcuts are allowed.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#5-required-observability-per-runtime-component","title":"5. Required Observability per Runtime Component","text":"Component Observable State Replica Supervisor Global state, blocking reason WAL Receiver Last received offset WAL Validator Last validated offset WAL Applier Last applied offset Snapshot Bootstrap State + cut CommitId Read Safety Gate Safety decision + proof <p>Hidden state is forbidden.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#6-failure-visibility-requirements","title":"6. Failure Visibility Requirements","text":"<p>For every failure in <code>OBSERVABILITY_FAILURE_MATRIX.md</code>:</p> <ul> <li>The failure MUST be visible via DX</li> <li>The failure MUST have an explanation</li> <li>The system MUST NOT auto-clear failure state</li> </ul> <p>Operators and developers must see why replication stopped.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#7-determinism-requirements","title":"7. Determinism Requirements","text":"<p>Given identical persisted state:</p> <ul> <li>Observability output MUST be identical</li> <li>Explanation output MUST be identical</li> <li>Ordering of fields MUST be stable</li> </ul> <p>No timestamps or timing-derived fields allowed.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#8-forbidden-observability-patterns","title":"8. Forbidden Observability Patterns","text":"<p>Explicitly forbidden:</p> <ul> <li>\u201cLag OK\u201d indicators</li> <li>Progress bars without evidence</li> <li>Health summaries</li> <li>Auto-healing messages</li> <li>Hiding blocked states</li> </ul> <p>If replication is unhealthy, it must look unhealthy.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#9-testing-requirements","title":"9. Testing Requirements","text":"<p>Replication observability MUST be tested for:</p> <ul> <li>Correct state exposure</li> <li>Correct blocking reasons</li> <li>Correct explanation evidence</li> <li>Deterministic output across restarts</li> </ul> <p>Observability tests are correctness tests.</p>"},{"location":"OBSERVABILITY_OBSERVABILITY_MAPPING/#10-final-rule","title":"10. Final Rule","text":"<p>If replication state cannot be observed, replication correctness cannot be proven.</p> <p>Observability is part of the replication contract.</p> <p>END OF DOCUMENT</p>"},{"location":"OBSERVABILITY_READINESS/","title":"PHASE 5 \u2014 READINESS &amp; FREEZE","text":""},{"location":"OBSERVABILITY_READINESS/#status","title":"Status","text":"<ul> <li>Phase: 5</li> <li>Authority: Normative (Closure Document)</li> <li>Scope: Replication implementation readiness and freeze</li> <li>Depends on:</li> <li><code>OBSERVABILITY_VISION.md</code></li> <li><code>OBSERVABILITY_INVARIANTS.md</code></li> <li><code>OBSERVABILITY_IMPLEMENTATION_ORDER.md</code></li> <li><code>REPLICATION_RUNTIME_ARCHITECTURE.md</code></li> <li><code>OBSERVABILITY_FAILURE_MATRIX.md</code></li> <li><code>OBSERVABILITY_TESTING_STRATEGY.md</code></li> <li><code>OBSERVABILITY_OBSERVABILITY_MAPPING.md</code></li> <li>All <code>REPL_*</code>, <code>MVCC_*</code>, and <code>CORE_*</code> documents</li> </ul> <p>This document formally declares whether Phase 5 is complete, correct, and frozen.</p>"},{"location":"OBSERVABILITY_READINESS/#1-purpose","title":"1. Purpose","text":"<p>Phase 5 is the point where AeroDB becomes actually replicated, not just designed to be.</p> <p>This document exists to:</p> <ul> <li>Prevent \u201calmost done\u201d replication</li> <li>Prevent silent semantic drift after implementation</li> <li>Provide a hard correctness boundary</li> <li>Declare replication semantics implemented and frozen</li> </ul> <p>No new replication behavior may be introduced after this document is accepted.</p>"},{"location":"OBSERVABILITY_READINESS/#2-readiness-definition","title":"2. Readiness Definition","text":"<p>Phase 5 is considered READY only if:</p> <ul> <li>All replication semantics from Phase 2B are implemented</li> <li>No Phase 2B or Phase 3 invariants are weakened</li> <li>Phase 4 observability fully covers replication</li> <li>All failure modes are tested and explained</li> <li>Replication behavior is deterministic and auditable</li> </ul> <p>Readiness is binary. There is no \u201cmostly ready\u201d.</p>"},{"location":"OBSERVABILITY_READINESS/#3-mandatory-completion-checklist","title":"3. Mandatory Completion Checklist","text":"<p>All items below MUST be satisfied.</p>"},{"location":"OBSERVABILITY_READINESS/#31-implementation-completeness","title":"3.1 Implementation Completeness","text":"<ul> <li> Primary / Replica role enforcement implemented</li> <li> WAL shipping implemented (prefix rule enforced)</li> <li> WAL validation implemented (checksum + continuity)</li> <li> WAL application implemented (crash-safe)</li> <li> Snapshot bootstrap implemented</li> <li> Replica recovery implemented</li> <li> Replica read-safety gate implemented</li> <li> Replication disablement path verified</li> </ul>"},{"location":"OBSERVABILITY_READINESS/#32-invariant-compliance","title":"3.2 Invariant Compliance","text":"<ul> <li> All <code>OBSERVABILITY_INVARIANTS.md</code> invariants enforced</li> <li> All <code>REPL_INVARIANTS.md</code> invariants enforced</li> <li> No temporary invariant violations exist</li> <li> No heuristic or timing-based logic introduced</li> </ul>"},{"location":"OBSERVABILITY_READINESS/#33-failure-coverage","title":"3.3 Failure Coverage","text":"<ul> <li> All scenarios in <code>OBSERVABILITY_FAILURE_MATRIX.md</code> tested</li> <li> Crash injection verified for:</li> <li>WAL receive</li> <li>WAL validation</li> <li>WAL apply</li> <li>Snapshot bootstrap</li> <li>Replica recovery</li> <li> No silent failure paths exist</li> </ul>"},{"location":"OBSERVABILITY_READINESS/#34-testing-coverage","title":"3.4 Testing Coverage","text":"<ul> <li> All tests in <code>OBSERVABILITY_TESTING_STRATEGY.md</code> implemented</li> <li> Crash tests deterministic</li> <li> No skipped or ignored tests</li> <li> Phase 0\u20134 tests unchanged and still passing</li> </ul>"},{"location":"OBSERVABILITY_READINESS/#35-observability-explainability","title":"3.5 Observability &amp; Explainability","text":"<ul> <li> <code>/v1/replication</code> fully implemented</li> <li> Replication states observable</li> <li> Blocking reasons explicit</li> <li> <code>/v1/explain/replication</code> correct and evidence-based</li> <li> Replica recovery explainable</li> <li> Read-safety decisions explainable</li> </ul>"},{"location":"OBSERVABILITY_READINESS/#36-determinism-replay","title":"3.6 Determinism &amp; Replay","text":"<ul> <li> Replica restart produces identical state</li> <li> WAL replay deterministic</li> <li> Snapshot + WAL continuity verified</li> <li> Observability output deterministic</li> </ul>"},{"location":"OBSERVABILITY_READINESS/#4-explicit-non-readiness-conditions","title":"4. Explicit Non-Readiness Conditions","text":"<p>Phase 5 MUST be considered NOT READY if any of the following are true:</p> <ul> <li>Replica serves reads without proof</li> <li>WAL prefix rule is violated even transiently</li> <li>Validation and application overlap incorrectly</li> <li>Failure states auto-clear without explanation</li> <li>Any replication behavior depends on timing</li> <li>Any invariant is \u201cusually\u201d but not always true</li> </ul> <p>If any apply, Phase 5 cannot be frozen.</p>"},{"location":"OBSERVABILITY_READINESS/#5-freeze-declaration","title":"5. Freeze Declaration","text":"<p>Once all checklist items are satisfied, the following show be declared:</p> <p>Phase 5 Replication Implementation is COMPLETE and FROZEN.</p> <p>After freeze:</p> <ul> <li>Replication semantics MUST NOT change</li> <li>New replication features require Phase 6</li> <li>Any bug fix must preserve semantics</li> <li>Any deviation requires a new audit</li> </ul>"},{"location":"OBSERVABILITY_READINESS/#6-post-freeze-guarantees","title":"6. Post-Freeze Guarantees","text":"<p>After Phase 5 freeze:</p> <ul> <li>AeroDB supports correct, deterministic replication</li> <li>Replication behavior is observable and explainable</li> <li>Replica reads are safe or explicitly refused</li> <li>Failures are loud and diagnosable</li> </ul> <p>Availability is still secondary. Correctness is absolute.</p>"},{"location":"OBSERVABILITY_READINESS/#7-forward-boundary","title":"7. Forward Boundary","text":"<p>After Phase 5, the next allowed phases are:</p> <ul> <li>Phase 6: Failover &amp; Promotion</li> <li>Phase 6: Security &amp; Hardening</li> <li>Phase 6: Operational Tooling</li> </ul> <p>None of these may begin until Phase 5 is frozen.</p>"},{"location":"OBSERVABILITY_READINESS/#8-final-rule","title":"8. Final Rule","text":"<p>Replication that cannot be frozen is replication that cannot be trusted.</p> <p>This document exists to draw the line.</p> <p>END OF DOCUMENT</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/","title":"PHASE 5 \u2014 TESTING STRATEGY (REPLICATION IMPLEMENTATION)","text":""},{"location":"OBSERVABILITY_TESTING_STRATEGY/#status","title":"Status","text":"<ul> <li>Phase: 5</li> <li>Authority: Normative</li> <li>Scope: All replication-related tests</li> <li>Depends on:</li> <li><code>OBSERVABILITY_VISION.md</code></li> <li><code>OBSERVABILITY_INVARIANTS.md</code></li> <li><code>OBSERVABILITY_IMPLEMENTATION_ORDER.md</code></li> <li><code>REPLICATION_RUNTIME_ARCHITECTURE.md</code></li> <li><code>OBSERVABILITY_FAILURE_MATRIX.md</code></li> <li><code>REPL_*</code> specifications</li> <li><code>MVCC_*</code> specifications</li> <li><code>CORE_INVARIANTS.md</code></li> <li><code>CRASH_TESTING.md</code></li> </ul> <p>This document defines how replication correctness is proven.</p> <p>If a behavior is not tested according to this strategy, it is not considered correct.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#1-purpose","title":"1. Purpose","text":"<p>Replication bugs are rarely logical. They are almost always: - Ordering bugs - Crash-window bugs - Partial-state bugs - Recovery bugs</p> <p>This testing strategy exists to ensure that: - Every replication invariant is enforced - Every failure mode is exercised - Every outcome is deterministic and explainable</p> <p>Tests are first-class correctness artifacts.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#2-testing-philosophy","title":"2. Testing Philosophy","text":""},{"location":"OBSERVABILITY_TESTING_STRATEGY/#t-1-tests-are-proof-not-examples","title":"T-1: Tests Are Proof, Not Examples","text":"<p>Replication tests MUST: - Prove invariants - Prove crash safety - Prove determinism</p> <p>\u201cHappy path only\u201d tests are insufficient.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#t-2-crash-testing-is-mandatory","title":"T-2: Crash Testing Is Mandatory","text":"<p>Any replication logic that: - Writes state - Applies WAL - Advances CommitId</p> <p>MUST be tested under crash injection.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#t-3-determinism-is-enforced","title":"T-3: Determinism Is Enforced","text":"<p>Given identical inputs and crash points: - Final state MUST be identical - Explanations MUST be identical</p> <p>Non-deterministic outcomes are failures.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#3-test-layers-mandatory","title":"3. Test Layers (Mandatory)","text":"<p>Replication tests are organized into five layers. All layers MUST exist.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#4-layer-1-unit-tests-pure-logic","title":"4. Layer 1 \u2014 Unit Tests (Pure Logic)","text":""},{"location":"OBSERVABILITY_TESTING_STRATEGY/#scope","title":"Scope","text":"<ul> <li>State machines</li> <li>Read-safety predicates</li> <li>WAL ordering logic</li> <li>Validation rules</li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#requirements","title":"Requirements","text":"<ul> <li>No IO</li> <li>No threads</li> <li>No timing assumptions</li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#examples","title":"Examples","text":"<ul> <li>WAL prefix validation</li> <li>CommitId monotonicity checks</li> <li>Read-safety predicate evaluation</li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#5-layer-2-component-tests-isolated-io","title":"5. Layer 2 \u2014 Component Tests (Isolated IO)","text":""},{"location":"OBSERVABILITY_TESTING_STRATEGY/#scope_1","title":"Scope","text":"<ul> <li>WAL Receiver</li> <li>WAL Validator</li> <li>WAL Applier</li> <li>Replica State Store</li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#requirements_1","title":"Requirements","text":"<ul> <li>Single component under test</li> <li>Explicit inputs</li> <li>Explicit outputs</li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#mandatory-scenarios","title":"Mandatory Scenarios","text":"<ul> <li>Invalid WAL rejection</li> <li>Partial WAL persistence</li> <li>Crash before/after fsync</li> <li>Idempotent WAL replay</li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#6-layer-3-integration-tests-primary-replica","title":"6. Layer 3 \u2014 Integration Tests (Primary \u2194 Replica)","text":""},{"location":"OBSERVABILITY_TESTING_STRATEGY/#scope_2","title":"Scope","text":"<ul> <li>End-to-end replication flow</li> <li>WAL shipping</li> <li>Snapshot bootstrap</li> <li>Replica recovery</li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#mandatory-scenarios_1","title":"Mandatory Scenarios","text":"<ul> <li>Fresh replica bootstrap</li> <li>Replica catch-up from WAL</li> <li>Primary crash + replica recovery</li> <li>Replica crash mid-apply</li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#requirements_2","title":"Requirements","text":"<ul> <li>Deterministic setup</li> <li>Explicit sequencing</li> <li>No background retries</li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#7-layer-4-crash-matrix-tests-critical","title":"7. Layer 4 \u2014 Crash Matrix Tests (Critical)","text":""},{"location":"OBSERVABILITY_TESTING_STRATEGY/#scope_3","title":"Scope","text":"<ul> <li>All crash points defined in <code>OBSERVABILITY_FAILURE_MATRIX.md</code></li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#mandatory-crash-points","title":"Mandatory Crash Points","text":"<ul> <li>Before WAL persist</li> <li>After WAL persist</li> <li>During WAL validation</li> <li>During WAL application</li> <li>During snapshot transfer</li> <li>During replica recovery</li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#requirements_3","title":"Requirements","text":"<p>For each crash point: 1. Inject crash 2. Restart system 3. Verify invariants 4. Verify explanation output</p> <p>Skipping a crash point is forbidden.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#8-layer-5-explanation-verification-tests","title":"8. Layer 5 \u2014 Explanation Verification Tests","text":""},{"location":"OBSERVABILITY_TESTING_STRATEGY/#scope_4","title":"Scope","text":"<ul> <li><code>/v1/explain/replication</code></li> <li><code>/v1/explain/recovery</code></li> <li>Read-safety explanations</li> </ul>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#requirements_4","title":"Requirements","text":"<ul> <li>Explanations must:</li> <li>Reference real WAL offsets</li> <li>Reference real CommitIds</li> <li>Reference invariant IDs</li> <li>No heuristic language</li> <li>No missing evidence</li> </ul> <p>Tests MUST fail if explanations are incomplete or misleading.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#9-required-test-matrix-authoritative","title":"9. Required Test Matrix (Authoritative)","text":"<p>Every test MUST map to at least one invariant.</p> Invariant Test Required P5-I4 (WAL prefix) \u2714 P5-I5 (Validate before apply) \u2714 P5-I6 (CommitId authority) \u2714 P5-I8 (Snapshot cut) \u2714 P5-I9 (Snapshot/WAL continuity) \u2714 P5-I11 (Crash safety) \u2714 P5-I12 (Read safety) \u2714 P5-I14 (Observability) \u2714 <p>No invariant may remain untested.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#10-forbidden-testing-patterns","title":"10. Forbidden Testing Patterns","text":"<p>Explicitly forbidden:</p> <ul> <li>Sleeping to \u201cwait\u201d for replication</li> <li>Time-based assertions</li> <li>Randomized fuzz without determinism</li> <li>Ignoring failed tests \u201ctemporarily\u201d</li> <li>Disabling crash tests for speed</li> </ul> <p>If a test is flaky, the implementation is wrong.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#11-test-execution-rules","title":"11. Test Execution Rules","text":"<ul> <li>All replication tests MUST run in CI</li> <li>Crash tests MUST run deterministically</li> <li>Tests MUST pass with replication disabled</li> <li>Phase 0\u20134 tests MUST remain unchanged</li> </ul> <p>Replication MUST NOT weaken existing guarantees.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#12-completion-criteria-testing","title":"12. Completion Criteria (Testing)","text":"<p>Phase 5 testing is complete only when:</p> <ul> <li>All test layers exist</li> <li>All failure scenarios are covered</li> <li>All explanations are validated</li> <li>Test suite is deterministic</li> <li>No tests are ignored or skipped</li> </ul> <p>Only then may replication be considered implemented.</p>"},{"location":"OBSERVABILITY_TESTING_STRATEGY/#13-final-rule","title":"13. Final Rule","text":"<p>If replication correctness is not testable, it is not correct.</p> <p>Tests are not optional. They are the proof.</p> <p>END OF DOCUMENT</p>"},{"location":"OBSERVABILITY_VISION/","title":"PHASE 5 \u2014 REPLICATION IMPLEMENTATION","text":""},{"location":"OBSERVABILITY_VISION/#status","title":"Status","text":"<ul> <li>Phase: 5</li> <li>State: Implementation</li> <li>Authority: Normative</li> <li>Depends on:</li> <li>Phase 0\u20134 (Frozen and Audited)</li> <li>Replication semantics defined in Phase 2B</li> <li>Observability &amp; Explanation infrastructure from Phase 4</li> </ul> <p>Phase 5 implements replication exactly as specified. It introduces no new replication semantics.</p>"},{"location":"OBSERVABILITY_VISION/#1-purpose-of-phase-5","title":"1. Purpose of Phase 5","text":"<p>Phase 5 exists to answer one question:</p> <p>\u201cCan AeroDB\u2019s replication semantics, already proven on paper, be implemented faithfully, observably, and deterministically?\u201d</p> <p>This phase turns frozen replication specifications into running code.</p>"},{"location":"OBSERVABILITY_VISION/#2-what-phase-5-is-and-is-not","title":"2. What Phase 5 Is (and Is Not)","text":""},{"location":"OBSERVABILITY_VISION/#phase-5-is","title":"Phase 5 IS","text":"<ul> <li>A faithful implementation of Phase 2B replication semantics</li> <li>Single-writer, primary/replica replication</li> <li>WAL-based log shipping</li> <li>Snapshot-based bootstrap</li> <li>Deterministic replica recovery</li> <li>Observable and explainable replication state</li> </ul>"},{"location":"OBSERVABILITY_VISION/#phase-5-is-not","title":"Phase 5 IS NOT","text":"<ul> <li>A redesign of replication</li> <li>Leader election</li> <li>Automatic failover</li> <li>Multi-primary writes</li> <li>Consensus protocols (Raft/Paxos)</li> <li>Availability-first behavior</li> <li>Performance tuning beyond correctness</li> </ul> <p>If it changes replication meaning, it does not belong in Phase 5.</p>"},{"location":"OBSERVABILITY_VISION/#3-replication-model-frozen-reference","title":"3. Replication Model (Frozen Reference)","text":"<p>Phase 5 implements the following unchanged model:</p> <ul> <li>One Primary</li> <li>One or more Replicas</li> <li>CommitId authority resides only on the Primary</li> <li>Replicas apply WAL as a strict prefix</li> <li>Replicas never acknowledge writes</li> <li>Replica reads are allowed only when MVCC-safe</li> </ul> <p>All of this is already defined. Phase 5 makes it real.</p>"},{"location":"OBSERVABILITY_VISION/#4-phase-5-core-principles","title":"4. Phase 5 Core Principles","text":""},{"location":"OBSERVABILITY_VISION/#p5-1-semantics-are-frozen","title":"P5-1: Semantics Are Frozen","text":"<p>Replication behavior is governed by: - <code>REPL_VISION.md</code> - <code>REPL_INVARIANTS.md</code> - <code>REPL_PROOFS.md</code></p> <p>Phase 5 MUST NOT: - Add rules - Remove rules - Infer rules</p> <p>Implementation follows spec verbatim.</p>"},{"location":"OBSERVABILITY_VISION/#p5-2-determinism-over-availability","title":"P5-2: Determinism Over Availability","text":"<p>Replication prioritizes: 1. Correctness 2. Determinism 3. Explicit failure 4. Availability (last)</p> <p>If replication cannot proceed safely: - It must stop - It must explain why</p>"},{"location":"OBSERVABILITY_VISION/#p5-3-explicit-failure-over-silent-degradation","title":"P5-3: Explicit Failure Over Silent Degradation","text":"<p>Replication failures MUST be: - Detected - Surfaced - Observable - Explainable</p> <p>There is no \u201cbest effort\u201d replication.</p>"},{"location":"OBSERVABILITY_VISION/#5-phase-5-scope","title":"5. Phase 5 Scope","text":""},{"location":"OBSERVABILITY_VISION/#51-in-scope","title":"5.1 In Scope","text":"<p>Phase 5 implements:</p> <ul> <li>WAL segment shipping from Primary to Replicas</li> <li>Replica WAL validation (checksums, ordering)</li> <li>Replica WAL application</li> <li>Snapshot bootstrap (MVCC cut + WAL resume)</li> <li>Replica restart and recovery</li> <li>Replica read-safety enforcement</li> <li>Replication observability</li> <li>Replication explanations (why a replica is / is not safe)</li> </ul>"},{"location":"OBSERVABILITY_VISION/#52-explicitly-out-of-scope","title":"5.2 Explicitly Out of Scope","text":"<p>Phase 5 does NOT include:</p> <ul> <li>Automatic role changes</li> <li>Promotion of replicas</li> <li>Failover orchestration</li> <li>Split-brain handling beyond detection</li> <li>Network encryption</li> <li>Authentication / authorization</li> <li>Dynamic cluster membership</li> </ul> <p>These belong to future phases.</p>"},{"location":"OBSERVABILITY_VISION/#6-interaction-with-earlier-phases","title":"6. Interaction with Earlier Phases","text":""},{"location":"OBSERVABILITY_VISION/#phase-1-core","title":"Phase 1 (Core)","text":"<ul> <li>WAL format is unchanged</li> <li>Storage format is unchanged</li> <li>Recovery logic is reused</li> </ul>"},{"location":"OBSERVABILITY_VISION/#phase-2a-mvcc","title":"Phase 2A (MVCC)","text":"<ul> <li>Snapshot isolation rules remain authoritative</li> <li>Replica reads use identical MVCC rules</li> </ul>"},{"location":"OBSERVABILITY_VISION/#phase-3-performance","title":"Phase 3 (Performance)","text":"<ul> <li>Replication may benefit from existing optimizations</li> <li>No new optimizations are introduced</li> </ul>"},{"location":"OBSERVABILITY_VISION/#phase-4-dx","title":"Phase 4 (DX)","text":"<ul> <li>Replication state is fully observable</li> <li>Replication behavior is explainable</li> <li>No replication control via DX</li> </ul>"},{"location":"OBSERVABILITY_VISION/#7-phase-5-invariants-high-level","title":"7. Phase 5 Invariants (High-Level)","text":"<p>Phase 5 MUST preserve:</p> <ul> <li>WAL prefix rule</li> <li>CommitId monotonicity</li> <li>Deterministic replay</li> <li>Snapshot consistency</li> <li>Replica derivability</li> <li>No acknowledged write loss</li> <li>No silent divergence</li> </ul> <p>Violation of any invariant is a Phase 5 failure.</p>"},{"location":"OBSERVABILITY_VISION/#8-phase-5-success-criteria","title":"8. Phase 5 Success Criteria","text":"<p>Phase 5 is successful if:</p> <ul> <li>A replica can be bootstrapped from scratch</li> <li>A replica can crash and recover deterministically</li> <li>Replica reads are allowed only when safe</li> <li>Replication lag is observable</li> <li>Replication failures are explicit and explainable</li> <li>Primary behavior is unchanged</li> </ul> <p>All of this must be provable via tests and explanations.</p>"},{"location":"OBSERVABILITY_VISION/#9-phase-5-failure-philosophy","title":"9. Phase 5 Failure Philosophy","text":"<p>Replication failure is not exceptional. It is expected and must be handled explicitly.</p> <p>If replication cannot guarantee correctness: - The replica must refuse to serve reads - The system must explain why</p> <p>Availability is optional. Correctness is not.</p>"},{"location":"OBSERVABILITY_VISION/#10-deliverables-of-phase-5","title":"10. Deliverables of Phase 5","text":"<p>Phase 5 produces:</p> <ul> <li>Replication runtime implementation</li> <li>Replica bootstrap mechanism</li> <li>Replica recovery logic</li> <li>Replication observability endpoints</li> <li>Replication explanation artifacts</li> <li>Exhaustive replication tests</li> </ul> <p>No UI or operational tooling is required in this phase.</p>"},{"location":"OBSERVABILITY_VISION/#11-phase-5-completion-rules","title":"11. Phase 5 Completion Rules","text":"<p>Phase 5 is complete when:</p> <ul> <li>All replication specs are implemented</li> <li>All replication invariants are enforced</li> <li>All failure modes are tested</li> <li>Replication explanations are accurate</li> <li>Phase 0\u20134 behavior remains unchanged</li> </ul> <p>Only then may replication be considered \u201cimplemented\u201d.</p>"},{"location":"OBSERVABILITY_VISION/#12-guiding-statement","title":"12. Guiding Statement","text":"<p>Phase 5 does not make AeroDB highly available. It makes AeroDB correctly replicated.</p> <p>Correct replication is more valuable than fast replication. Explainable replication is more valuable than opaque replication.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_BASELINE/","title":"PERFORMANCE BASELINE \u2014 PHASE 3","text":""},{"location":"PERF_BASELINE/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: Baseline-only (no optimization)</li> <li>Dependency:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> </ul> <p>This document defines the reference execution behavior against which all Phase 3 optimizations are proven equivalent.</p> <p>If baseline behavior is not explicitly described here, it MUST NOT be optimized.</p>"},{"location":"PERF_BASELINE/#1-purpose","title":"1. Purpose","text":"<p>The purpose of this document is to:</p> <ul> <li>Freeze the current execution model</li> <li>Identify cost centers without changing behavior</li> <li>Provide a canonical reference for equivalence proofs</li> <li>Prevent accidental semantic drift during optimization</li> </ul> <p>This document contains no optimizations, only descriptions.</p>"},{"location":"PERF_BASELINE/#2-baseline-execution-model-overview","title":"2. Baseline Execution Model Overview","text":"<p>AeroDB baseline behavior is defined by:</p> <ul> <li>Single-node execution (Phase 1)</li> <li>MVCC-enabled visibility (Phase 2A)</li> <li>Replication-compatible semantics (Phase 2B)</li> <li>Deterministic WAL-governed state transitions</li> </ul> <p>Execution is synchronous, explicit, and ordered.</p>"},{"location":"PERF_BASELINE/#3-baseline-write-path","title":"3. Baseline Write Path","text":""},{"location":"PERF_BASELINE/#31-client-write-request-lifecycle","title":"3.1 Client Write Request Lifecycle","text":"<p>For a single write request:</p> <ol> <li>Client submits document write</li> <li>Schema validation is performed (strict, versioned)</li> <li>MVCC version object is created (uncommitted)</li> <li>WAL record is constructed</li> <li>WAL record is written to disk</li> <li>WAL record is fsync\u2019ed</li> <li>CommitId is assigned</li> <li>Write is acknowledged to client</li> <li>In-memory indexes are updated</li> <li>Version becomes visible to eligible snapshots</li> </ol> <p>Critical Rule: Acknowledgment occurs only after fsync completion.</p>"},{"location":"PERF_BASELINE/#32-wal-characteristics-baseline","title":"3.2 WAL Characteristics (Baseline)","text":"<ul> <li>WAL records are:</li> <li>Appended sequentially</li> <li>Checksummed individually</li> <li>Written one logical commit at a time</li> <li>fsync is performed per acknowledged commit</li> <li>No grouping, batching, or coalescing occurs</li> </ul>"},{"location":"PERF_BASELINE/#33-write-cost-centers","title":"3.3 Write Cost Centers","text":"<p>Primary contributors:</p> <ul> <li>fsync latency</li> <li>WAL serialization</li> <li>Checksum computation</li> <li>Schema validation</li> <li>In-memory index updates</li> </ul> <p>No cost is amortized across requests.</p>"},{"location":"PERF_BASELINE/#4-baseline-read-path","title":"4. Baseline Read Path","text":""},{"location":"PERF_BASELINE/#41-snapshot-creation","title":"4.1 Snapshot Creation","text":"<ul> <li>Snapshot is created with a fixed <code>visible_commit_id</code></li> <li>Snapshot does not change over time</li> <li>Snapshot is immutable</li> </ul>"},{"location":"PERF_BASELINE/#42-document-read-execution","title":"4.2 Document Read Execution","text":"<p>For each read:</p> <ol> <li>Snapshot visibility rules are applied</li> <li>Version chain is traversed</li> <li>First visible version is selected</li> <li>Document is materialized</li> <li>Result is returned</li> </ol> <p>No caching beyond existing structures is assumed.</p>"},{"location":"PERF_BASELINE/#43-read-cost-centers","title":"4.3 Read Cost Centers","text":"<p>Primary contributors:</p> <ul> <li>Version chain traversal</li> <li>Snapshot visibility checks</li> <li>Document materialization</li> <li>Index lookups (if applicable)</li> </ul>"},{"location":"PERF_BASELINE/#5-baseline-query-execution","title":"5. Baseline Query Execution","text":""},{"location":"PERF_BASELINE/#51-query-planning","title":"5.1 Query Planning","text":"<ul> <li>Query is parsed deterministically</li> <li>Planner produces a bounded plan</li> <li>No adaptive planning</li> <li>No runtime plan modification</li> </ul>"},{"location":"PERF_BASELINE/#52-query-execution","title":"5.2 Query Execution","text":"<ul> <li>Execution follows plan strictly</li> <li>No speculative execution</li> <li>No parallelism unless explicitly specified by Phase 1</li> <li>All bounds are enforced</li> </ul>"},{"location":"PERF_BASELINE/#6-baseline-mvcc-behavior","title":"6. Baseline MVCC Behavior","text":""},{"location":"PERF_BASELINE/#61-commitid-assignment","title":"6.1 CommitId Assignment","text":"<ul> <li>CommitId is assigned only after WAL fsync</li> <li>CommitIds are strictly increasing</li> <li>No speculative or provisional IDs</li> </ul>"},{"location":"PERF_BASELINE/#62-visibility-rules","title":"6.2 Visibility Rules","text":"<ul> <li>Snapshot sees all commits \u2264 visible_commit_id</li> <li>No snapshot sees partial commits</li> <li>Visibility is deterministic and reproducible</li> </ul>"},{"location":"PERF_BASELINE/#63-garbage-collection-baseline","title":"6.3 Garbage Collection (Baseline)","text":"<ul> <li>GC is WAL-governed</li> <li>GC does not run opportunistically</li> <li>GC decisions are deterministic</li> </ul>"},{"location":"PERF_BASELINE/#7-baseline-snapshot-checkpoint-behavior","title":"7. Baseline Snapshot &amp; Checkpoint Behavior","text":""},{"location":"PERF_BASELINE/#71-snapshot-creation","title":"7.1 Snapshot Creation","text":"<ul> <li>Snapshot captures a full MVCC-consistent view</li> <li>Snapshot is read-only</li> <li>Snapshot is manifest-driven</li> </ul>"},{"location":"PERF_BASELINE/#72-checkpoint-execution","title":"7.2 Checkpoint Execution","text":"<ol> <li>Snapshot is created</li> <li>Snapshot is persisted</li> <li>WAL truncation occurs only after snapshot durability</li> <li>No concurrent checkpoint pipelining</li> </ol>"},{"location":"PERF_BASELINE/#73-cost-centers","title":"7.3 Cost Centers","text":"<ul> <li>Snapshot I/O</li> <li>Manifest generation</li> <li>WAL truncation coordination</li> </ul>"},{"location":"PERF_BASELINE/#8-baseline-recovery-path","title":"8. Baseline Recovery Path","text":""},{"location":"PERF_BASELINE/#81-startup-recovery","title":"8.1 Startup Recovery","text":"<ol> <li>Detect last checkpoint</li> <li>Load snapshot</li> <li>Replay WAL from checkpoint forward</li> <li>Validate checksums</li> <li>Rebuild in-memory indexes</li> </ol> <p>Recovery is:</p> <ul> <li>Deterministic</li> <li>Idempotent</li> <li>Single-threaded unless specified elsewhere</li> </ul>"},{"location":"PERF_BASELINE/#82-recovery-cost-centers","title":"8.2 Recovery Cost Centers","text":"<ul> <li>WAL replay time</li> <li>Index rebuild time</li> <li>Checksum validation</li> </ul>"},{"location":"PERF_BASELINE/#9-baseline-replication-interaction","title":"9. Baseline Replication Interaction","text":"<p>Even in single-node Phase 1:</p> <ul> <li>WAL format is replication-ready</li> <li>Commit ordering is authoritative</li> <li>No replication-specific shortcuts exist</li> </ul> <p>Baseline behavior MUST remain compatible with Phase 2B replication semantics.</p>"},{"location":"PERF_BASELINE/#10-baseline-observability","title":"10. Baseline Observability","text":"<ul> <li>Logs are emitted synchronously</li> <li>Metrics are collected deterministically</li> <li>Observability does not influence control flow</li> </ul> <p>Instrumentation cost exists but is not optimized.</p>"},{"location":"PERF_BASELINE/#11-baseline-resource-usage-characteristics","title":"11. Baseline Resource Usage Characteristics","text":""},{"location":"PERF_BASELINE/#111-cpu","title":"11.1 CPU","text":"<ul> <li>Serialization</li> <li>Validation</li> <li>Checksums</li> <li>Query execution</li> </ul>"},{"location":"PERF_BASELINE/#112-io","title":"11.2 I/O","text":"<ul> <li>WAL append</li> <li>fsync per commit</li> <li>Snapshot writes</li> <li>Checkpoint I/O</li> </ul>"},{"location":"PERF_BASELINE/#113-memory","title":"11.3 Memory","text":"<ul> <li>In-memory indexes</li> <li>MVCC version chains</li> <li>Snapshot metadata</li> </ul> <p>Memory usage is bounded and explicit.</p>"},{"location":"PERF_BASELINE/#12-explicit-non-assumptions","title":"12. Explicit Non-Assumptions","text":"<p>Baseline behavior does NOT assume:</p> <ul> <li>SSD-specific guarantees</li> <li>Write-back caching</li> <li>Power-loss protection</li> <li>Kernel-level reordering safety</li> <li>Fair scheduling</li> <li>Low latency fsync</li> </ul> <p>All correctness holds under worst-case assumptions.</p>"},{"location":"PERF_BASELINE/#13-baseline-as-proof-anchor","title":"13. Baseline as Proof Anchor","text":"<p>All Phase 3 optimizations MUST:</p> <ul> <li>Reference this document explicitly</li> <li>State which sections are affected</li> <li>Prove equivalence against this behavior</li> </ul> <p>If behavior is not described here, it MUST NOT be optimized.</p>"},{"location":"PERF_BASELINE/#14-final-rule","title":"14. Final Rule","text":"<p>Phase 3 does not optimize AeroDB. It optimizes this document\u2019s behavior, without changing it.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/","title":"CHECKPOINT PIPELINING \u2014 PHASE 3","text":""},{"location":"PERF_CHECKPOINT_PIPELINING/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: Checkpoint execution performance optimization</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>PERFORMANCE_BASELINE.md</li> <li>CRITICAL_PATHS.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> <li>FAILURE_MODEL_PHASE3.md</li> <li>ROLLBACK_AND_DISABLEMENT.md</li> <li>PERFORMANCE_OBSERVABILITY.md</li> </ul> <p>This document specifies Checkpoint Pipelining as a correctness-preserving optimization. If any rule herein cannot be proven, this optimization MUST NOT be implemented.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#1-purpose","title":"1. Purpose","text":"<p>Baseline AeroDB checkpointing is strictly sequential:</p> <ol> <li>Snapshot creation</li> <li>Snapshot persistence</li> <li>Snapshot fsync</li> <li>Checkpoint marker write</li> <li>WAL truncation</li> </ol> <p>This is maximally clear but can cause: - Long pause times - Poor write throughput during checkpoints</p> <p>Checkpoint Pipelining improves performance by: - Overlapping preparatory work with normal operation - While preserving all durability, ordering, and recovery semantics</p> <p>Checkpoint Pipelining does not: - Change snapshot semantics - Change checkpoint semantics - Change WAL truncation rules - Introduce speculative persistence</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#2-baseline-reference-normative","title":"2. Baseline Reference (Normative)","text":"<p>Baseline checkpoint behavior is defined in:</p> <ul> <li><code>PERFORMANCE_BASELINE.md</code> \u00a77</li> <li><code>CRITICAL_PATHS.md</code> \u00a75</li> </ul> <p>Baseline invariants:</p> <ul> <li>Snapshot represents a precise MVCC cut</li> <li>Snapshot must be fully durable before checkpoint marker</li> <li>WAL truncation occurs only after checkpoint durability</li> <li>Recovery selects last valid checkpoint deterministically</li> </ul> <p>These invariants MUST remain true.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#3-definition-of-checkpoint-pipelining","title":"3. Definition of Checkpoint Pipelining","text":""},{"location":"PERF_CHECKPOINT_PIPELINING/#31-conceptual-definition","title":"3.1 Conceptual Definition","text":"<p>Checkpoint Pipelining allows:</p> <p>Overlapping non-authoritative checkpoint preparation work with normal database operation, while deferring all authoritative durability decisions to the baseline ordering.</p> <p>Only work that has no correctness authority may be pipelined.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#32-explicit-non-definition-what-this-is-not","title":"3.2 Explicit Non-Definition (What This Is NOT)","text":"<p>Checkpoint Pipelining does NOT allow:</p> <ul> <li>Writing a checkpoint marker early</li> <li>Truncating WAL early</li> <li>Using incomplete snapshots</li> <li>Making snapshots visible before durability</li> <li>Time-based checkpoint triggers</li> <li>Background speculative cleanup</li> </ul> <p>If any step alters checkpoint authority, the optimization is invalid.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#4-mechanical-description","title":"4. Mechanical Description","text":""},{"location":"PERF_CHECKPOINT_PIPELINING/#41-baseline-checkpoint-path-simplified","title":"4.1 Baseline Checkpoint Path (Simplified)","text":"<ol> <li>Select checkpoint CommitId</li> <li>Freeze snapshot visibility</li> <li>Enumerate persistent state</li> <li>Write snapshot files</li> <li>fsync snapshot</li> <li>Write checkpoint marker</li> <li>fsync marker</li> <li>Truncate WAL</li> </ol>"},{"location":"PERF_CHECKPOINT_PIPELINING/#42-pipelined-checkpoint-path","title":"4.2 Pipelined Checkpoint Path","text":"<p>Checkpoint Pipelining permits the following restructuring:</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#phase-a-preparation-pipeline-eligible","title":"Phase A \u2014 Preparation (Pipeline-Eligible)","text":"<ul> <li>Snapshot CommitId selection</li> <li>Snapshot visibility freeze</li> <li>Snapshot enumeration</li> <li>Snapshot file writes (not yet authoritative)</li> </ul> <p>These steps: - Produce tentative snapshot artifacts - Have no recovery authority - May overlap with normal reads and writes</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#phase-b-authority-non-pipelined","title":"Phase B \u2014 Authority (Non-Pipelined)","text":"<ul> <li>Snapshot fsync</li> <li>Checkpoint marker write</li> <li>Checkpoint marker fsync</li> <li>WAL truncation</li> </ul> <p>These steps: - Remain strictly ordered - Are identical to baseline semantics - Define durability and recovery authority</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#43-pipeline-rules","title":"4.3 Pipeline Rules","text":"<ul> <li>Phase A work MUST be restart-discardable</li> <li>Phase B work MUST preserve baseline ordering exactly</li> <li>No read or write may observe Phase-A artifacts as authoritative</li> <li>No recovery logic may consult Phase-A artifacts</li> </ul>"},{"location":"PERF_CHECKPOINT_PIPELINING/#5-invariant-preservation-matrix","title":"5. Invariant Preservation Matrix","text":"<p>(Referenced from <code>PERF_INVARIANTS.md</code>)</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#durability","title":"Durability","text":"<ul> <li>D-1 (Acknowledged Write Durability): Preserved</li> <li>D-2 (Atomic Commit Boundary): Preserved</li> <li>D-3 (No Silent Downgrade): Preserved</li> </ul>"},{"location":"PERF_CHECKPOINT_PIPELINING/#determinism","title":"Determinism","text":"<ul> <li>DET-1 (Crash Determinism): Preserved</li> <li>DET-2 (Replay Equivalence): Preserved</li> <li>DET-3 (Bounded Execution): Preserved</li> </ul>"},{"location":"PERF_CHECKPOINT_PIPELINING/#mvcc","title":"MVCC","text":"<ul> <li>MVCC-1 (Snapshot Isolation): Preserved</li> <li>MVCC-2 (CommitId Authority): Preserved</li> <li>MVCC-3 (Version Chain Integrity): Preserved</li> </ul>"},{"location":"PERF_CHECKPOINT_PIPELINING/#replication","title":"Replication","text":"<ul> <li>REP-1, REP-2, REP-3: Preserved</li> </ul>"},{"location":"PERF_CHECKPOINT_PIPELINING/#failure-recovery","title":"Failure &amp; Recovery","text":"<ul> <li>FR-1, FR-2, FR-3: Preserved</li> </ul>"},{"location":"PERF_CHECKPOINT_PIPELINING/#observability","title":"Observability","text":"<ul> <li>OBS-1, OBS-2: Preserved</li> </ul>"},{"location":"PERF_CHECKPOINT_PIPELINING/#disablement","title":"Disablement","text":"<ul> <li>DIS-1, DIS-2, DIS-3: Preserved</li> </ul> <p>No invariant is weakened.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#6-semantic-equivalence-argument","title":"6. Semantic Equivalence Argument","text":"<p>Checkpoint Pipelining is semantically equivalent to baseline because:</p> <ul> <li>The checkpoint CommitId is identical</li> <li>The snapshot contents are identical</li> <li>The durability boundary is identical</li> <li>The checkpoint marker is written at the same semantic point</li> <li>WAL truncation rules are unchanged</li> </ul> <p>Pipelined work only prepares data earlier; it does not change when that data becomes authoritative.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#7-failure-matrix","title":"7. Failure Matrix","text":""},{"location":"PERF_CHECKPOINT_PIPELINING/#71-crash-during-phase-a-preparation","title":"7.1 Crash During Phase A (Preparation)","text":"<ul> <li>Baseline: no checkpoint</li> <li>Pipelined: no authoritative checkpoint</li> </ul> <p>Recovery: - Discards tentative snapshot artifacts - Uses previous checkpoint</p> <p>Equivalent.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#72-crash-between-phase-a-and-phase-b","title":"7.2 Crash Between Phase A and Phase B","text":"<ul> <li>No snapshot fsync</li> <li>No checkpoint marker</li> </ul> <p>Recovery: - Tentative snapshot ignored - WAL replay continues from last checkpoint</p> <p>Equivalent.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#73-crash-during-snapshot-fsync-phase-b","title":"7.3 Crash During Snapshot fsync (Phase B)","text":"<ul> <li>fsync incomplete \u2192 snapshot not durable</li> </ul> <p>Recovery: - Snapshot rejected - WAL replay used</p> <p>Equivalent.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#74-crash-after-snapshot-fsync-before-marker-fsync","title":"7.4 Crash After Snapshot fsync, Before Marker fsync","text":"<ul> <li>Snapshot durable</li> <li>Marker not durable</li> </ul> <p>Recovery: - Snapshot not selected - WAL replay used</p> <p>Equivalent.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#75-crash-after-marker-fsync-before-wal-truncation","title":"7.5 Crash After Marker fsync, Before WAL Truncation","text":"<ul> <li>Checkpoint valid</li> <li>WAL not yet truncated</li> </ul> <p>Recovery: - Checkpoint selected - WAL replay resumes correctly</p> <p>Equivalent.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#8-recovery-proof","title":"8. Recovery Proof","text":"<ul> <li>Recovery logic remains unchanged</li> <li>Recovery selects checkpoints based only on durable markers</li> <li>Tentative artifacts are ignored</li> <li>Replay behavior is deterministic</li> </ul> <p>No optimization-specific replay logic exists.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#9-disablement-rollback","title":"9. Disablement &amp; Rollback","text":""},{"location":"PERF_CHECKPOINT_PIPELINING/#91-disablement-mechanism","title":"9.1 Disablement Mechanism","text":"<p>Checkpoint Pipelining MUST be disableable via:</p> <ul> <li>Compile-time flag or</li> <li>Startup configuration</li> </ul> <p>Disablement restores: - Fully sequential checkpoint behavior</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#92-compatibility-proof","title":"9.2 Compatibility Proof","text":"<ul> <li>Snapshot format unchanged</li> <li>Checkpoint marker format unchanged</li> <li>WAL format unchanged</li> </ul> <p>Pipelined artifacts are compatible or discardable.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#93-no-ghost-state","title":"9.3 No Ghost State","text":"<ul> <li>Tentative snapshot artifacts are clearly marked or isolated</li> <li>No persistent flags indicate \u201cin-progress checkpoint\u201d</li> <li>No metadata leaks into recovery logic</li> </ul>"},{"location":"PERF_CHECKPOINT_PIPELINING/#10-observability","title":"10. Observability","text":"<p>Permitted metrics (passive only):</p> <ul> <li>checkpoint.pipeline.prepare_duration</li> <li>checkpoint.pipeline.authority_duration</li> <li>checkpoint.pipeline.aborted_count</li> </ul> <p>Metrics MUST NOT: - Influence scheduling - Influence pipeline depth - Influence checkpoint triggering</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#11-testing-requirements","title":"11. Testing Requirements","text":"<p>Checkpoint Pipelining MUST introduce:</p> <ul> <li>Crash tests at every pipeline boundary</li> <li>Recovery equivalence tests</li> <li>Disablement equivalence tests</li> <li>WAL truncation correctness tests</li> <li>Replication compatibility tests</li> </ul> <p>All existing tests MUST pass unmodified.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#12-explicit-non-goals","title":"12. Explicit Non-Goals","text":"<p>Checkpoint Pipelining does NOT aim to:</p> <ul> <li>Change checkpoint frequency</li> <li>Reduce checkpoint durability guarantees</li> <li>Make checkpoints incremental</li> <li>Introduce background checkpoints</li> </ul> <p>It improves overlap only.</p>"},{"location":"PERF_CHECKPOINT_PIPELINING/#13-final-rule","title":"13. Final Rule","text":"<p>A checkpoint is defined by when it becomes durable, not by when work starts.</p> <p>Checkpoint Pipelining is valid only if recovery, replicas, and clients cannot observe any difference.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_DISABLEMENT/","title":"ROLLBACK AND DISABLEMENT \u2014 PHASE 3","text":""},{"location":"PERF_DISABLEMENT/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: All Phase 3 optimizations</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> <li>FAILURE_MODEL_PHASE3.md</li> </ul> <p>This document defines the mandatory rollback, disablement, and compatibility rules for all Phase 3 performance optimizations.</p> <p>If an optimization cannot be disabled safely, it MUST NOT exist.</p>"},{"location":"PERF_DISABLEMENT/#1-purpose","title":"1. Purpose","text":"<p>Performance optimizations must never trap AeroDB in a state that:</p> <ul> <li>Requires data migration</li> <li>Requires cleanup tooling</li> <li>Requires replay special-casing</li> <li>Requires operator intervention</li> </ul> <p>This document ensures that: - Optimizations are optional - Data formats remain stable - Recovery remains unconditional</p>"},{"location":"PERF_DISABLEMENT/#2-definition-of-disablement","title":"2. Definition of Disablement","text":"<p>Disablement means:</p> <p>The optimization is turned off, and AeroDB behaves exactly like the Phase 2 baseline.</p> <p>Disablement MUST be possible: - Without rewriting WAL - Without rewriting snapshots - Without rewriting checkpoints - Without rewriting indexes</p> <p>Disablement is not \u201cbest effort\u201d. It is a hard requirement.</p>"},{"location":"PERF_DISABLEMENT/#3-forms-of-disablement","title":"3. Forms of Disablement","text":"<p>Phase 3 allows two and only two forms of disablement.</p>"},{"location":"PERF_DISABLEMENT/#31-compile-time-disablement","title":"3.1 Compile-Time Disablement","text":"<ul> <li>Optimization is conditionally compiled</li> <li>Code is entirely removed from the binary</li> <li>Baseline behavior is compiled instead</li> </ul> <p>Requirements: - Persistent formats MUST remain compatible - WAL replay MUST not branch on compile flags - No conditional decoding paths</p> <p>Compile-time disablement is preferred where feasible.</p>"},{"location":"PERF_DISABLEMENT/#32-startup-time-disablement","title":"3.2 Startup-Time Disablement","text":"<ul> <li>Optimization is toggled via configuration</li> <li>Decision is made before database opens</li> <li>Decision is immutable for the process lifetime</li> </ul> <p>Requirements: - No runtime toggling - No mid-flight switching - No partial activation</p> <p>Runtime enable/disable is forbidden.</p>"},{"location":"PERF_DISABLEMENT/#4-forbidden-disablement-models","title":"4. Forbidden Disablement Models","text":"<p>The following are explicitly forbidden:</p> <ul> <li>Disabling after startup</li> <li>Disabling based on load or timing</li> <li>Automatic fallback</li> <li>Progressive degradation</li> <li>Partial disablement</li> <li>Per-request switching</li> </ul> <p>If an optimization needs \u201cfallback logic\u201d, it is invalid.</p>"},{"location":"PERF_DISABLEMENT/#5-data-compatibility-invariants","title":"5. Data Compatibility Invariants","text":""},{"location":"PERF_DISABLEMENT/#51-wal-compatibility","title":"5.1 WAL Compatibility","text":"<ul> <li>WAL format MUST NOT change</li> <li>WAL records written with optimization enabled:</li> <li>MUST be replayable without optimization</li> <li>MUST preserve logical meaning</li> </ul> <p>Optimizations MAY: - Change how WAL is produced Optimizations MUST NOT: - Change what WAL means</p>"},{"location":"PERF_DISABLEMENT/#52-snapshot-compatibility","title":"5.2 Snapshot Compatibility","text":"<ul> <li>Snapshot file formats MUST remain unchanged</li> <li>Snapshot manifests MUST remain valid</li> <li>Snapshot readers MUST be identical</li> </ul> <p>Optimizations MUST NOT: - Add hidden snapshot metadata - Encode optimization state into snapshots</p>"},{"location":"PERF_DISABLEMENT/#53-checkpoint-compatibility","title":"5.3 Checkpoint Compatibility","text":"<ul> <li>Checkpoint markers MUST be unchanged</li> <li>WAL truncation logic MUST be identical</li> <li>Recovery selection logic MUST be unchanged</li> </ul>"},{"location":"PERF_DISABLEMENT/#6-no-persistent-optimization-state","title":"6. No Persistent Optimization State","text":""},{"location":"PERF_DISABLEMENT/#61-ghost-state-prohibition","title":"6.1 Ghost State Prohibition","text":"<p>Optimizations MUST NOT introduce:</p> <ul> <li>Hidden persistent files</li> <li>Undocumented metadata</li> <li>Implicit flags in WAL</li> <li>Implicit flags in snapshots</li> <li>Optimization-only markers</li> </ul> <p>All persistent state MUST be: - Explicit - Documented - Semantically neutral</p>"},{"location":"PERF_DISABLEMENT/#62-in-memory-state-rules","title":"6.2 In-Memory State Rules","text":"<p>Optimizations MAY introduce in-memory state ONLY if:</p> <ul> <li>It is reconstructible</li> <li>It is non-authoritative</li> <li>Its loss does not affect correctness</li> </ul> <p>In-memory state MUST be discardable at any time.</p>"},{"location":"PERF_DISABLEMENT/#7-recovery-behavior-under-disablement","title":"7. Recovery Behavior Under Disablement","text":"<p>Recovery MUST behave as follows:</p> <ul> <li>Recovery logic MUST NOT branch on optimization state</li> <li>WAL replay MUST be identical</li> <li>Snapshot loading MUST be identical</li> <li>Index rebuild MUST be identical</li> </ul> <p>If recovery behavior differs, the optimization is invalid.</p>"},{"location":"PERF_DISABLEMENT/#8-rolling-back-after-failure","title":"8. Rolling Back After Failure","text":"<p>If a crash occurs:</p> <ul> <li>During optimized execution</li> <li>With optimization enabled</li> </ul> <p>Then after restart:</p> <ul> <li>Optimization may be disabled</li> <li>Recovery MUST succeed</li> <li>Final state MUST be correct</li> </ul> <p>Optimizations MUST NOT: - Require post-crash cleanup - Leave ambiguous persistent state</p>"},{"location":"PERF_DISABLEMENT/#9-disablement-proof-obligations","title":"9. Disablement Proof Obligations","text":"<p>Every Phase 3 optimization specification MUST include:</p> <ol> <li>Disablement mechanism (compile-time or startup-time)</li> <li>Proof of WAL compatibility</li> <li>Proof of snapshot compatibility</li> <li>Proof of recovery equivalence</li> <li>Proof of no ghost state</li> </ol> <p>Missing any proof invalidates the optimization.</p>"},{"location":"PERF_DISABLEMENT/#10-operational-guarantees","title":"10. Operational Guarantees","text":"<p>From an operator\u2019s perspective:</p> <ul> <li>Disabling an optimization is safe</li> <li>No data loss occurs</li> <li>No special procedures are required</li> <li>No downgrade path is needed</li> </ul> <p>If an operator needs instructions, the optimization is invalid.</p>"},{"location":"PERF_DISABLEMENT/#11-interaction-with-replication","title":"11. Interaction with Replication","text":"<p>Disablement MUST preserve:</p> <ul> <li>WAL prefix rule</li> <li>CommitId ordering</li> <li>Replica derivability</li> </ul> <p>Primary and replica MUST NOT: - Require matching optimization settings - Coordinate optimization state</p> <p>Replication MUST remain agnostic.</p>"},{"location":"PERF_DISABLEMENT/#12-testing-requirements","title":"12. Testing Requirements","text":"<p>Disablement MUST be tested via:</p> <ul> <li>Enable \u2192 write \u2192 crash \u2192 disable \u2192 recover</li> <li>Enable \u2192 write \u2192 disable \u2192 restart</li> <li>Mixed WAL segments across enable/disable boundaries</li> </ul> <p>All tests MUST pass unmodified baseline recovery logic.</p>"},{"location":"PERF_DISABLEMENT/#13-what-rollback-is-not","title":"13. What Rollback Is NOT","text":"<p>Rollback does NOT mean:</p> <ul> <li>Undoing committed data</li> <li>Reverting WAL</li> <li>Removing snapshots</li> <li>Replaying differently</li> </ul> <p>Rollback means ceasing to use the optimization, not reversing history.</p>"},{"location":"PERF_DISABLEMENT/#14-final-rule","title":"14. Final Rule","text":"<p>If an optimization cannot be safely disabled, it is not an optimization \u2014 it is a liability.</p> <p>Phase 3 only allows optimizations that can be abandoned without consequence.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_FAILURE_MODEL/","title":"FAILURE MODEL \u2014 PHASE 3","text":""},{"location":"PERF_FAILURE_MODEL/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: Failure assumptions and equivalence requirements</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>PERFORMANCE_BASELINE.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> </ul> <p>This document defines the authoritative failure model for Phase 3. It is inherited from Phase 1 and MUST NOT be weakened, narrowed, or reinterpreted.</p> <p>All Phase 3 optimizations MUST re-prove correctness under this model.</p>"},{"location":"PERF_FAILURE_MODEL/#1-purpose","title":"1. Purpose","text":"<p>Phase 3 allows performance optimizations. Failures are where optimizations usually break correctness.</p> <p>This document defines: - What failures are assumed possible - When failures may occur - What outcomes are required - What optimizations must explicitly re-prove</p> <p>If an optimization relies on a failure not occurring, it is invalid.</p>"},{"location":"PERF_FAILURE_MODEL/#2-failure-model-continuity","title":"2. Failure Model Continuity","text":"<p>The Phase 3 failure model is identical to Phase 1.</p> <p>No additional assumptions are allowed. No failures may be excluded. No probabilities may be assigned.</p> <p>Phase 3 does NOT introduce: - \u201cFast path\u201d failure exclusions - Reduced failure surfaces - Hardware trust assumptions</p>"},{"location":"PERF_FAILURE_MODEL/#3-global-failure-assumptions","title":"3. Global Failure Assumptions","text":"<p>The system MUST be correct under the following assumptions:</p> <ul> <li>Process may terminate at any instruction</li> <li>Power may be lost at any time</li> <li>Kernel may crash or panic</li> <li>Disk writes may be partially completed</li> <li>fsync may return only when durability is achieved</li> <li>fsync may be delayed arbitrarily</li> <li>Reads may return corrupted data (detected by checksum)</li> <li>Memory is volatile and lost on crash</li> <li>Time does not advance monotonically across crashes</li> </ul> <p>No assumption of: - Graceful shutdown - Ordered teardown - Fair scheduling - Bounded I/O latency</p>"},{"location":"PERF_FAILURE_MODEL/#4-process-level-failures","title":"4. Process-Level Failures","text":""},{"location":"PERF_FAILURE_MODEL/#41-sudden-process-termination","title":"4.1 Sudden Process Termination","text":"<p>The process may terminate:</p> <ul> <li>Between any two instructions</li> <li>During any system call</li> <li>While holding locks</li> <li>While mutating in-memory state</li> </ul> <p>Required Outcome: - On restart, recovery MUST succeed - Persistent state MUST be consistent - No acknowledged write may be lost</p> <p>Optimizations MUST NOT: - Depend on cleanup handlers - Depend on RAII for correctness - Leave persistent state in ambiguous form</p>"},{"location":"PERF_FAILURE_MODEL/#42-restart-semantics","title":"4.2 Restart Semantics","text":"<p>After restart:</p> <ul> <li>Recovery begins from last durable checkpoint</li> <li>WAL is replayed deterministically</li> <li>In-memory state is rebuilt</li> </ul> <p>Optimizations MUST NOT: - Require optimization-specific replay logic - Branch replay behavior on configuration</p>"},{"location":"PERF_FAILURE_MODEL/#5-power-loss-failures","title":"5. Power Loss Failures","text":""},{"location":"PERF_FAILURE_MODEL/#51-power-loss-timing","title":"5.1 Power Loss Timing","text":"<p>Power loss may occur:</p> <ul> <li>Before WAL write</li> <li>During WAL write</li> <li>After WAL write but before fsync</li> <li>During fsync</li> <li>After fsync but before acknowledgment</li> <li>During snapshot creation</li> <li>During checkpoint</li> <li>During WAL truncation</li> </ul> <p>All boundaries are failure boundaries.</p>"},{"location":"PERF_FAILURE_MODEL/#52-required-properties","title":"5.2 Required Properties","text":"<ul> <li>Only fsync defines durability</li> <li>Data written before fsync MAY be lost</li> <li>Data written after fsync MUST persist</li> </ul> <p>Optimizations MUST: - Preserve fsync as the durability boundary - Never infer durability earlier</p>"},{"location":"PERF_FAILURE_MODEL/#6-disk-io-failures","title":"6. Disk I/O Failures","text":""},{"location":"PERF_FAILURE_MODEL/#61-partial-writes","title":"6.1 Partial Writes","text":"<p>Disk writes may be:</p> <ul> <li>Partially written</li> <li>Torn across sectors</li> <li>Reordered internally (unless fsync completed)</li> </ul> <p>Required Outcome: - Partial writes MUST be detected via checksum - Corruption MUST NOT be repaired silently</p> <p>Optimizations MUST NOT: - Remove checksums - Coalesce writes without preserving detectability</p>"},{"location":"PERF_FAILURE_MODEL/#62-disk-errors","title":"6.2 Disk Errors","text":"<p>Disk operations may fail with errors:</p> <ul> <li>ENOSPC</li> <li>EIO</li> <li>Permission errors</li> <li>Transient failures</li> </ul> <p>Required Outcome: - Errors must be surfaced explicitly - No silent fallback behavior</p>"},{"location":"PERF_FAILURE_MODEL/#7-fsync-semantics","title":"7. fsync Semantics","text":""},{"location":"PERF_FAILURE_MODEL/#71-fsync-guarantees","title":"7.1 fsync Guarantees","text":"<p>fsync guarantees: - All previous writes are durable upon successful return</p> <p>fsync does NOT guarantee: - Bounded latency - Immediate hardware flush - Ordering between different files unless specified</p> <p>Optimizations MUST: - Treat fsync return as the only durability signal - Avoid assumptions about fsync speed or batching</p>"},{"location":"PERF_FAILURE_MODEL/#72-fsync-failure","title":"7.2 fsync Failure","text":"<p>fsync may: - Fail with error - Succeed after long delay</p> <p>Required Outcome: - On fsync failure, commit MUST fail - No acknowledgment may occur</p>"},{"location":"PERF_FAILURE_MODEL/#8-memory-failures","title":"8. Memory Failures","text":""},{"location":"PERF_FAILURE_MODEL/#81-volatile-memory-loss","title":"8.1 Volatile Memory Loss","text":"<p>On crash: - All in-memory state is lost - No memory content is preserved</p> <p>Optimizations MUST NOT: - Depend on memory persistence - Depend on restart-resident caches</p>"},{"location":"PERF_FAILURE_MODEL/#82-memory-corruption","title":"8.2 Memory Corruption","text":"<p>Memory corruption is NOT assumed correctable.</p> <p>Phase 3 does not introduce: - ECC assumptions - Retry-on-corruption logic</p>"},{"location":"PERF_FAILURE_MODEL/#9-checkpoint-snapshot-failures","title":"9. Checkpoint &amp; Snapshot Failures","text":""},{"location":"PERF_FAILURE_MODEL/#91-snapshot-creation-failures","title":"9.1 Snapshot Creation Failures","text":"<p>Failures may occur: - During snapshot enumeration - During snapshot file write - During snapshot fsync - During manifest write</p> <p>Required Outcome: - Incomplete snapshots MUST be detected - They MUST NOT be used for recovery</p>"},{"location":"PERF_FAILURE_MODEL/#92-checkpoint-failures","title":"9.2 Checkpoint Failures","text":"<p>Failures may occur: - After snapshot but before checkpoint marker - After marker but before WAL truncation</p> <p>Required Outcome: - WAL truncation MUST NOT occur unless snapshot is durable - Recovery MUST choose a valid checkpoint</p> <p>Optimizations MUST preserve this ordering exactly.</p>"},{"location":"PERF_FAILURE_MODEL/#10-wal-truncation-failures","title":"10. WAL Truncation Failures","text":"<p>Failures may occur: - During truncation - After truncation but before fsync</p> <p>Required Outcome: - Truncation MUST be atomic or detectable - WAL prefix must remain valid</p> <p>Optimizations MUST NOT: - Introduce speculative truncation - Rely on background cleanup</p>"},{"location":"PERF_FAILURE_MODEL/#11-replication-relevant-failures","title":"11. Replication-Relevant Failures","text":"<p>Even if replication is not yet enabled, optimizations MUST respect:</p>"},{"location":"PERF_FAILURE_MODEL/#111-replica-disconnect","title":"11.1 Replica Disconnect","text":"<p>Replica may: - Disconnect at any time - Reconnect later - Restart independently</p> <p>Required Outcome: - WAL prefix rule is preserved - Replica state is derivable</p>"},{"location":"PERF_FAILURE_MODEL/#112-partial-wal-shipping","title":"11.2 Partial WAL Shipping","text":"<p>Replica may receive: - Partial WAL segments - Interrupted transfers</p> <p>Required Outcome: - Partial data is detected - Replay waits for completion</p> <p>Optimizations MUST NOT: - Assume continuous streaming - Assume synchronous replication</p>"},{"location":"PERF_FAILURE_MODEL/#12-failure-equivalence-requirement","title":"12. Failure Equivalence Requirement","text":"<p>For every optimization:</p> <ul> <li>Each failure point in baseline MUST be enumerated</li> <li>Optimized behavior MUST be described</li> <li>Resulting state MUST be equivalent</li> </ul> <p>Equivalence must hold for: - Success paths - Failure paths - Recovery outcomes</p>"},{"location":"PERF_FAILURE_MODEL/#13-forbidden-failure-assumptions","title":"13. Forbidden Failure Assumptions","text":"<p>Optimizations MUST NOT assume:</p> <ul> <li>\u201cCrashes are rare\u201d</li> <li>\u201cfsync is fast\u201d</li> <li>\u201cWrites are atomic\u201d</li> <li>\u201cStorage is reliable\u201d</li> <li>\u201cShutdown is graceful\u201d</li> <li>\u201cPower loss won\u2019t happen here\u201d</li> </ul> <p>Any such assumption invalidates the optimization.</p>"},{"location":"PERF_FAILURE_MODEL/#14-failure-proof-obligations","title":"14. Failure Proof Obligations","text":"<p>Each optimization specification MUST include:</p> <ul> <li>A failure timeline</li> <li>A before/after state comparison</li> <li>Recovery convergence proof</li> <li>Explicit reference to this document</li> </ul> <p>If a failure case is omitted, proof is incomplete.</p>"},{"location":"PERF_FAILURE_MODEL/#15-final-rule","title":"15. Final Rule","text":"<p>AeroDB correctness is defined by its behavior when everything goes wrong.</p> <p>An optimization that only works when things go right does not belong in Phase 3.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_GROUP_COMMIT/","title":"GROUP COMMIT \u2014 PHASE 3","text":""},{"location":"PERF_GROUP_COMMIT/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: Write-path performance optimization</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>PERFORMANCE_BASELINE.md</li> <li>CRITICAL_PATHS.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> <li>FAILURE_MODEL_PHASE3.md</li> <li>ROLLBACK_AND_DISABLEMENT.md</li> <li>PERFORMANCE_OBSERVABILITY.md</li> </ul> <p>This document specifies Group Commit as a correctness-preserving optimization. If any requirement in this document cannot be satisfied, Group Commit MUST NOT be implemented.</p>"},{"location":"PERF_GROUP_COMMIT/#1-purpose","title":"1. Purpose","text":"<p>Baseline AeroDB performs:</p> <ul> <li>One fsync per acknowledged commit</li> </ul> <p>This yields maximal durability clarity but poor throughput under concurrent writes.</p> <p>Group Commit reduces fsync frequency by: - Allowing multiple commits to share a single fsync - While preserving exact durability, ordering, and visibility semantics</p> <p>Group Commit does not: - Change acknowledgment semantics - Change CommitId semantics - Change WAL meaning - Introduce async durability</p>"},{"location":"PERF_GROUP_COMMIT/#2-baseline-reference-normative","title":"2. Baseline Reference (Normative)","text":"<p>This optimization is defined relative to:</p> <ul> <li>Section 3 of <code>PERFORMANCE_BASELINE.md</code></li> <li>Section 2.1 and 2.2 of <code>CRITICAL_PATHS.md</code></li> </ul> <p>Baseline properties that MUST remain true:</p> <ul> <li>A commit is acknowledged only after fsync</li> <li>CommitIds are assigned after fsync</li> <li>WAL append order == commit order</li> <li>Each commit is independently durable</li> </ul>"},{"location":"PERF_GROUP_COMMIT/#3-definition-of-group-commit","title":"3. Definition of Group Commit","text":""},{"location":"PERF_GROUP_COMMIT/#31-conceptual-definition","title":"3.1 Conceptual Definition","text":"<p>Group Commit allows:</p> <p>Multiple logically independent commits to wait on the same fsync call, provided that each commit\u2019s WAL record is fully written before that fsync.</p> <p>Each commit remains: - Logically independent - Separately represented in WAL - Separately ordered - Separately acknowledged</p> <p>The fsync is shared, not amortized semantically.</p>"},{"location":"PERF_GROUP_COMMIT/#32-non-definition-what-group-commit-is-not","title":"3.2 Non-Definition (What Group Commit Is NOT)","text":"<p>Group Commit does NOT mean:</p> <ul> <li>Delaying acknowledgment beyond durability</li> <li>Acknowledging commits before fsync</li> <li>Combining WAL records into a single logical commit</li> <li>Assigning CommitIds early</li> <li>Time-based flushing</li> <li>Adaptive grouping</li> </ul> <p>If grouping depends on timing heuristics, it is invalid.</p>"},{"location":"PERF_GROUP_COMMIT/#4-mechanical-description","title":"4. Mechanical Description","text":""},{"location":"PERF_GROUP_COMMIT/#41-baseline-write-path-simplified","title":"4.1 Baseline Write Path (Simplified)","text":"<p>For each commit:</p> <ol> <li>Append WAL record</li> <li>fsync WAL</li> <li>Assign CommitId</li> <li>Acknowledge commit</li> </ol>"},{"location":"PERF_GROUP_COMMIT/#42-group-commit-write-path","title":"4.2 Group Commit Write Path","text":"<p>Under Group Commit, the following mechanical change is permitted:</p> <ol> <li>Append WAL record for commit A</li> <li>Append WAL record for commit B</li> <li>Append WAL record for commit C</li> <li>fsync WAL once</li> <li>Assign CommitIds to A, B, C (in append order)</li> <li>Acknowledge A, B, C (in order)</li> </ol> <p>Key rule: - No commit is acknowledged before fsync returns</p>"},{"location":"PERF_GROUP_COMMIT/#43-group-formation-rules","title":"4.3 Group Formation Rules","text":"<p>Group Commit groups are formed ONLY by:</p> <ul> <li>Concurrent arrival of commits</li> <li>Explicit queueing before fsync</li> </ul> <p>Groups MUST NOT be formed by: - Timers - Delays - Load thresholds - Background batching</p> <p>If only one commit is present, behavior is identical to baseline.</p>"},{"location":"PERF_GROUP_COMMIT/#5-invariant-preservation-matrix","title":"5. Invariant Preservation Matrix","text":"<p>This section references <code>PERF_INVARIANTS.md</code>.</p>"},{"location":"PERF_GROUP_COMMIT/#durability","title":"Durability","text":"<ul> <li>D-1 (Acknowledged Write Durability): Preserved</li> <li>D-2 (Atomic Commit Boundary): Preserved</li> <li>D-3 (No Silent Downgrade): Preserved</li> </ul>"},{"location":"PERF_GROUP_COMMIT/#determinism","title":"Determinism","text":"<ul> <li>DET-1 (Crash Determinism): Preserved</li> <li>DET-2 (Replay Equivalence): Preserved</li> <li>DET-3 (Bounded Execution): Preserved</li> </ul>"},{"location":"PERF_GROUP_COMMIT/#mvcc","title":"MVCC","text":"<ul> <li>MVCC-1 (Snapshot Isolation): Preserved</li> <li>MVCC-2 (CommitId Authority): Preserved</li> <li>MVCC-3 (Version Chain Integrity): Preserved</li> </ul>"},{"location":"PERF_GROUP_COMMIT/#replication","title":"Replication","text":"<ul> <li>REP-1 (Single Writer): Preserved</li> <li>REP-2 (WAL Prefix Rule): Preserved</li> <li>REP-3 (Replica Equivalence): Preserved</li> </ul>"},{"location":"PERF_GROUP_COMMIT/#failure-recovery","title":"Failure &amp; Recovery","text":"<ul> <li>FR-1, FR-2, FR-3: Preserved</li> </ul>"},{"location":"PERF_GROUP_COMMIT/#observability","title":"Observability","text":"<ul> <li>OBS-1, OBS-2: Preserved</li> </ul>"},{"location":"PERF_GROUP_COMMIT/#disablement","title":"Disablement","text":"<ul> <li>DIS-1, DIS-2, DIS-3: Preserved</li> </ul> <p>No invariant is weakened or reinterpreted.</p>"},{"location":"PERF_GROUP_COMMIT/#6-semantic-equivalence-argument","title":"6. Semantic Equivalence Argument","text":"<p>Group Commit is semantically equivalent to baseline execution because:</p> <ul> <li>WAL contains the same sequence of logical commit records</li> <li>Commit ordering is identical</li> <li>CommitIds are assigned in the same order</li> <li>Acknowledgment occurs after fsync in all cases</li> <li>Crash recovery replays the same WAL</li> </ul> <p>The only difference is which commits wait on which fsync, which is not observable.</p>"},{"location":"PERF_GROUP_COMMIT/#7-failure-matrix","title":"7. Failure Matrix","text":""},{"location":"PERF_GROUP_COMMIT/#71-crash-before-wal-append","title":"7.1 Crash Before WAL Append","text":"<ul> <li>Baseline: commit lost</li> <li>Group Commit: commit lost</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_GROUP_COMMIT/#72-crash-after-wal-append-before-fsync","title":"7.2 Crash After WAL Append, Before fsync","text":"<ul> <li>Baseline: commit not durable, replay drops it</li> <li>Group Commit: commit not durable, replay drops it</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_GROUP_COMMIT/#73-crash-during-fsync","title":"7.3 Crash During fsync","text":"<ul> <li>Baseline: durability depends on fsync completion</li> <li>Group Commit: durability depends on fsync completion</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_GROUP_COMMIT/#74-crash-after-fsync-before-acknowledgment","title":"7.4 Crash After fsync, Before Acknowledgment","text":"<ul> <li>Baseline: commit durable, replay restores it</li> <li>Group Commit: commit durable, replay restores it</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_GROUP_COMMIT/#75-partial-wal-write","title":"7.5 Partial WAL Write","text":"<ul> <li>Detected by checksum</li> <li>Commit rejected or replay-failed identically</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_GROUP_COMMIT/#8-recovery-proof","title":"8. Recovery Proof","text":"<ul> <li>WAL replay logic is unchanged</li> <li>WAL contents are unchanged</li> <li>Replay order is unchanged</li> <li>No grouping state is persisted</li> </ul> <p>Therefore: - Replay is deterministic - Replay is idempotent - Replay is optimization-agnostic</p>"},{"location":"PERF_GROUP_COMMIT/#9-disablement-rollback","title":"9. Disablement &amp; Rollback","text":""},{"location":"PERF_GROUP_COMMIT/#91-disablement-mechanism","title":"9.1 Disablement Mechanism","text":"<p>Group Commit MUST be disableable via:</p> <ul> <li>Compile-time flag or</li> <li>Startup configuration</li> </ul> <p>Disablement means: - Each commit performs its own fsync - No shared fsync paths exist</p>"},{"location":"PERF_GROUP_COMMIT/#92-compatibility-proof","title":"9.2 Compatibility Proof","text":"<ul> <li>WAL format is unchanged</li> <li>Snapshot format is unchanged</li> <li>Checkpoint format is unchanged</li> </ul> <p>Data written with Group Commit enabled is readable with it disabled.</p>"},{"location":"PERF_GROUP_COMMIT/#93-no-ghost-state","title":"9.3 No Ghost State","text":"<ul> <li>No persistent grouping metadata</li> <li>No WAL flags</li> <li>No snapshot annotations</li> </ul> <p>All grouping state is in-memory and discardable.</p>"},{"location":"PERF_GROUP_COMMIT/#10-observability","title":"10. Observability","text":"<p>Permitted metrics (passive only):</p> <ul> <li>group_commit.size</li> <li>group_commit.fsync_count</li> <li>group_commit.waiters</li> </ul> <p>Metrics MUST NOT: - Influence grouping - Influence commit ordering - Influence scheduling</p>"},{"location":"PERF_GROUP_COMMIT/#11-testing-requirements","title":"11. Testing Requirements","text":"<p>Group Commit MUST introduce:</p> <ul> <li>Equivalence tests vs baseline</li> <li>Crash tests at all boundaries</li> <li>Enable \u2192 write \u2192 crash \u2192 disable \u2192 recover tests</li> <li>Replication-prefix validation tests</li> </ul> <p>All Phase 1 and Phase 2 tests MUST pass unmodified.</p>"},{"location":"PERF_GROUP_COMMIT/#12-explicit-non-goals","title":"12. Explicit Non-Goals","text":"<p>Group Commit does NOT aim to:</p> <ul> <li>Reduce latency of individual commits</li> <li>Change commit acknowledgment timing</li> <li>Introduce adaptive batching</li> <li>Reduce fsync durability guarantees</li> </ul> <p>It improves throughput only.</p>"},{"location":"PERF_GROUP_COMMIT/#13-final-rule","title":"13. Final Rule","text":"<p>Group Commit is acceptable only if it is indistinguishable from doing every fsync separately.</p> <p>If a client, replica, or recovery process can tell the difference, Group Commit is invalid.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_INDEX_ACCELERATION/","title":"INDEX ACCELERATION \u2014 PHASE 3","text":""},{"location":"PERF_INDEX_ACCELERATION/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: Read-path and query-execution acceleration via derived indexes</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>PERFORMANCE_BASELINE.md</li> <li>CRITICAL_PATHS.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> <li>FAILURE_MODEL_PHASE3.md</li> <li>ROLLBACK_AND_DISABLEMENT.md</li> <li>PERFORMANCE_OBSERVABILITY.md</li> </ul> <p>This document specifies Index Acceleration as a Phase-3 optimization. Indexes remain derived, non-authoritative, rebuildable, and correctness-neutral.</p> <p>If any index influences correctness or visibility, it is invalid.</p>"},{"location":"PERF_INDEX_ACCELERATION/#1-purpose","title":"1. Purpose","text":"<p>Baseline AeroDB indexes are:</p> <ul> <li>In-memory</li> <li>Derived from persistent state</li> <li>Rebuilt on startup</li> <li>Advisory to query execution</li> </ul> <p>They are correct but not aggressively optimized.</p> <p>Index Acceleration improves performance by: - Reducing scan width - Reducing per-read work - Improving query selectivity</p> <p>While strictly preserving: - MVCC semantics - Query determinism - Recovery behavior - Replication compatibility</p>"},{"location":"PERF_INDEX_ACCELERATION/#2-baseline-reference-normative","title":"2. Baseline Reference (Normative)","text":"<p>Baseline index behavior is defined in:</p> <ul> <li><code>PERFORMANCE_BASELINE.md</code> \u00a74, \u00a75</li> <li><code>CRITICAL_PATHS.md</code> \u00a73</li> </ul> <p>Baseline properties:</p> <ul> <li>Indexes are never authoritative</li> <li>Indexes may be stale only transiently during rebuild</li> <li>Query correctness never depends on index completeness</li> <li>Visibility checks are always enforced</li> </ul> <p>These properties MUST remain true.</p>"},{"location":"PERF_INDEX_ACCELERATION/#3-definition-of-index-acceleration","title":"3. Definition of Index Acceleration","text":""},{"location":"PERF_INDEX_ACCELERATION/#31-conceptual-definition","title":"3.1 Conceptual Definition","text":"<p>Index Acceleration is any optimization that:</p> <p>Improves the performance of locating candidate records while preserving the requirement that final visibility and correctness are determined independently of the index.</p> <p>Indexes may only: - Narrow search space - Suggest candidates</p> <p>Indexes may never: - Decide visibility - Decide existence - Decide commit ordering</p>"},{"location":"PERF_INDEX_ACCELERATION/#32-explicit-non-definition-what-this-is-not","title":"3.2 Explicit Non-Definition (What This Is NOT)","text":"<p>Index Acceleration does NOT allow:</p> <ul> <li>Persistent authoritative indexes</li> <li>Index-driven visibility</li> <li>Index-only reads</li> <li>Skipping MVCC checks</li> <li>Skipping document validation</li> <li>Query result correctness dependent on index health</li> </ul> <p>If an index can cause a wrong answer, it is invalid.</p>"},{"location":"PERF_INDEX_ACCELERATION/#4-allowed-index-acceleration-techniques","title":"4. Allowed Index Acceleration Techniques","text":"<p>Only the following classes are permitted.</p>"},{"location":"PERF_INDEX_ACCELERATION/#41-improved-in-memory-data-structures","title":"4.1 Improved In-Memory Data Structures","text":""},{"location":"PERF_INDEX_ACCELERATION/#description","title":"Description","text":"<p>Replace baseline index structures with more efficient but equivalent ones:</p> <ul> <li>Better hash distributions</li> <li>Balanced trees</li> <li>Cache-friendly layouts</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#rules","title":"Rules","text":"<ul> <li>Key semantics unchanged</li> <li>Value semantics unchanged</li> <li>Ordering semantics unchanged (if applicable)</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#proof-obligation","title":"Proof Obligation","text":"<ul> <li>Index lookup returns a superset of valid candidates</li> <li>No valid candidate is omitted</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#42-multi-attribute-derived-indexes","title":"4.2 Multi-Attribute Derived Indexes","text":""},{"location":"PERF_INDEX_ACCELERATION/#description_1","title":"Description","text":"<p>Construct composite in-memory indexes derived from:</p> <ul> <li>Existing document fields</li> <li>Existing schema definitions</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#rules_1","title":"Rules","text":"<ul> <li>Indexes MUST be derivable entirely from stored documents</li> <li>Index build order MUST be deterministic</li> <li>No additional persistent metadata allowed</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#proof-obligation_1","title":"Proof Obligation","text":"<ul> <li>Query filtering still validates predicates explicitly</li> <li>Missing index entries do not affect correctness</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#43-predicate-pre-filtering-advisory-only","title":"4.3 Predicate Pre-Filtering (Advisory Only)","text":""},{"location":"PERF_INDEX_ACCELERATION/#description_2","title":"Description","text":"<p>Use indexes to pre-filter candidates before:</p> <ul> <li>Version-chain traversal</li> <li>MVCC visibility checks</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#rules_2","title":"Rules","text":"<ul> <li>Pre-filtering MUST be conservative</li> <li>False positives allowed</li> <li>False negatives forbidden</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#proof-obligation_2","title":"Proof Obligation","text":"<ul> <li>All correct results remain reachable</li> <li>Index absence yields baseline behavior</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#44-read-only-index-hints-planner-visible-not-binding","title":"4.4 Read-Only Index Hints (Planner-Visible, Not Binding)","text":""},{"location":"PERF_INDEX_ACCELERATION/#description_3","title":"Description","text":"<p>Allow query planner to prefer certain indexes when multiple options exist.</p>"},{"location":"PERF_INDEX_ACCELERATION/#rules_3","title":"Rules","text":"<ul> <li>Planner remains deterministic</li> <li>Plan selection remains bounded</li> <li>Hints do not override correctness checks</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#proof-obligation_3","title":"Proof Obligation","text":"<ul> <li>Different plans produce identical result sets</li> <li>Plan choice does not affect semantics</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#5-forbidden-index-optimizations","title":"5. Forbidden Index Optimizations","text":"<p>The following are explicitly forbidden:</p> <ul> <li>Persistent on-disk indexes</li> <li>Incremental index persistence</li> <li>Index-based visibility shortcuts</li> <li>Index-only execution paths</li> <li>Lazy index maintenance affecting correctness</li> <li>Background index mutation affecting reads</li> <li>Heuristic index selection</li> </ul> <p>If an index becomes required for correctness, it violates Phase 3.</p>"},{"location":"PERF_INDEX_ACCELERATION/#6-invariant-preservation-matrix","title":"6. Invariant Preservation Matrix","text":"<p>(Referenced from <code>PERF_INVARIANTS.md</code>)</p>"},{"location":"PERF_INDEX_ACCELERATION/#durability","title":"Durability","text":"<ul> <li>D-1, D-2, D-3: Not Applicable (Derived Only)</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#determinism","title":"Determinism","text":"<ul> <li>DET-1 (Crash Determinism): Preserved</li> <li>DET-2 (Replay Equivalence): Preserved</li> <li>DET-3 (Bounded Execution): Preserved</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#mvcc","title":"MVCC","text":"<ul> <li>MVCC-1 (Snapshot Isolation): Preserved</li> <li>MVCC-2 (CommitId Authority): Preserved</li> <li>MVCC-3 (Version Chain Integrity): Preserved</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#replication","title":"Replication","text":"<ul> <li>REP-1, REP-2, REP-3: Preserved</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#failure-recovery","title":"Failure &amp; Recovery","text":"<ul> <li>FR-1, FR-2, FR-3: Preserved</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#observability","title":"Observability","text":"<ul> <li>OBS-1, OBS-2: Preserved</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#disablement","title":"Disablement","text":"<ul> <li>DIS-1, DIS-2, DIS-3: Preserved</li> </ul>"},{"location":"PERF_INDEX_ACCELERATION/#7-semantic-equivalence-argument","title":"7. Semantic Equivalence Argument","text":"<p>Index Acceleration is semantically equivalent to baseline because:</p> <ul> <li>Indexes only restrict candidate enumeration</li> <li>All candidates are validated independently</li> <li>MVCC visibility is enforced post-selection</li> <li>Missing or incorrect index entries only reduce performance, not correctness</li> </ul> <p>Query results remain identical.</p>"},{"location":"PERF_INDEX_ACCELERATION/#8-failure-matrix","title":"8. Failure Matrix","text":""},{"location":"PERF_INDEX_ACCELERATION/#81-crash-during-index-build","title":"8.1 Crash During Index Build","text":"<ul> <li>Index state is lost</li> <li>Index is rebuilt on restart</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_INDEX_ACCELERATION/#82-crash-during-query-execution","title":"8.2 Crash During Query Execution","text":"<ul> <li>Baseline: query aborted</li> <li>Optimized: query aborted</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_INDEX_ACCELERATION/#83-index-corruption-memory","title":"8.3 Index Corruption (Memory)","text":"<ul> <li>Index discarded</li> <li>Query falls back to baseline behavior</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_INDEX_ACCELERATION/#9-recovery-proof","title":"9. Recovery Proof","text":"<ul> <li>Indexes are not persisted</li> <li>Recovery ignores index state</li> <li>Index rebuild is deterministic</li> </ul> <p>Recovery behavior is unchanged.</p>"},{"location":"PERF_INDEX_ACCELERATION/#10-disablement-rollback","title":"10. Disablement &amp; Rollback","text":""},{"location":"PERF_INDEX_ACCELERATION/#101-disablement-mechanism","title":"10.1 Disablement Mechanism","text":"<p>Index Acceleration MUST be disableable via:</p> <ul> <li>Compile-time flag or</li> <li>Startup configuration</li> </ul> <p>Disablement restores: - Baseline index structures - Baseline query execution paths</p>"},{"location":"PERF_INDEX_ACCELERATION/#102-compatibility-proof","title":"10.2 Compatibility Proof","text":"<ul> <li>WAL unaffected</li> <li>Snapshots unaffected</li> <li>Checkpoints unaffected</li> </ul> <p>Index-accelerated data is always readable.</p>"},{"location":"PERF_INDEX_ACCELERATION/#103-no-ghost-state","title":"10.3 No Ghost State","text":"<ul> <li>No persistent index files</li> <li>No WAL index metadata</li> <li>No snapshot annotations</li> </ul> <p>All index state is transient.</p>"},{"location":"PERF_INDEX_ACCELERATION/#11-observability","title":"11. Observability","text":"<p>Permitted metrics (passive only):</p> <ul> <li>index.lookup.count</li> <li>index.candidate.count</li> <li>index.filter.false_positives</li> <li>index.rebuild.duration</li> </ul> <p>Metrics MUST NOT: - Influence planner decisions - Influence index selection - Influence execution flow</p>"},{"location":"PERF_INDEX_ACCELERATION/#12-testing-requirements","title":"12. Testing Requirements","text":"<p>Index Acceleration MUST introduce:</p> <ul> <li>Query equivalence tests</li> <li>Index absence tests</li> <li>Corrupted index tests</li> <li>Disablement equivalence tests</li> <li>Crash during index rebuild tests</li> </ul> <p>All existing tests MUST pass unmodified.</p>"},{"location":"PERF_INDEX_ACCELERATION/#13-explicit-non-goals","title":"13. Explicit Non-Goals","text":"<p>Index Acceleration does NOT aim to:</p> <ul> <li>Replace scans with indexes</li> <li>Change query semantics</li> <li>Persist index state</li> <li>Introduce secondary storage structures</li> </ul> <p>Indexes are helpers, not authorities.</p>"},{"location":"PERF_INDEX_ACCELERATION/#14-final-rule","title":"14. Final Rule","text":"<p>If removing an index changes a query result, the index is incorrect.</p> <p>Index Acceleration exists to make queries faster, never different.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_INVARIANTS/","title":"PHASE 3 \u2014 INVARIANTS","text":""},{"location":"PERF_INVARIANTS/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Scope: Global, cross-cutting</li> <li>Authority: Normative</li> <li>Applies to: All Phase 3 optimizations without exception</li> </ul> <p>This document defines the non-negotiable invariants that Phase 3 optimizations MUST preserve. Violation of any invariant invalidates an optimization regardless of performance benefit.</p>"},{"location":"PERF_INVARIANTS/#1-invariant-taxonomy","title":"1. Invariant Taxonomy","text":"<p>Phase 3 invariants are grouped by domain:</p> <ol> <li>Durability Invariants</li> <li>Determinism Invariants</li> <li>Visibility &amp; MVCC Invariants</li> <li>Replication Invariants</li> <li>Failure &amp; Recovery Invariants</li> <li>Observability Invariants</li> <li>Disablement &amp; Rollback Invariants</li> </ol> <p>All invariants are absolute, not best-effort.</p>"},{"location":"PERF_INVARIANTS/#2-durability-invariants","title":"2. Durability Invariants","text":""},{"location":"PERF_INVARIANTS/#d-1-acknowledged-write-durability","title":"D-1: Acknowledged Write Durability","text":"<p>Once a write is acknowledged to the caller:</p> <ul> <li>Its WAL record MUST be:</li> <li>Fully written</li> <li>Checksummed</li> <li>fsync-completed</li> <li>The write MUST survive:</li> <li>Process crash</li> <li>Power loss</li> <li>Kernel panic</li> </ul> <p>Phase 3 Rule: No optimization may delay, weaken, batch, or amortize durability beyond what Phase 1 guarantees.</p>"},{"location":"PERF_INVARIANTS/#d-2-atomic-commit-boundary-preservation","title":"D-2: Atomic Commit Boundary Preservation","text":"<ul> <li>Each commit has a precise durability boundary</li> <li>Partial commits are forbidden</li> <li>Commit boundaries MUST NOT be inferred from timing or batching</li> </ul> <p>Phase 3 Rule: If commits are grouped, the group MUST be equivalent to sequential commits with identical durability semantics.</p>"},{"location":"PERF_INVARIANTS/#d-3-no-silent-durability-downgrade","title":"D-3: No Silent Durability Downgrade","text":"<ul> <li>Durability behavior MUST NOT vary based on:</li> <li>Load</li> <li>Time</li> <li>Configuration heuristics</li> <li>Hardware characteristics</li> </ul> <p>Phase 3 Rule: Durability is a constant, not a variable.</p>"},{"location":"PERF_INVARIANTS/#3-determinism-invariants","title":"3. Determinism Invariants","text":""},{"location":"PERF_INVARIANTS/#det-1-crash-determinism","title":"DET-1: Crash Determinism","text":"<p>Given identical inputs and crash points:</p> <ul> <li>Recovery MUST produce identical state</li> <li>WAL replay order MUST be identical</li> <li>MVCC visibility MUST be identical</li> </ul> <p>Phase 3 Rule: Optimizations MUST NOT introduce scheduling, timing, or concurrency-dependent outcomes.</p>"},{"location":"PERF_INVARIANTS/#det-2-replay-equivalence","title":"DET-2: Replay Equivalence","text":"<p>Optimized execution MUST be replay-equivalent to baseline execution.</p> <ul> <li>WAL contents MUST be semantically identical</li> <li>Commit ordering MUST be preserved</li> <li>Replay logic MUST remain unchanged</li> </ul> <p>Phase 3 Rule: If replay behavior differs, the optimization is invalid.</p>"},{"location":"PERF_INVARIANTS/#det-3-bounded-execution","title":"DET-3: Bounded Execution","text":"<ul> <li>All operations remain bounded</li> <li>No unbounded queues</li> <li>No unbounded memory growth</li> </ul> <p>Phase 3 Rule: Performance optimizations may reduce bounds, never remove them.</p>"},{"location":"PERF_INVARIANTS/#4-visibility-mvcc-invariants","title":"4. Visibility &amp; MVCC Invariants","text":""},{"location":"PERF_INVARIANTS/#mvcc-1-snapshot-isolation-preservation","title":"MVCC-1: Snapshot Isolation Preservation","text":"<ul> <li>Snapshot visibility rules are immutable</li> <li>No read may observe:</li> <li>Uncommitted data</li> <li>Future commits</li> <li>Cross-snapshot leakage</li> </ul> <p>Phase 3 Rule: Read optimizations MUST explicitly re-check MVCC visibility.</p>"},{"location":"PERF_INVARIANTS/#mvcc-2-commitid-authority","title":"MVCC-2: CommitId Authority","text":"<ul> <li>CommitIds originate only from WAL-governed commits</li> <li>No speculative or provisional CommitIds</li> </ul> <p>Phase 3 Rule: Optimizations MUST NOT invent or infer CommitIds.</p>"},{"location":"PERF_INVARIANTS/#mvcc-3-version-chain-integrity","title":"MVCC-3: Version Chain Integrity","text":"<ul> <li>Version chains are immutable</li> <li>Order is strictly CommitId-ordered</li> </ul> <p>Phase 3 Rule: Optimizations MUST NOT shortcut version traversal without proof of equivalence.</p>"},{"location":"PERF_INVARIANTS/#5-replication-invariants","title":"5. Replication Invariants","text":""},{"location":"PERF_INVARIANTS/#rep-1-single-writer-invariant","title":"REP-1: Single-Writer Invariant","text":"<ul> <li>Only Primary assigns CommitIds</li> <li>Replicas consume WAL strictly as a prefix</li> </ul> <p>Phase 3 Rule: No optimization may alter CommitId assignment timing or authority.</p>"},{"location":"PERF_INVARIANTS/#rep-2-wal-prefix-rule","title":"REP-2: WAL Prefix Rule","text":"<ul> <li>Replica WAL is always a prefix of Primary WAL</li> <li>No gaps</li> <li>No reordering</li> </ul> <p>Phase 3 Rule: Batching or grouping MUST preserve prefix structure exactly.</p>"},{"location":"PERF_INVARIANTS/#rep-3-replica-observational-equivalence","title":"REP-3: Replica Observational Equivalence","text":"<ul> <li>Replica-visible state MUST be derivable from WAL + snapshots</li> <li>No hidden or transient state</li> </ul> <p>Phase 3 Rule: Optimizations MUST NOT create replica-only or primary-only semantic paths.</p>"},{"location":"PERF_INVARIANTS/#6-failure-recovery-invariants","title":"6. Failure &amp; Recovery Invariants","text":""},{"location":"PERF_INVARIANTS/#fr-1-failure-detectability","title":"FR-1: Failure Detectability","text":"<ul> <li>Corruption MUST be detected</li> <li>No silent repair</li> <li>No best-effort recovery</li> </ul> <p>Phase 3 Rule: Optimizations MUST preserve all existing checksums and validation points.</p>"},{"location":"PERF_INVARIANTS/#fr-2-failure-locality","title":"FR-2: Failure Locality","text":"<ul> <li>Failures affect only the operation in progress</li> <li>No cascading semantic damage</li> </ul> <p>Phase 3 Rule: Optimizations MUST NOT widen failure blast radius.</p>"},{"location":"PERF_INVARIANTS/#fr-3-recovery-idempotence","title":"FR-3: Recovery Idempotence","text":"<ul> <li>WAL replay is idempotent</li> <li>Replaying the same WAL twice yields identical state</li> </ul> <p>Phase 3 Rule: Optimizations MUST NOT introduce side effects during replay.</p>"},{"location":"PERF_INVARIANTS/#7-observability-invariants","title":"7. Observability Invariants","text":""},{"location":"PERF_INVARIANTS/#obs-1-observability-passivity","title":"OBS-1: Observability Passivity","text":"<ul> <li>Metrics and logs MUST NOT influence behavior</li> <li>No metric-driven decisions</li> </ul> <p>Phase 3 Rule: Instrumentation is observational only.</p>"},{"location":"PERF_INVARIANTS/#obs-2-deterministic-emission","title":"OBS-2: Deterministic Emission","text":"<ul> <li>Metrics emission order is deterministic</li> <li>Logs do not affect control flow</li> </ul> <p>Phase 3 Rule: Instrumentation must be ignorable without semantic change.</p>"},{"location":"PERF_INVARIANTS/#8-disablement-rollback-invariants","title":"8. Disablement &amp; Rollback Invariants","text":""},{"location":"PERF_INVARIANTS/#dis-1-safe-disablement","title":"DIS-1: Safe Disablement","text":"<ul> <li>Any optimization can be disabled:</li> <li>At compile time, or</li> <li>At startup</li> <li>Disabling MUST NOT require data migration</li> </ul>"},{"location":"PERF_INVARIANTS/#dis-2-data-compatibility","title":"DIS-2: Data Compatibility","text":"<ul> <li>Data written with optimization enabled MUST be readable with it disabled</li> <li>WAL and snapshot formats MUST remain compatible</li> </ul>"},{"location":"PERF_INVARIANTS/#dis-3-no-ghost-state","title":"DIS-3: No Ghost State","text":"<ul> <li>Optimizations MUST NOT introduce:</li> <li>Hidden persistent state</li> <li>Implicit metadata</li> <li>Undocumented invariants</li> </ul>"},{"location":"PERF_INVARIANTS/#9-invariant-enforcement","title":"9. Invariant Enforcement","text":"<p>Each Phase 3 optimization MUST:</p> <ul> <li>Explicitly list which invariants it touches</li> <li>Prove preservation of each</li> <li>Include failure matrices per invariant</li> <li>Reference this document section-by-section</li> </ul> <p>Failure to reference an invariant implies failure to preserve it.</p>"},{"location":"PERF_INVARIANTS/#10-invariant-hierarchy","title":"10. Invariant Hierarchy","text":"<p>If invariants conflict, precedence is:</p> <ol> <li>Durability</li> <li>Determinism</li> <li>MVCC Visibility</li> <li>Replication</li> <li>Failure Detection</li> <li>Observability</li> <li>Performance</li> </ol> <p>Performance always loses.</p>"},{"location":"PERF_INVARIANTS/#11-final-rule","title":"11. Final Rule","text":"<p>An optimization that cannot prove it preserves every invariant is not an optimization \u2014 it is a bug.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_MEMORY_LAYOUT/","title":"MEMORY LAYOUT OPTIMIZATION \u2014 PHASE 3","text":""},{"location":"PERF_MEMORY_LAYOUT/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: In-memory layout and allocation optimizations</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>PERFORMANCE_BASELINE.md</li> <li>CRITICAL_PATHS.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> <li>FAILURE_MODEL_PHASE3.md</li> <li>ROLLBACK_AND_DISABLEMENT.md</li> <li>PERFORMANCE_OBSERVABILITY.md</li> </ul> <p>This document specifies Memory Layout Optimization as a correctness-preserving, purely in-memory optimization. If any rule in this document cannot be satisfied, the optimization MUST NOT be implemented.</p>"},{"location":"PERF_MEMORY_LAYOUT/#1-purpose","title":"1. Purpose","text":"<p>Baseline AeroDB prioritizes clarity and correctness over memory efficiency:</p> <ul> <li>Straightforward data structures</li> <li>Conservative allocation patterns</li> <li>No reliance on cache behavior</li> </ul> <p>This ensures correctness but may incur: - Poor cache locality - Excessive pointer chasing - Allocation overhead</p> <p>Memory Layout Optimization improves performance by: - Improving cache locality - Reducing allocation count - Improving data density</p> <p>While strictly preserving: - Semantics - Determinism - Recovery behavior - Replication compatibility</p> <p>Memory layout is never authoritative.</p>"},{"location":"PERF_MEMORY_LAYOUT/#2-baseline-reference-normative","title":"2. Baseline Reference (Normative)","text":"<p>Baseline memory behavior is defined implicitly in:</p> <ul> <li><code>PERFORMANCE_BASELINE.md</code> \u00a711</li> <li><code>CRITICAL_PATHS.md</code> (all sections)</li> </ul> <p>Baseline properties:</p> <ul> <li>In-memory state is discardable</li> <li>Persistent correctness does not depend on memory layout</li> <li>Restart reconstructs all in-memory state</li> <li>No memory content is assumed to persist</li> </ul> <p>These properties MUST remain true.</p>"},{"location":"PERF_MEMORY_LAYOUT/#3-definition-of-memory-layout-optimization","title":"3. Definition of Memory Layout Optimization","text":""},{"location":"PERF_MEMORY_LAYOUT/#31-conceptual-definition","title":"3.1 Conceptual Definition","text":"<p>A memory layout optimization is any change that:</p> <p>Improves performance by altering how data is laid out in memory, without changing data meaning, lifetime, or authority.</p> <p>Optimizations apply ONLY to: - In-memory representations - Transient execution state - Derived structures</p> <p>They NEVER apply to: - WAL formats - Snapshot formats - Checkpoint formats - Network formats</p>"},{"location":"PERF_MEMORY_LAYOUT/#32-explicit-non-definition-what-this-is-not","title":"3.2 Explicit Non-Definition (What This Is NOT)","text":"<p>Memory Layout Optimization does NOT allow:</p> <ul> <li>Persisted memory assumptions</li> <li>Platform-specific correctness dependencies</li> <li>Undefined behavior reliance</li> <li>Pointer reinterpretation tricks</li> <li>Alignment-based semantic inference</li> <li>Architecture-specific branching</li> </ul> <p>If correctness depends on CPU cache behavior, it is invalid.</p>"},{"location":"PERF_MEMORY_LAYOUT/#4-allowed-memory-layout-optimizations","title":"4. Allowed Memory Layout Optimizations","text":"<p>Only the following classes are permitted.</p>"},{"location":"PERF_MEMORY_LAYOUT/#41-structure-packing-and-field-reordering","title":"4.1 Structure Packing and Field Reordering","text":""},{"location":"PERF_MEMORY_LAYOUT/#description","title":"Description","text":"<p>Reorder struct fields to: - Reduce padding - Improve cache-line utilization</p>"},{"location":"PERF_MEMORY_LAYOUT/#rules","title":"Rules","text":"<ul> <li>Field semantics unchanged</li> <li>No reliance on layout outside the struct</li> <li>Explicit <code>#[repr(C)]</code> or <code>#[repr(Rust)]</code> semantics documented</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#proof-obligation","title":"Proof Obligation","text":"<ul> <li>Logical equality preserved</li> <li>Serialization unaffected</li> <li>No external ABI dependence introduced</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#42-cache-line-alignment-advisory-only","title":"4.2 Cache-Line Alignment (Advisory Only)","text":""},{"location":"PERF_MEMORY_LAYOUT/#description_1","title":"Description","text":"<p>Align frequently accessed structures to cache-line boundaries.</p>"},{"location":"PERF_MEMORY_LAYOUT/#rules_1","title":"Rules","text":"<ul> <li>Alignment is advisory, not required</li> <li>No correctness dependence on alignment</li> <li>Code must behave identically without alignment</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#proof-obligation_1","title":"Proof Obligation","text":"<ul> <li>Misalignment does not change behavior</li> <li>Alignment absence does not degrade correctness</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#43-allocation-strategy-refinement","title":"4.3 Allocation Strategy Refinement","text":""},{"location":"PERF_MEMORY_LAYOUT/#description_2","title":"Description","text":"<p>Reduce allocation overhead by: - Arena allocation - Object pooling - Bump allocators</p>"},{"location":"PERF_MEMORY_LAYOUT/#rules_2","title":"Rules","text":"<ul> <li>Allocation lifetime MUST be explicit</li> <li>No reuse of live objects</li> <li>No hidden aliasing</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#proof-obligation_2","title":"Proof Obligation","text":"<ul> <li>Object lifetimes remain correct</li> <li>Drop semantics remain correct</li> <li>Memory safety preserved</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#44-data-locality-improvements","title":"4.4 Data Locality Improvements","text":""},{"location":"PERF_MEMORY_LAYOUT/#description_3","title":"Description","text":"<p>Group frequently accessed fields together to: - Reduce cache misses - Improve traversal speed</p>"},{"location":"PERF_MEMORY_LAYOUT/#rules_3","title":"Rules","text":"<ul> <li>Access patterns must be deterministic</li> <li>No data duplication with semantic meaning</li> <li>No coupling between unrelated structures</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#proof-obligation_3","title":"Proof Obligation","text":"<ul> <li>Data access yields identical values</li> <li>Traversal order unchanged</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#45-copy-elision-safe-only","title":"4.5 Copy Elision (Safe Only)","text":""},{"location":"PERF_MEMORY_LAYOUT/#description_4","title":"Description","text":"<p>Avoid copying immutable data when: - Ownership is clear - Lifetime is bounded - Aliasing is controlled</p>"},{"location":"PERF_MEMORY_LAYOUT/#rules_4","title":"Rules","text":"<ul> <li>No mutable aliasing</li> <li>Explicit lifetime management</li> <li>Compiler-enforced safety</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#proof-obligation_4","title":"Proof Obligation","text":"<ul> <li>Data immutability guaranteed</li> <li>Use-after-free impossible</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#5-forbidden-memory-optimizations","title":"5. Forbidden Memory Optimizations","text":"<p>The following are explicitly forbidden:</p> <ul> <li>Unsafe code without proof</li> <li>Pointer arithmetic affecting semantics</li> <li>Type punning</li> <li>Bit-level reinterpretation</li> <li>Architecture-specific correctness</li> <li>Lock-free tricks relying on UB</li> <li>Relaxed memory ordering affecting logic</li> </ul> <p>If correctness depends on CPU behavior, it is invalid.</p>"},{"location":"PERF_MEMORY_LAYOUT/#6-invariant-preservation-matrix","title":"6. Invariant Preservation Matrix","text":"<p>(Referenced from <code>PERF_INVARIANTS.md</code>)</p>"},{"location":"PERF_MEMORY_LAYOUT/#durability","title":"Durability","text":"<ul> <li>D-1, D-2, D-3: Not Applicable (In-Memory Only)</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#determinism","title":"Determinism","text":"<ul> <li>DET-1 (Crash Determinism): Preserved</li> <li>DET-2 (Replay Equivalence): Preserved</li> <li>DET-3 (Bounded Execution): Preserved</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#mvcc","title":"MVCC","text":"<ul> <li>MVCC-1 (Snapshot Isolation): Preserved</li> <li>MVCC-2 (CommitId Authority): Preserved</li> <li>MVCC-3 (Version Chain Integrity): Preserved</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#replication","title":"Replication","text":"<ul> <li>REP-1, REP-2, REP-3: Preserved</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#failure-recovery","title":"Failure &amp; Recovery","text":"<ul> <li>FR-1, FR-2, FR-3: Preserved</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#observability","title":"Observability","text":"<ul> <li>OBS-1, OBS-2: Preserved</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#disablement","title":"Disablement","text":"<ul> <li>DIS-1, DIS-2, DIS-3: Preserved</li> </ul>"},{"location":"PERF_MEMORY_LAYOUT/#7-semantic-equivalence-argument","title":"7. Semantic Equivalence Argument","text":"<p>Memory Layout Optimization is semantically equivalent to baseline because:</p> <ul> <li>Only in-memory representation changes</li> <li>Logical state remains identical</li> <li>Persistent state is unaffected</li> <li>Recovery reconstructs state identically</li> <li>Replication is unaffected</li> </ul> <p>Any difference is invisible to all observers.</p>"},{"location":"PERF_MEMORY_LAYOUT/#8-failure-matrix","title":"8. Failure Matrix","text":""},{"location":"PERF_MEMORY_LAYOUT/#81-crash-during-execution","title":"8.1 Crash During Execution","text":"<ul> <li>In-memory state lost</li> <li>Recovery reconstructs state</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_MEMORY_LAYOUT/#82-allocation-failure","title":"8.2 Allocation Failure","text":"<ul> <li>Baseline: operation fails</li> <li>Optimized: operation fails</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_MEMORY_LAYOUT/#83-memory-fragmentation","title":"8.3 Memory Fragmentation","text":"<ul> <li>Baseline: degraded performance</li> <li>Optimized: degraded performance</li> </ul> <p>Correctness unaffected.</p>"},{"location":"PERF_MEMORY_LAYOUT/#9-recovery-proof","title":"9. Recovery Proof","text":"<ul> <li>Recovery does not consult in-memory layout</li> <li>WAL replay unaffected</li> <li>Snapshot loading unaffected</li> <li>Index rebuild unaffected</li> </ul> <p>Recovery behavior is identical.</p>"},{"location":"PERF_MEMORY_LAYOUT/#10-disablement-rollback","title":"10. Disablement &amp; Rollback","text":""},{"location":"PERF_MEMORY_LAYOUT/#101-disablement-mechanism","title":"10.1 Disablement Mechanism","text":"<p>Memory layout optimizations MUST be disableable via:</p> <ul> <li>Compile-time flag or</li> <li>Startup configuration</li> </ul> <p>Disablement restores: - Baseline allocation paths - Baseline structure layouts</p>"},{"location":"PERF_MEMORY_LAYOUT/#102-compatibility-proof","title":"10.2 Compatibility Proof","text":"<ul> <li>WAL unchanged</li> <li>Snapshot unchanged</li> <li>Checkpoint unchanged</li> </ul> <p>Data compatibility is guaranteed.</p>"},{"location":"PERF_MEMORY_LAYOUT/#103-no-ghost-state","title":"10.3 No Ghost State","text":"<ul> <li>No persistent memory assumptions</li> <li>No hidden metadata</li> <li>No runtime layout flags persisted</li> </ul> <p>All layout choices are ephemeral.</p>"},{"location":"PERF_MEMORY_LAYOUT/#11-observability","title":"11. Observability","text":"<p>Permitted metrics (passive only):</p> <ul> <li>memory.allocations.count</li> <li>memory.arena.usage</li> <li>memory.copy_elision.count</li> <li>memory.cache_line.utilization (approximate)</li> </ul> <p>Metrics MUST NOT: - Influence allocation strategy - Influence layout selection - Influence execution flow</p>"},{"location":"PERF_MEMORY_LAYOUT/#12-testing-requirements","title":"12. Testing Requirements","text":"<p>Memory Layout Optimization MUST introduce:</p> <ul> <li>Layout equivalence tests</li> <li>Allocation lifetime tests</li> <li>Stress tests under memory pressure</li> <li>Disablement equivalence tests</li> <li>Crash recovery tests</li> </ul> <p>All existing tests MUST pass unmodified.</p>"},{"location":"PERF_MEMORY_LAYOUT/#13-explicit-non-goals","title":"13. Explicit Non-Goals","text":"<p>Memory Layout Optimization does NOT aim to:</p> <ul> <li>Change data models</li> <li>Introduce unsafe performance hacks</li> <li>Depend on hardware features</li> <li>Improve persistence efficiency</li> </ul> <p>It improves in-memory execution cost only.</p>"},{"location":"PERF_MEMORY_LAYOUT/#14-final-rule","title":"14. Final Rule","text":"<p>Memory layout may change how fast AeroDB runs, but it must never change what AeroDB is.</p> <p>If a memory optimization can affect correctness, it does not belong in Phase 3.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_OBSERVABILITY/","title":"PERFORMANCE OBSERVABILITY \u2014 PHASE 3","text":""},{"location":"PERF_OBSERVABILITY/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: Measurement-only, non-influential</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>PERFORMANCE_BASELINE.md</li> <li>CRITICAL_PATHS.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> </ul> <p>This document defines the only allowed observability mechanisms for performance analysis in Phase 3.</p> <p>If observability influences behavior, correctness, ordering, or timing, it violates Phase 3 invariants and is forbidden.</p>"},{"location":"PERF_OBSERVABILITY/#1-purpose","title":"1. Purpose","text":"<p>Phase 3 requires insight into performance without changing semantics.</p> <p>This document defines: - What performance data may be collected - Where instrumentation may exist - What instrumentation MUST NOT do - How determinism is preserved</p> <p>Observability exists to observe, never to decide.</p>"},{"location":"PERF_OBSERVABILITY/#2-observability-principle","title":"2. Observability Principle","text":""},{"location":"PERF_OBSERVABILITY/#observability-principle-binding","title":"OBSERVABILITY PRINCIPLE (Binding)","text":"<p>Observability MUST be strictly passive.</p> <p>This means: - Observability may record - Observability may count - Observability may timestamp - Observability may expose metrics</p> <p>It may never: - Influence control flow - Influence scheduling - Influence batching - Influence retry logic - Influence resource usage decisions</p> <p>If removing observability changes behavior, observability is incorrect.</p>"},{"location":"PERF_OBSERVABILITY/#3-permitted-observability-outputs","title":"3. Permitted Observability Outputs","text":"<p>The following outputs are permitted:</p>"},{"location":"PERF_OBSERVABILITY/#31-metrics","title":"3.1 Metrics","text":"<ul> <li>Counters</li> <li>Gauges</li> <li>Histograms</li> <li>Deterministic timers</li> </ul> <p>Metrics MUST: - Be monotonic where applicable - Have explicit units - Be emitted in deterministic order</p>"},{"location":"PERF_OBSERVABILITY/#32-logs","title":"3.2 Logs","text":"<ul> <li>Structured logs</li> <li>Event logs</li> <li>Lifecycle logs</li> </ul> <p>Logs MUST: - Be append-only - Never gate behavior - Never suppress errors</p>"},{"location":"PERF_OBSERVABILITY/#33-traces-internal-only","title":"3.3 Traces (Internal Only)","text":"<ul> <li>Internal execution spans</li> <li>Phase boundaries</li> <li>Critical path markers</li> </ul> <p>Traces MUST: - Be disabled by default - Not alter execution shape - Not allocate unbounded memory</p>"},{"location":"PERF_OBSERVABILITY/#4-forbidden-observability-patterns","title":"4. Forbidden Observability Patterns","text":"<p>The following patterns are explicitly forbidden:</p> <ul> <li>Metric-driven branching</li> <li>Threshold-based behavior changes</li> <li>Adaptive batching using metrics</li> <li>Backpressure driven by observability</li> <li>Sampling that affects execution</li> <li>Best-effort metric emission</li> <li>Dropping metrics silently</li> <li>Async observability affecting ordering</li> </ul> <p>Observability MUST NOT introduce feedback loops.</p>"},{"location":"PERF_OBSERVABILITY/#5-determinism-requirements","title":"5. Determinism Requirements","text":""},{"location":"PERF_OBSERVABILITY/#51-deterministic-emission","title":"5.1 Deterministic Emission","text":"<p>Observability output MUST be:</p> <ul> <li>Deterministically ordered</li> <li>Independent of scheduling</li> <li>Independent of timing variance</li> </ul> <p>For identical executions: - Metric sequences MUST be identical - Log sequences MUST be identical (excluding timestamps if explicitly allowed)</p>"},{"location":"PERF_OBSERVABILITY/#52-timestamp-rules","title":"5.2 Timestamp Rules","text":"<p>Timestamps: - MAY be recorded - MUST NOT be interpreted - MUST NOT affect control flow</p> <p>Timestamps are diagnostic only.</p>"},{"location":"PERF_OBSERVABILITY/#6-placement-rules","title":"6. Placement Rules","text":""},{"location":"PERF_OBSERVABILITY/#61-critical-path-instrumentation","title":"6.1 Critical Path Instrumentation","text":"<p>Instrumentation MAY exist on critical paths ONLY if:</p> <ul> <li>It does not allocate unbounded memory</li> <li>It does not block</li> <li>It does not perform I/O</li> <li>It does not acquire new locks</li> </ul> <p>If instrumentation adds blocking or contention, it is invalid.</p>"},{"location":"PERF_OBSERVABILITY/#62-non-critical-paths","title":"6.2 Non-Critical Paths","text":"<p>Heavier instrumentation MAY exist on non-critical paths ONLY if:</p> <ul> <li>It is explicitly documented</li> <li>It is disableable</li> <li>It does not influence critical paths</li> </ul>"},{"location":"PERF_OBSERVABILITY/#7-error-handling-in-observability","title":"7. Error Handling in Observability","text":"<ul> <li>Observability failures MUST NOT affect execution</li> <li>Metrics emission failures MUST be ignored safely</li> <li>Logging failures MUST NOT suppress errors</li> </ul> <p>If observability fails, the system continues unmodified.</p>"},{"location":"PERF_OBSERVABILITY/#8-interaction-with-optimizations","title":"8. Interaction with Optimizations","text":"<p>Optimizations MUST NOT:</p> <ul> <li>Read observability outputs</li> <li>Infer state from metrics</li> <li>Use observability to tune behavior</li> <li>Depend on observability being enabled</li> </ul> <p>Observability MUST remain orthogonal to optimization logic.</p>"},{"location":"PERF_OBSERVABILITY/#9-configuration-rules","title":"9. Configuration Rules","text":""},{"location":"PERF_OBSERVABILITY/#91-enablement","title":"9.1 Enablement","text":"<ul> <li>Observability may be enabled or disabled at startup</li> <li>Enablement MUST NOT change behavior</li> <li>Enablement MUST NOT affect recovery</li> </ul>"},{"location":"PERF_OBSERVABILITY/#92-runtime-changes","title":"9.2 Runtime Changes","text":"<p>Runtime observability toggling is allowed ONLY if:</p> <ul> <li>It does not alter code paths</li> <li>It does not alter allocation patterns</li> <li>It does not alter execution order</li> </ul> <p>If toggling changes execution shape, it is forbidden.</p>"},{"location":"PERF_OBSERVABILITY/#10-observability-and-failure-model","title":"10. Observability and Failure Model","text":"<p>Observability MUST be correct under failures:</p> <ul> <li>Crash during metric emission</li> <li>Crash during logging</li> <li>Partial observability output</li> </ul> <p>Failure outcomes: - MUST NOT corrupt WAL - MUST NOT corrupt snapshots - MUST NOT affect recovery</p> <p>Observability state is non-authoritative and discardable.</p>"},{"location":"PERF_OBSERVABILITY/#11-testing-requirements","title":"11. Testing Requirements","text":"<p>Observability MUST be tested to prove:</p> <ul> <li>Removal does not change behavior</li> <li>Enablement does not change behavior</li> <li>Failures in observability do not affect execution</li> </ul> <p>Tests MUST: - Compare observable DB behavior with and without observability - Pass all Phase 1 and Phase 2 regressions unmodified</p>"},{"location":"PERF_OBSERVABILITY/#12-explicit-non-goals","title":"12. Explicit Non-Goals","text":"<p>Performance observability does NOT aim to:</p> <ul> <li>Auto-tune AeroDB</li> <li>Adapt execution strategies</li> <li>Replace profiling tools</li> <li>Predict performance</li> </ul> <p>It exists only to measure what already happens.</p>"},{"location":"PERF_OBSERVABILITY/#13-proof-obligations","title":"13. Proof Obligations","text":"<p>Any Phase 3 optimization that adds observability MUST:</p> <ul> <li>Reference this document</li> <li>Prove passivity</li> <li>Prove determinism</li> <li>Prove disablement safety</li> </ul> <p>If proof is omitted, optimization is invalid.</p>"},{"location":"PERF_OBSERVABILITY/#14-final-rule","title":"14. Final Rule","text":"<p>Observability that influences behavior is no longer observability \u2014 it is control logic.</p> <p>Phase 3 permits measurement only. All decision-making remains explicit and semantic.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_PROOF_RULES/","title":"PHASE 3 \u2014 PROOF RULES","text":""},{"location":"PERF_PROOF_RULES/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Applies to: All Phase 3 optimization specifications and implementations</li> <li>Dependency:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> </ul> <p>No Phase 3 code may be written, merged, or enabled without satisfying the proof rules in this document.</p>"},{"location":"PERF_PROOF_RULES/#1-purpose","title":"1. Purpose","text":"<p>Phase 3 introduces performance optimizations without changing semantics.</p> <p>Because semantics are frozen, proof precedes code.</p> <p>This document defines: - What constitutes a valid proof - What must be proven - How equivalence is established - When proof is considered insufficient - When an optimization must be rejected</p> <p>Proofs are not informal reasoning; they are structured, explicit arguments tied to invariants.</p>"},{"location":"PERF_PROOF_RULES/#2-definition-of-a-proof-in-aerodb","title":"2. Definition of a \u201cProof\u201d in AeroDB","text":"<p>A Phase 3 proof is a structured, checkable argument that demonstrates:</p> <p>Optimized execution is observationally equivalent to baseline execution under all allowed failures.</p> <p>A proof MUST: - Be written in the optimization\u2019s markdown specification - Reference invariants explicitly - Enumerate failure cases - Define equivalence criteria - Be independent of implementation details where possible</p> <p>If behavior cannot be proven equivalent, the optimization is invalid.</p>"},{"location":"PERF_PROOF_RULES/#3-proof-scope","title":"3. Proof Scope","text":"<p>Every proof MUST cover all of the following domains:</p> <ol> <li>Durability</li> <li>Determinism</li> <li>MVCC Visibility</li> <li>Replication Safety (if applicable)</li> <li>Failure &amp; Recovery</li> <li>Disablement &amp; Rollback</li> </ol> <p>Omission of any domain constitutes proof failure.</p>"},{"location":"PERF_PROOF_RULES/#4-mandatory-proof-structure","title":"4. Mandatory Proof Structure","text":"<p>Every Phase 3 optimization document MUST contain the following sections, in the order listed.</p>"},{"location":"PERF_PROOF_RULES/#41-baseline-semantics","title":"4.1 Baseline Semantics","text":"<p>This section MUST describe:</p> <ul> <li>Current (pre-optimization) behavior</li> <li>Precise ordering of operations</li> <li>Existing durability boundaries</li> <li>WAL emission behavior</li> <li>MVCC visibility checkpoints</li> </ul> <p>Rules: - No hand-waving - No \u201cas implemented\u201d shortcuts - If baseline behavior is unclear, STOP and specify it first</p>"},{"location":"PERF_PROOF_RULES/#42-optimization-description","title":"4.2 Optimization Description","text":"<p>This section MUST describe:</p> <ul> <li>Exact mechanical change</li> <li>What is removed, reordered, or combined</li> <li>What remains unchanged</li> <li>What new structure (if any) is introduced</li> </ul> <p>Rules: - No pseudocode shortcuts - No implicit behavior - No future work placeholders</p> <p>If the optimization cannot be described mechanically, it is invalid.</p>"},{"location":"PERF_PROOF_RULES/#43-invariant-impact-matrix","title":"4.3 Invariant Impact Matrix","text":"<p>This section MUST list every invariant from <code>PERF_INVARIANTS.md</code> and classify it as:</p> <ul> <li>Preserved without interaction</li> <li>Preserved with proof (reference section)</li> <li>Not applicable (with justification)</li> </ul> <p>Rules: - Each invariant MUST be mentioned explicitly - Silence implies violation</p>"},{"location":"PERF_PROOF_RULES/#44-equivalence-argument","title":"4.4 Equivalence Argument","text":"<p>This section MUST prove that optimized execution is equivalent to baseline execution.</p> <p>Equivalence MUST be argued in terms of: - Observable outputs - Persisted state - Recovery results</p> <p>At minimum, the argument MUST address:</p> <ul> <li>WAL contents equivalence</li> <li>Commit ordering equivalence</li> <li>Visibility equivalence</li> <li>Error surface equivalence</li> </ul> <p>Rules: - Performance differences are irrelevant - Internal timing is irrelevant - Only observable behavior matters</p>"},{"location":"PERF_PROOF_RULES/#45-failure-matrix","title":"4.5 Failure Matrix","text":"<p>This section MUST enumerate behavior under failures at every boundary.</p> <p>Minimum required failures: - Process crash - Power loss - Partial WAL write - Partial fsync - Disk error - Replica disconnect (if applicable)</p> <p>For each failure: - Describe baseline outcome - Describe optimized outcome - Prove equivalence</p> <p>Rules: - \u201cSame as baseline\u201d is not sufficient without explanation - Failure ordering must be explicit</p>"},{"location":"PERF_PROOF_RULES/#46-recovery-proof","title":"4.6 Recovery Proof","text":"<p>This section MUST prove:</p> <ul> <li>WAL replay remains deterministic</li> <li>Replay is idempotent</li> <li>No optimization-specific side effects occur during replay</li> </ul> <p>Rules: - Replay code MUST NOT branch on optimization presence - If replay behavior differs, optimization is invalid</p>"},{"location":"PERF_PROOF_RULES/#47-disablement-rollback-proof","title":"4.7 Disablement &amp; Rollback Proof","text":"<p>This section MUST prove:</p> <ul> <li>Optimization can be disabled safely</li> <li>Data written with optimization enabled is readable without it</li> <li>No persistent ghost state exists</li> </ul> <p>Rules: - Disablement MUST NOT require data migration - WAL format compatibility is mandatory</p>"},{"location":"PERF_PROOF_RULES/#48-residual-risk-analysis","title":"4.8 Residual Risk Analysis","text":"<p>This section MUST list: - Known non-risks (explicitly ruled out) - Any remaining assumptions (must be structural, not heuristic)</p> <p>Rules: - \u201cLow probability\u201d is not an argument - Hardware reliability assumptions must match Phase 1</p>"},{"location":"PERF_PROOF_RULES/#5-proof-style-rules","title":"5. Proof Style Rules","text":"<p>Proofs MUST be:</p> <ul> <li>Explicit</li> <li>Deterministic</li> <li>Mechanically checkable</li> <li>Free of probabilistic language</li> </ul> <p>The following phrases are forbidden in proofs: - \u201cUsually\u201d - \u201cIn practice\u201d - \u201cShould be safe\u201d - \u201cExpected to\u201d - \u201cAssumed\u201d - \u201cLikely\u201d</p> <p>If a proof relies on timing, load, or fairness, it is invalid.</p>"},{"location":"PERF_PROOF_RULES/#6-what-is-not-a-proof","title":"6. What Is NOT a Proof","text":"<p>The following do NOT constitute proof:</p> <ul> <li>Benchmarks</li> <li>Microbenchmarks</li> <li>Performance graphs</li> <li>Empirical testing alone</li> <li>Fuzzing without equivalence arguments</li> <li>\u201cWorks on restart\u201d claims</li> </ul> <p>Testing supports proofs; it does not replace them.</p>"},{"location":"PERF_PROOF_RULES/#7-proof-review-rules","title":"7. Proof Review Rules","text":"<p>Before an optimization may be accepted:</p> <ul> <li>Proof must be reviewed independently</li> <li>All invariants must be checked off</li> <li>Failure matrix must be complete</li> <li>Equivalence argument must be explicit</li> </ul> <p>If reviewers disagree: - The optimization is rejected - Ambiguity favors correctness</p>"},{"location":"PERF_PROOF_RULES/#8-proof-vs-implementation-ordering","title":"8. Proof vs Implementation Ordering","text":"<p>The required order is:</p> <ol> <li>Baseline specification</li> <li>Optimization specification</li> <li>Proof completion</li> <li>Proof review acceptance</li> <li>Implementation</li> <li>Regression testing</li> </ol> <p>Deviation from this order is forbidden.</p>"},{"location":"PERF_PROOF_RULES/#9-handling-insufficient-proof","title":"9. Handling Insufficient Proof","text":"<p>If proof is insufficient:</p> <ul> <li>The optimization is not \u201cparked\u201d</li> <li>The optimization is not \u201cexperimental\u201d</li> <li>The optimization is rejected</li> </ul> <p>Phase 3 does not allow speculative optimizations.</p>"},{"location":"PERF_PROOF_RULES/#10-final-rule","title":"10. Final Rule","text":"<p>In AeroDB, performance is optional. Correctness is mandatory. Proof is the price of optimization.</p> <p>If proof cannot be completed, optimization does not proceed.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_READ_PATH/","title":"READ PATH OPTIMIZATION \u2014 PHASE 3","text":""},{"location":"PERF_READ_PATH/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: Read-only performance optimizations</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>PERFORMANCE_BASELINE.md</li> <li>CRITICAL_PATHS.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> <li>FAILURE_MODEL_PHASE3.md</li> <li>ROLLBACK_AND_DISABLEMENT.md</li> <li>PERFORMANCE_OBSERVABILITY.md</li> </ul> <p>This document specifies read-path optimizations that preserve snapshot isolation, determinism, and replication safety.</p> <p>Any optimization described here MUST be provably read-only and MUST NOT alter MVCC visibility, ordering, or failure behavior.</p>"},{"location":"PERF_READ_PATH/#1-purpose","title":"1. Purpose","text":"<p>Baseline AeroDB read behavior prioritizes correctness:</p> <ul> <li>Explicit MVCC visibility checks</li> <li>Deterministic version-chain traversal</li> <li>No speculative caching</li> <li>No read shortcuts</li> </ul> <p>This yields correct but potentially expensive reads.</p> <p>Read Path Optimization improves performance by: - Eliminating redundant work - Reducing repeated traversal - Avoiding unnecessary allocations</p> <p>While strictly preserving: - Snapshot isolation - Visibility semantics - Deterministic behavior</p>"},{"location":"PERF_READ_PATH/#2-baseline-reference-normative","title":"2. Baseline Reference (Normative)","text":"<p>Baseline read behavior is defined in:</p> <ul> <li><code>PERFORMANCE_BASELINE.md</code> \u00a74</li> <li><code>CRITICAL_PATHS.md</code> \u00a73</li> </ul> <p>Baseline invariants:</p> <ul> <li>Every read evaluates MVCC visibility explicitly</li> <li>Version chains are traversed in CommitId order</li> <li>No read observes uncommitted or future data</li> <li>Reads do not mutate persistent state</li> </ul> <p>These properties MUST remain true.</p>"},{"location":"PERF_READ_PATH/#3-definition-of-read-path-optimization","title":"3. Definition of Read Path Optimization","text":""},{"location":"PERF_READ_PATH/#31-conceptual-definition","title":"3.1 Conceptual Definition","text":"<p>A read-path optimization is any change that:</p> <p>Reduces the cost of determining which committed version is visible to a snapshot, without changing the result.</p> <p>All optimizations are: - Read-only - Snapshot-scoped - Deterministic - Discardable</p>"},{"location":"PERF_READ_PATH/#32-explicit-non-definition-what-this-is-not","title":"3.2 Explicit Non-Definition (What This Is NOT)","text":"<p>Read Path Optimization does NOT allow:</p> <ul> <li>Skipping MVCC visibility checks</li> <li>Pre-committing visibility</li> <li>Read-your-own-writes shortcuts</li> <li>Cross-snapshot caching</li> <li>Adaptive or speculative behavior</li> <li>Time-based cache expiry</li> </ul> <p>If visibility is inferred instead of proven, the optimization is invalid.</p>"},{"location":"PERF_READ_PATH/#4-allowed-optimization-classes","title":"4. Allowed Optimization Classes","text":"<p>Only the following read optimizations are permitted.</p>"},{"location":"PERF_READ_PATH/#41-snapshot-local-visibility-caching","title":"4.1 Snapshot-Local Visibility Caching","text":""},{"location":"PERF_READ_PATH/#description","title":"Description","text":"<p>Within a single snapshot, cache the result of:</p> <ul> <li>Version-chain traversal</li> <li>Visibility decision</li> </ul> <p>Keyed by: - Document identifier - Snapshot CommitId</p>"},{"location":"PERF_READ_PATH/#rules","title":"Rules","text":"<ul> <li>Cache is valid ONLY for one snapshot</li> <li>Cache MUST be discarded when snapshot ends</li> <li>Cache entries are immutable</li> </ul>"},{"location":"PERF_READ_PATH/#proof-obligation","title":"Proof Obligation","text":"<ul> <li>Cached result equals traversal result</li> <li>No snapshot mutation occurs</li> <li>No cross-snapshot leakage</li> </ul>"},{"location":"PERF_READ_PATH/#42-deterministic-short-circuit-traversal","title":"4.2 Deterministic Short-Circuit Traversal","text":""},{"location":"PERF_READ_PATH/#description_1","title":"Description","text":"<p>If version chains are ordered by CommitId:</p> <ul> <li>Stop traversal once first visible version is found</li> </ul> <p>(This matches baseline semantics but avoids unnecessary work.)</p>"},{"location":"PERF_READ_PATH/#rules_1","title":"Rules","text":"<ul> <li>Order MUST be explicit</li> <li>Visibility MUST be checked</li> <li>No speculative skipping</li> </ul>"},{"location":"PERF_READ_PATH/#proof-obligation_1","title":"Proof Obligation","text":"<ul> <li>Later versions cannot be visible</li> <li>Earlier versions are superseded</li> </ul>"},{"location":"PERF_READ_PATH/#43-zero-copy-read-materialization","title":"4.3 Zero-Copy Read Materialization","text":""},{"location":"PERF_READ_PATH/#description_2","title":"Description","text":"<p>Avoid copying document data when:</p> <ul> <li>Data is immutable</li> <li>Lifetime exceeds read duration</li> <li>Snapshot guarantees immutability</li> </ul>"},{"location":"PERF_READ_PATH/#rules_2","title":"Rules","text":"<ul> <li>No mutable aliasing</li> <li>No shared ownership beyond snapshot</li> <li>Memory safety must be explicit</li> </ul>"},{"location":"PERF_READ_PATH/#proof-obligation_2","title":"Proof Obligation","text":"<ul> <li>Data cannot change</li> <li>Snapshot lifetime bounds usage</li> </ul>"},{"location":"PERF_READ_PATH/#44-index-assisted-visibility-filtering-read-only","title":"4.4 Index-Assisted Visibility Filtering (Read-Only)","text":""},{"location":"PERF_READ_PATH/#description_3","title":"Description","text":"<p>Use existing in-memory indexes to:</p> <ul> <li>Narrow candidate version sets</li> <li>Without skipping visibility checks</li> </ul>"},{"location":"PERF_READ_PATH/#rules_3","title":"Rules","text":"<ul> <li>Indexes are advisory only</li> <li>Visibility check is mandatory</li> <li>Index absence must not affect correctness</li> </ul>"},{"location":"PERF_READ_PATH/#5-forbidden-read-optimizations","title":"5. Forbidden Read Optimizations","text":"<p>The following are explicitly forbidden:</p> <ul> <li>Skipping visibility checks</li> <li>Caching across snapshots</li> <li>Global read caches</li> <li>Heuristic pruning</li> <li>Time-based invalidation</li> <li>Read-write coupling</li> <li>Replica-only visibility shortcuts</li> <li>Opportunistic consistency</li> </ul> <p>If correctness depends on cache freshness, the optimization is invalid.</p>"},{"location":"PERF_READ_PATH/#6-invariant-preservation-matrix","title":"6. Invariant Preservation Matrix","text":"<p>(Referenced from <code>PERF_INVARIANTS.md</code>)</p>"},{"location":"PERF_READ_PATH/#durability","title":"Durability","text":"<ul> <li>D-1, D-2, D-3: Not Applicable (Read-Only)</li> </ul>"},{"location":"PERF_READ_PATH/#determinism","title":"Determinism","text":"<ul> <li>DET-1 (Crash Determinism): Preserved</li> <li>DET-2 (Replay Equivalence): Preserved</li> <li>DET-3 (Bounded Execution): Preserved</li> </ul>"},{"location":"PERF_READ_PATH/#mvcc","title":"MVCC","text":"<ul> <li>MVCC-1 (Snapshot Isolation): Preserved</li> <li>MVCC-2 (CommitId Authority): Preserved</li> <li>MVCC-3 (Version Chain Integrity): Preserved</li> </ul>"},{"location":"PERF_READ_PATH/#replication","title":"Replication","text":"<ul> <li>REP-1, REP-2, REP-3: Preserved</li> </ul>"},{"location":"PERF_READ_PATH/#failure-recovery","title":"Failure &amp; Recovery","text":"<ul> <li>FR-1, FR-2, FR-3: Preserved</li> </ul>"},{"location":"PERF_READ_PATH/#observability","title":"Observability","text":"<ul> <li>OBS-1, OBS-2: Preserved</li> </ul>"},{"location":"PERF_READ_PATH/#disablement","title":"Disablement","text":"<ul> <li>DIS-1, DIS-2, DIS-3: Preserved</li> </ul>"},{"location":"PERF_READ_PATH/#7-semantic-equivalence-argument","title":"7. Semantic Equivalence Argument","text":"<p>Read Path Optimization is semantically equivalent to baseline because:</p> <ul> <li>For any snapshot and document:</li> <li>The same version is selected</li> <li>The same data is returned</li> <li>Visibility rules are evaluated identically</li> <li>No persistent state is modified</li> <li>No ordering is changed</li> </ul> <p>Optimizations only reduce how much work is done, not what is decided.</p>"},{"location":"PERF_READ_PATH/#8-failure-matrix","title":"8. Failure Matrix","text":""},{"location":"PERF_READ_PATH/#81-crash-during-read","title":"8.1 Crash During Read","text":"<ul> <li>Baseline: read aborted, no state change</li> <li>Optimized: read aborted, no state change</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_READ_PATH/#82-crash-after-cache-population","title":"8.2 Crash After Cache Population","text":"<ul> <li>Cache is in-memory only</li> <li>Cache is discarded on restart</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_READ_PATH/#83-memory-allocation-failure","title":"8.3 Memory Allocation Failure","text":"<ul> <li>Baseline: read fails</li> <li>Optimized: read fails</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_READ_PATH/#9-recovery-proof","title":"9. Recovery Proof","text":"<ul> <li>Read optimizations do not affect WAL</li> <li>No persistent read state exists</li> <li>Recovery logic is unchanged</li> </ul> <p>Replay behavior is identical.</p>"},{"location":"PERF_READ_PATH/#10-disablement-rollback","title":"10. Disablement &amp; Rollback","text":""},{"location":"PERF_READ_PATH/#101-disablement-mechanism","title":"10.1 Disablement Mechanism","text":"<p>Read optimizations MUST be disableable via:</p> <ul> <li>Compile-time flag or</li> <li>Startup configuration</li> </ul> <p>Disablement restores: - Baseline traversal - Baseline allocation behavior</p>"},{"location":"PERF_READ_PATH/#102-compatibility-proof","title":"10.2 Compatibility Proof","text":"<ul> <li>No WAL changes</li> <li>No snapshot changes</li> <li>No checkpoint changes</li> </ul> <p>Data is always readable.</p>"},{"location":"PERF_READ_PATH/#103-no-ghost-state","title":"10.3 No Ghost State","text":"<ul> <li>No persistent caches</li> <li>No hidden metadata</li> <li>No optimization markers</li> </ul> <p>All state is in-memory and snapshot-scoped.</p>"},{"location":"PERF_READ_PATH/#11-observability","title":"11. Observability","text":"<p>Permitted metrics (passive only):</p> <ul> <li>read_path.version_chain_traversals</li> <li>read_path.cache_hits</li> <li>read_path.cache_misses</li> <li>read_path.materialization_copies</li> </ul> <p>Metrics MUST NOT: - Influence caching - Influence traversal - Influence allocation</p>"},{"location":"PERF_READ_PATH/#12-testing-requirements","title":"12. Testing Requirements","text":"<p>Read Path Optimization MUST introduce:</p> <ul> <li>Snapshot equivalence tests</li> <li>Cache correctness tests</li> <li>Cross-snapshot isolation tests</li> <li>Crash-during-read tests</li> <li>Disablement equivalence tests</li> </ul> <p>All existing tests MUST pass unmodified.</p>"},{"location":"PERF_READ_PATH/#13-explicit-non-goals","title":"13. Explicit Non-Goals","text":"<p>Read Path Optimization does NOT aim to:</p> <ul> <li>Change isolation levels</li> <li>Improve write performance</li> <li>Introduce speculative reads</li> <li>Relax MVCC rules</li> </ul> <p>It optimizes execution cost only.</p>"},{"location":"PERF_READ_PATH/#14-final-rule","title":"14. Final Rule","text":"<p>A faster read that returns the wrong version is worse than a slow read.</p> <p>Read-path optimizations are valid only when they are invisible to all observers.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/","title":"REPLICA READ FAST PATH \u2014 PHASE 3","text":""},{"location":"PERF_REPLICA_READ_FAST_PATH/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: Replica-side read-only performance optimization</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>PERFORMANCE_BASELINE.md</li> <li>CRITICAL_PATHS.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> <li>FAILURE_MODEL_PHASE3.md</li> <li>ROLLBACK_AND_DISABLEMENT.md</li> <li>PERFORMANCE_OBSERVABILITY.md</li> </ul> <p>This document specifies Replica Read Fast Path as a correctness-preserving, read-only optimization. If any rule in this document cannot be proven, the optimization MUST NOT be implemented.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#1-purpose","title":"1. Purpose","text":"<p>Baseline replica behavior is conservative:</p> <ul> <li>Replica consumes WAL strictly as a prefix</li> <li>Replica serves reads only when MVCC-safe</li> <li>Replica performs the same read logic as primary</li> </ul> <p>This guarantees correctness but may result in: - Higher read latency - Redundant MVCC checks - Repeated visibility computation</p> <p>Replica Read Fast Path improves performance by: - Avoiding redundant work for already-proven-safe snapshots - Reducing read-path overhead on replicas only</p> <p>This optimization does not: - Change replication semantics - Change visibility rules - Allow speculative or stale reads - Introduce replica-only semantics</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#2-baseline-reference-normative","title":"2. Baseline Reference (Normative)","text":"<p>Baseline replica read behavior is defined in:</p> <ul> <li><code>PERFORMANCE_BASELINE.md</code> \u00a79</li> <li><code>CRITICAL_PATHS.md</code> \u00a77</li> <li>Replication design documents (Phase 2B, frozen)</li> </ul> <p>Baseline invariants:</p> <ul> <li>Replica WAL is a strict prefix of primary WAL</li> <li>Replica assigns no CommitIds</li> <li>Replica visibility is MVCC-governed</li> <li>Replica may serve reads only for MVCC-safe snapshots</li> <li>Replica state is always derivable from WAL + snapshots</li> </ul> <p>These invariants MUST remain true.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#3-definition-of-replica-read-fast-path","title":"3. Definition of Replica Read Fast Path","text":""},{"location":"PERF_REPLICA_READ_FAST_PATH/#31-conceptual-definition","title":"3.1 Conceptual Definition","text":"<p>Replica Read Fast Path allows:</p> <p>A replica to perform reads using pre-validated snapshot visibility when it is provably impossible for additional WAL to affect the result.</p> <p>The optimization applies only when: - Snapshot CommitId is \u2264 replica\u2019s durable WAL CommitId - Replica is not lagging behind that snapshot - No visibility ambiguity exists</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#32-explicit-non-definition-what-this-is-not","title":"3.2 Explicit Non-Definition (What This Is NOT)","text":"<p>Replica Read Fast Path does NOT allow:</p> <ul> <li>Reading ahead of WAL durability</li> <li>Reading unreplicated commits</li> <li>Divergent visibility rules</li> <li>Replica-local CommitId inference</li> <li>Stale reads masked as fresh</li> <li>Heuristic lag thresholds</li> <li>Time-based safety assumptions</li> </ul> <p>If safety depends on \u201cprobably caught up\u201d, the optimization is invalid.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#4-safety-preconditions","title":"4. Safety Preconditions","text":"<p>Replica Read Fast Path MAY be used only if all of the following hold:</p> <ol> <li>Replica has durably applied WAL up to CommitId R</li> <li>Requested snapshot CommitId S \u2264 R</li> <li>Snapshot S is immutable</li> <li>No WAL gaps exist</li> <li>Replica is not mid-recovery</li> <li>Replica is not mid-snapshot-bootstrap</li> </ol> <p>If any precondition fails, replica MUST fall back to baseline read behavior.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#5-mechanical-description","title":"5. Mechanical Description","text":""},{"location":"PERF_REPLICA_READ_FAST_PATH/#51-baseline-replica-read-path","title":"5.1 Baseline Replica Read Path","text":"<p>For each read:</p> <ol> <li>Validate replica is MVCC-safe</li> <li>Acquire snapshot</li> <li>Traverse version chain</li> <li>Apply visibility rules</li> <li>Materialize document</li> <li>Return result</li> </ol>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#52-replica-read-fast-path","title":"5.2 Replica Read Fast Path","text":"<p>Under Replica Read Fast Path:</p> <ol> <li>Validate safety preconditions</li> <li>Reuse pre-validated snapshot visibility boundary</li> <li>Traverse version chain</li> <li>Materialize document</li> <li>Return result</li> </ol> <p>Differences: - No re-validation of WAL prefix per read - No re-computation of snapshot safety - No speculative shortcuts</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#6-invariant-preservation-matrix","title":"6. Invariant Preservation Matrix","text":"<p>(Referenced from <code>PERF_INVARIANTS.md</code>)</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#durability","title":"Durability","text":"<ul> <li>D-1, D-2, D-3: Not Applicable (Read-Only)</li> </ul>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#determinism","title":"Determinism","text":"<ul> <li>DET-1 (Crash Determinism): Preserved</li> <li>DET-2 (Replay Equivalence): Preserved</li> <li>DET-3 (Bounded Execution): Preserved</li> </ul>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#mvcc","title":"MVCC","text":"<ul> <li>MVCC-1 (Snapshot Isolation): Preserved</li> <li>MVCC-2 (CommitId Authority): Preserved</li> <li>MVCC-3 (Version Chain Integrity): Preserved</li> </ul>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#replication","title":"Replication","text":"<ul> <li>REP-1 (Single Writer): Preserved</li> <li>REP-2 (WAL Prefix Rule): Preserved</li> <li>REP-3 (Replica Observational Equivalence): Preserved</li> </ul>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#failure-recovery","title":"Failure &amp; Recovery","text":"<ul> <li>FR-1, FR-2, FR-3: Preserved</li> </ul>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#observability","title":"Observability","text":"<ul> <li>OBS-1, OBS-2: Preserved</li> </ul>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#disablement","title":"Disablement","text":"<ul> <li>DIS-1, DIS-2, DIS-3: Preserved</li> </ul>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#7-semantic-equivalence-argument","title":"7. Semantic Equivalence Argument","text":"<p>Replica Read Fast Path is semantically equivalent to baseline because:</p> <ul> <li>Reads are served only for snapshots already fully replicated</li> <li>No read observes data not present in replica WAL</li> <li>Version-chain traversal yields identical results</li> <li>Visibility rules are unchanged</li> <li>Primary and replica results match</li> </ul> <p>The optimization removes redundant checks, not safety checks.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#8-failure-matrix","title":"8. Failure Matrix","text":""},{"location":"PERF_REPLICA_READ_FAST_PATH/#81-replica-crash-during-read","title":"8.1 Replica Crash During Read","text":"<ul> <li>Baseline: read aborted</li> <li>Optimized: read aborted</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#82-replica-crash-after-safety-validation","title":"8.2 Replica Crash After Safety Validation","text":"<ul> <li>Validation state is in-memory</li> <li>State is lost on restart</li> </ul> <p>Recovery: - Safety is re-evaluated - Baseline behavior resumes</p> <p>Equivalent.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#83-wal-arrival-during-read","title":"8.3 WAL Arrival During Read","text":"<ul> <li>Baseline: WAL arrival handled normally</li> <li>Optimized: WAL arrival does not affect snapshot \u2264 R</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#84-replica-lag-increase","title":"8.4 Replica Lag Increase","text":"<ul> <li>Safety precondition fails</li> <li>Fast path is disabled</li> <li>Baseline read path used</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#9-recovery-proof","title":"9. Recovery Proof","text":"<ul> <li>Replica recovery logic is unchanged</li> <li>WAL replay is unchanged</li> <li>Snapshot selection is unchanged</li> <li>No optimization state is persisted</li> </ul> <p>Recovery behavior is identical.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#10-disablement-rollback","title":"10. Disablement &amp; Rollback","text":""},{"location":"PERF_REPLICA_READ_FAST_PATH/#101-disablement-mechanism","title":"10.1 Disablement Mechanism","text":"<p>Replica Read Fast Path MUST be disableable via:</p> <ul> <li>Compile-time flag or</li> <li>Startup configuration</li> </ul> <p>Disablement restores: - Baseline replica read behavior</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#102-compatibility-proof","title":"10.2 Compatibility Proof","text":"<ul> <li>WAL format unchanged</li> <li>Snapshot format unchanged</li> <li>Checkpoint format unchanged</li> </ul> <p>Replica data is always readable.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#103-no-ghost-state","title":"10.3 No Ghost State","text":"<ul> <li>No persistent replica-only metadata</li> <li>No WAL flags</li> <li>No snapshot annotations</li> </ul> <p>All fast-path state is in-memory and discardable.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#11-observability","title":"11. Observability","text":"<p>Permitted metrics (passive only):</p> <ul> <li>replica_read.fast_path_hits</li> <li>replica_read.fast_path_misses</li> <li>replica_read.safe_snapshot_commit_id</li> <li>replica_read.fallback_count</li> </ul> <p>Metrics MUST NOT: - Influence read selection - Influence safety decisions - Influence replication behavior</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#12-testing-requirements","title":"12. Testing Requirements","text":"<p>Replica Read Fast Path MUST introduce:</p> <ul> <li>Replica vs primary read equivalence tests</li> <li>Lag boundary tests</li> <li>Crash-during-read tests</li> <li>Disablement equivalence tests</li> <li>WAL gap tests</li> <li>Snapshot bootstrap interaction tests</li> </ul> <p>All existing tests MUST pass unmodified.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#13-explicit-non-goals","title":"13. Explicit Non-Goals","text":"<p>Replica Read Fast Path does NOT aim to:</p> <ul> <li>Make replicas eventually consistent</li> <li>Hide replication lag</li> <li>Provide weaker consistency reads</li> <li>Introduce read-your-own-writes on replicas</li> </ul> <p>Replica correctness is not negotiable.</p>"},{"location":"PERF_REPLICA_READ_FAST_PATH/#14-final-rule","title":"14. Final Rule","text":"<p>A replica may be faster than the primary, but it must never be less correct.</p> <p>Replica Read Fast Path is valid only if it is impossible to observe any divergence from baseline semantics.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/","title":"SEMANTIC EQUIVALENCE \u2014 PHASE 3","text":""},{"location":"PERF_SEMANTIC_EQUIVALENCE/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: Equivalence definition for all Phase 3 optimizations</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>PERFORMANCE_BASELINE.md</li> <li>CRITICAL_PATHS.md</li> </ul> <p>No optimization is valid unless it is proven semantically equivalent under the definitions in this document.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#1-purpose","title":"1. Purpose","text":"<p>Phase 3 permits performance changes only if behavior is unchanged.</p> <p>This document defines: - What \u201cbehavior\u201d means in AeroDB - What is observable vs non-observable - What must remain identical - What differences are permitted - How equivalence is evaluated under failures</p> <p>Equivalence is not similarity. Equivalence is indistinguishability to all permitted observers.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#2-definition-of-semantic-equivalence","title":"2. Definition of Semantic Equivalence","text":"<p>Two executions are semantically equivalent if and only if:</p> <p>For all permitted observers, under all allowed failure scenarios, the observable outcomes are identical.</p> <p>This must hold for: - Successful execution - Partial execution - Crash and recovery - Restart and replay - Replication consumption</p> <p>Performance differences are irrelevant.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#3-permitted-observers","title":"3. Permitted Observers","text":"<p>Semantic equivalence is evaluated relative to the following observers:</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#31-client-observer","title":"3.1 Client Observer","text":"<p>A client may observe: - Acknowledgment timing (relative to fsync only) - Success or failure - Returned query results - Error codes</p> <p>A client may NOT observe: - Internal scheduling - Intermediate states - Background activity</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#32-crash-recovery-observer","title":"3.2 Crash-Recovery Observer","text":"<p>The recovery process may observe: - WAL contents - Snapshot contents - Checkpoints - Checksums</p> <p>Recovery MUST produce identical state.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#33-replica-observer","title":"3.3 Replica Observer","text":"<p>A replica may observe: - WAL stream - Snapshot bootstrap data - Commit ordering - Visibility boundaries</p> <p>Replica-visible state MUST be derivable identically.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#34-diagnostic-observer","title":"3.4 Diagnostic Observer","text":"<p>Logs and metrics may observe: - Events - Counters - Timing</p> <p>Diagnostics MUST NOT influence semantics and are not authoritative for equivalence.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#4-observable-state-surface","title":"4. Observable State Surface","text":"<p>The following are observable and must be equivalent:</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#41-persistent-state","title":"4.1 Persistent State","text":"<ul> <li>WAL records (logical content and ordering)</li> <li>Snapshot files</li> <li>Snapshot manifests</li> <li>Checkpoint markers</li> </ul> <p>Binary equality is not required, but logical equivalence is mandatory.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#42-logical-database-state","title":"4.2 Logical Database State","text":"<ul> <li>Document contents</li> <li>MVCC version chains</li> <li>CommitId assignments</li> <li>Tombstones</li> <li>Index-visible state</li> </ul> <p>After recovery, state MUST be identical.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#43-visibility-semantics","title":"4.3 Visibility Semantics","text":"<ul> <li>Snapshot isolation behavior</li> <li>Version visibility</li> <li>Query results</li> </ul> <p>A read must return the same result set.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#44-failure-outcomes","title":"4.4 Failure Outcomes","text":"<ul> <li>Which operations succeed</li> <li>Which operations fail</li> <li>Which operations are retried</li> <li>Which operations are rolled back</li> </ul> <p>Failures MUST be detected at the same semantic boundaries.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#5-non-observable-differences-permitted","title":"5. Non-Observable Differences (Permitted)","text":"<p>The following differences are allowed only if they are not observable:</p> <ul> <li>Internal buffering</li> <li>Memory layout</li> <li>CPU instruction count</li> <li>Syscall batching</li> <li>Temporary allocations</li> <li>Lock granularity (if determinism preserved)</li> </ul> <p>If a difference becomes observable under any failure, it is forbidden.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#6-temporal-considerations","title":"6. Temporal Considerations","text":""},{"location":"PERF_SEMANTIC_EQUIVALENCE/#61-time-is-not-a-semantic-dimension","title":"6.1 Time Is Not a Semantic Dimension","text":"<p>Equivalence MUST NOT depend on: - Wall-clock time - CPU speed - I/O latency - Scheduling fairness</p> <p>An optimization that relies on \u201cfast enough\u201d behavior is invalid.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#62-ordering-is-semantic","title":"6.2 Ordering Is Semantic","text":"<p>Ordering of: - WAL records - CommitIds - Visibility transitions</p> <p>is semantically observable and MUST be preserved.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#7-write-path-equivalence","title":"7. Write Path Equivalence","text":"<p>Two executions are equivalent on the write path if:</p> <ul> <li>Acknowledgment occurs after equivalent durability</li> <li>CommitIds are assigned in the same order</li> <li>WAL records represent the same logical commits</li> <li>Partial writes fail identically</li> </ul> <p>Batching is allowed only if it produces the same logical sequence.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#8-read-path-equivalence","title":"8. Read Path Equivalence","text":"<p>Two executions are equivalent on the read path if:</p> <ul> <li>The same snapshot sees the same versions</li> <li>Version chain traversal yields the same result</li> <li>Queries return identical result sets</li> <li>Errors occur at the same semantic points</li> </ul> <p>Caching is allowed only if visibility rules are re-applied.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#9-mvcc-equivalence","title":"9. MVCC Equivalence","text":"<p>MVCC behavior is equivalent if:</p> <ul> <li>Snapshot isolation holds identically</li> <li>No snapshot observes new or missing versions</li> <li>CommitId visibility rules are unchanged</li> <li>Garbage collection effects are identical</li> </ul> <p>Optimizations MUST NOT: - Skip visibility checks - Pre-compute visibility without proof</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#10-replication-equivalence","title":"10. Replication Equivalence","text":"<p>Replication behavior is equivalent if:</p> <ul> <li>WAL stream is a strict prefix-equivalent sequence</li> <li>Snapshots represent the same MVCC cut</li> <li>Replicas reach the same logical state</li> <li>Replica restarts behave identically</li> </ul> <p>Any optimization affecting WAL emission MUST prove prefix preservation.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#11-failure-equivalence","title":"11. Failure Equivalence","text":"<p>For each failure point:</p> <ul> <li>Baseline outcome MUST be described</li> <li>Optimized outcome MUST match</li> <li>Recovery MUST converge to identical state</li> </ul> <p>Failure equivalence is evaluated at: - Before fsync - During WAL write - After fsync but before acknowledgment - During checkpoint - During snapshot - During replication transfer (if applicable)</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#12-equivalence-under-disablement","title":"12. Equivalence Under Disablement","text":"<p>An optimization is equivalent under disablement if:</p> <ul> <li>Data written with optimization enabled   can be read with it disabled</li> <li>WAL replay behavior is identical</li> <li>No migration or cleanup is required</li> </ul> <p>Disablement MUST NOT alter semantics.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#13-prohibited-equivalence-arguments","title":"13. Prohibited Equivalence Arguments","text":"<p>The following arguments are invalid:</p> <ul> <li>\u201cEquivalent in practice\u201d</li> <li>\u201cEquivalent under normal load\u201d</li> <li>\u201cEquivalent assuming no crash\u201d</li> <li>\u201cEquivalent because tests pass\u201d</li> <li>\u201cEquivalent because performance improved\u201d</li> </ul> <p>Equivalence is structural, not empirical.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#14-equivalence-proof-obligations","title":"14. Equivalence Proof Obligations","text":"<p>Every optimization MUST:</p> <ul> <li>Reference this document explicitly</li> <li>State which equivalence clauses apply</li> <li>Prove equivalence clause-by-clause</li> <li>Include failure equivalence</li> </ul> <p>Missing a clause is proof failure.</p>"},{"location":"PERF_SEMANTIC_EQUIVALENCE/#15-final-rule","title":"15. Final Rule","text":"<p>In AeroDB, two executions are equivalent if no observer can ever tell them apart.</p> <p>If an observer can distinguish them, the optimization is rejected.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_VISION/","title":"PHASE 3 \u2014 PERFORMANCE (CORRECTNESS-PRESERVING OPTIMIZATIONS)","text":""},{"location":"PERF_VISION/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>State: Design-first, proof-gated</li> <li>Prerequisites:</li> <li>Phase 1: Core Storage &amp; Correctness \u2014 Frozen</li> <li>Phase 2A: MVCC \u2014 Frozen</li> <li>Phase 2B: Replication Semantics \u2014 Frozen</li> </ul> <p>This document is authoritative for Phase 3 intent and scope.</p>"},{"location":"PERF_VISION/#1-purpose-of-phase-3","title":"1. Purpose of Phase 3","text":"<p>Phase 3 exists to improve performance without altering semantics.</p> <p>This phase introduces mechanical optimizations only, under strict rules: - No behavior changes - No semantic relaxation - No heuristic shortcuts - No timing assumptions</p> <p>Every optimization must be: 1. Explicitly specified 2. Correctness-proven 3. Opt-in (compile-time or config-gated) 4. Independently testable 5. Reversible without data impact</p> <p>If an optimization cannot be proven correct, it is forbidden.</p>"},{"location":"PERF_VISION/#2-definition-of-correctness-preserving-performance","title":"2. Definition of \u201cCorrectness-Preserving Performance\u201d","text":"<p>An optimization is correctness-preserving if and only if:</p> <ul> <li>All externally observable behavior is bit-for-bit equivalent</li> <li>All failure modes remain detectable and explicit</li> <li>All crash-recovery outcomes remain deterministic</li> <li>All MVCC visibility rules remain unchanged</li> <li>All replication invariants remain unchanged</li> <li>All acknowledged writes maintain identical durability guarantees</li> </ul> <p>Performance improvements must not introduce: - New states - New timing dependencies - New partial-commit behavior - New implicit ordering rules</p>"},{"location":"PERF_VISION/#3-absolute-non-goals","title":"3. Absolute Non-Goals","text":"<p>Phase 3 explicitly does NOT include:</p> <ul> <li>New features</li> <li>New APIs</li> <li>New consistency levels</li> <li>New isolation semantics</li> <li>New replication modes</li> <li>New storage formats</li> <li>New heuristics</li> <li>Adaptive or ML-based behavior</li> <li>Background threads that influence correctness</li> </ul> <p>If a change would be marketed as a \u201cfeature\u201d, it does not belong in Phase 3.</p>"},{"location":"PERF_VISION/#4-frozen-foundations-non-negotiable","title":"4. Frozen Foundations (Non-Negotiable)","text":"<p>Phase 3 MUST treat the following as immutable law:</p>"},{"location":"PERF_VISION/#41-phase-1-guarantees","title":"4.1 Phase 1 Guarantees","text":"<ul> <li>No acknowledged write is ever lost</li> <li>Corruption is detected, never repaired silently</li> <li>Recovery is deterministic</li> <li>Queries are bounded and deterministic</li> <li>Snapshots are read-only and manifest-driven</li> <li>Checkpoints bound WAL growth</li> <li>Observability never affects behavior</li> </ul>"},{"location":"PERF_VISION/#42-mvcc-guarantees","title":"4.2 MVCC Guarantees","text":"<ul> <li>CommitId authority is WAL-governed</li> <li>Snapshot isolation semantics are fixed</li> <li>Version chains are immutable</li> <li>Visibility rules are deterministic</li> <li>Garbage collection is WAL-governed</li> <li>Crash behavior is exhaustively defined</li> </ul>"},{"location":"PERF_VISION/#43-replication-guarantees","title":"4.3 Replication Guarantees","text":"<ul> <li>Single-writer invariant</li> <li>CommitId authority exists only on Primary</li> <li>WAL prefix rule is inviolable</li> <li>Replica state is always derivable</li> <li>No silent divergence</li> <li>Deterministic restart semantics</li> </ul> <p>No optimization may reinterpret, soften, or bypass these guarantees.</p>"},{"location":"PERF_VISION/#5-allowed-optimization-classes","title":"5. Allowed Optimization Classes","text":"<p>Only the following classes of optimizations are allowed in Phase 3:</p>"},{"location":"PERF_VISION/#51-mechanical-reordering-proven-equivalent","title":"5.1 Mechanical Reordering (Proven Equivalent)","text":"<p>Examples: - Grouping independent fsync calls - Combining buffer flushes</p> <p>Rules: - Logical order must remain identical - Failure boundaries must be preserved - Acknowledgment semantics must be unchanged</p>"},{"location":"PERF_VISION/#52-redundant-work-elimination","title":"5.2 Redundant Work Elimination","text":"<p>Examples: - Avoiding duplicate checksum computation - Memoizing schema validation results</p> <p>Rules: - Inputs must be provably identical - Cached results must be immutable - Cache invalidation must be explicit and total</p>"},{"location":"PERF_VISION/#53-read-only-fast-paths","title":"5.3 Read-Only Fast Paths","text":"<p>Examples: - Zero-copy reads - Snapshot-local caching</p> <p>Rules: - No writes - No visibility shortcuts - MVCC rules must be explicitly enforced</p>"},{"location":"PERF_VISION/#54-deterministic-batching","title":"5.4 Deterministic Batching","text":"<p>Examples: - WAL record batching - Commit group formation</p> <p>Rules: - No reordering across CommitId boundaries - No partial acknowledgment - Crash behavior must match unbatched execution</p>"},{"location":"PERF_VISION/#55-memory-layout-optimization","title":"5.5 Memory Layout Optimization","text":"<p>Examples: - Cache-line alignment - Structure packing</p> <p>Rules: - No semantic coupling to layout - No reliance on undefined behavior - No platform-specific correctness assumptions</p>"},{"location":"PERF_VISION/#6-forbidden-optimization-patterns","title":"6. Forbidden Optimization Patterns","text":"<p>The following are explicitly forbidden:</p> <ul> <li>Lazy durability</li> <li>Async acknowledgment</li> <li>Background retries</li> <li>Time-based flushing</li> <li>Adaptive thresholds</li> <li>Best-effort behavior</li> <li>Silent fallback paths</li> <li>\u201cUsually safe\u201d logic</li> <li>Hardware-specific correctness dependencies</li> </ul> <p>If an optimization requires a disclaimer, it is not allowed.</p>"},{"location":"PERF_VISION/#7-proof-requirements","title":"7. Proof Requirements","text":"<p>Every Phase 3 optimization document MUST include:</p> <ol> <li>Baseline Semantics Section</li> <li>What the system does today</li> <li> <p>Why it is correct</p> </li> <li> <p>Optimization Description</p> </li> <li>Exact mechanical change</li> <li> <p>No implementation shortcuts</p> </li> <li> <p>Invariant Preservation Proof</p> </li> <li>Durability</li> <li>Determinism</li> <li>MVCC visibility</li> <li> <p>Replication safety</p> </li> <li> <p>Failure Matrix</p> </li> <li>Power loss</li> <li>Process crash</li> <li>Partial I/O</li> <li>Disk error</li> <li> <p>Replica disconnect (if applicable)</p> </li> <li> <p>Equivalence Argument</p> </li> <li> <p>Why optimized execution is observationally identical</p> </li> <li> <p>Rollback Plan</p> </li> <li>How optimization can be disabled</li> <li>Proof that disabling does not affect stored data</li> </ol> <p>No code may be written without an accepted proof.</p>"},{"location":"PERF_VISION/#8-observability-rules-in-phase-3","title":"8. Observability Rules in Phase 3","text":"<p>Performance instrumentation: - May measure - May record - May expose metrics</p> <p>It may never: - Influence control flow - Influence scheduling - Influence batching decisions - Influence retry behavior</p> <p>Observability remains strictly passive.</p>"},{"location":"PERF_VISION/#9-testing-requirements","title":"9. Testing Requirements","text":"<p>Each optimization must introduce:</p> <ul> <li>Deterministic unit tests</li> <li>Crash-recovery equivalence tests</li> <li>Phase 1 regression tests</li> <li>MVCC regression tests</li> <li>Replication regression tests (if applicable)</li> </ul> <p>All existing tests MUST pass unmodified.</p> <p>If a test must change, the optimization is invalid.</p>"},{"location":"PERF_VISION/#10-phase-3-exit-criteria","title":"10. Phase 3 Exit Criteria","text":"<p>Phase 3 is complete when:</p> <ul> <li>All selected optimizations are proven and implemented</li> <li>No correctness regressions exist</li> <li>No semantics are altered</li> <li>All optimizations are optional</li> <li>Documentation is complete and authoritative</li> </ul> <p>Performance gains are secondary to proof quality.</p>"},{"location":"PERF_VISION/#11-guiding-principle","title":"11. Guiding Principle","text":"<p>AeroDB would rather be slow and correct than fast and ambiguous.</p> <p>Phase 3 exists to make AeroDB faster only where correctness is untouched.</p> <p>If there is doubt, we do not optimize.</p> <p>END OF DOCUMENT</p>"},{"location":"PERF_WAL_BATCHING/","title":"WAL BATCHING \u2014 PHASE 3","text":""},{"location":"PERF_WAL_BATCHING/#status","title":"Status","text":"<ul> <li>Phase: 3</li> <li>Authority: Normative</li> <li>Scope: Write-ahead log emission optimization</li> <li>Dependencies:</li> <li>PERF_VISION.md</li> <li>PERF_INVARIANTS.md</li> <li>PERF_PROOF_RULES.md</li> <li>PERFORMANCE_BASELINE.md</li> <li>CRITICAL_PATHS.md</li> <li>SEMANTIC_EQUIVALENCE.md</li> <li>FAILURE_MODEL_PHASE3.md</li> <li>ROLLBACK_AND_DISABLEMENT.md</li> <li>PERFORMANCE_OBSERVABILITY.md</li> </ul> <p>This document specifies WAL Batching as a correctness-preserving optimization. If any requirement in this document cannot be proven, WAL Batching MUST NOT be implemented.</p>"},{"location":"PERF_WAL_BATCHING/#1-purpose","title":"1. Purpose","text":"<p>Baseline AeroDB performs:</p> <ul> <li>One logical WAL record write per commit</li> <li>One physical write per record (even if contiguous)</li> </ul> <p>This results in: - Excessive syscall overhead - Redundant write amplification</p> <p>WAL Batching reduces overhead by: - Writing multiple WAL records in a single physical write - Without changing WAL semantics, ordering, or durability</p> <p>WAL Batching affects how WAL is written, not what WAL means.</p>"},{"location":"PERF_WAL_BATCHING/#2-baseline-reference-normative","title":"2. Baseline Reference (Normative)","text":"<p>Baseline WAL behavior is defined in:</p> <ul> <li><code>PERFORMANCE_BASELINE.md</code> \u00a73.2</li> <li><code>CRITICAL_PATHS.md</code> \u00a72.2</li> </ul> <p>Baseline invariants:</p> <ul> <li>WAL is append-only</li> <li>Logical record boundaries are explicit</li> <li>Each record is checksummed</li> <li>Ordering is strict</li> <li>fsync defines durability</li> </ul> <p>These invariants MUST remain true.</p>"},{"location":"PERF_WAL_BATCHING/#3-definition-of-wal-batching","title":"3. Definition of WAL Batching","text":""},{"location":"PERF_WAL_BATCHING/#31-conceptual-definition","title":"3.1 Conceptual Definition","text":"<p>WAL Batching allows:</p> <p>Multiple logically independent WAL records to be written to disk using a single physical write operation, while preserving logical record boundaries and ordering.</p> <p>Each WAL record remains: - Individually checksummed - Individually parseable - Individually replayable</p> <p>Only the physical I/O shape changes.</p>"},{"location":"PERF_WAL_BATCHING/#32-non-definition-what-wal-batching-is-not","title":"3.2 Non-Definition (What WAL Batching Is NOT)","text":"<p>WAL Batching does NOT mean:</p> <ul> <li>Combining records into a new logical format</li> <li>Removing per-record checksums</li> <li>Changing replay semantics</li> <li>Reordering records</li> <li>Delaying fsync</li> <li>Time-based buffering</li> <li>Adaptive buffering based on load</li> </ul> <p>If batching changes record semantics, it is invalid.</p>"},{"location":"PERF_WAL_BATCHING/#4-mechanical-description","title":"4. Mechanical Description","text":""},{"location":"PERF_WAL_BATCHING/#41-baseline-wal-write-path","title":"4.1 Baseline WAL Write Path","text":"<p>For each commit:</p> <ol> <li>Serialize WAL record</li> <li>Compute checksum</li> <li>Write record to WAL file</li> <li>(Later) fsync WAL</li> </ol> <p>Each record write is independent.</p>"},{"location":"PERF_WAL_BATCHING/#42-wal-batching-write-path","title":"4.2 WAL Batching Write Path","text":"<p>Under WAL Batching, the following mechanical change is permitted:</p> <ol> <li>Serialize WAL record A</li> <li>Serialize WAL record B</li> <li>Serialize WAL record C</li> <li>Concatenate serialized records into a contiguous buffer</li> <li>Perform one write() for the buffer</li> <li>(Later) fsync WAL</li> </ol> <p>Rules: - Serialization order MUST match commit order - No record may be split across buffers - Record boundaries MUST be preserved in the byte stream</p>"},{"location":"PERF_WAL_BATCHING/#43-batch-formation-rules","title":"4.3 Batch Formation Rules","text":"<p>Batches MAY be formed only by:</p> <ul> <li>Sequential availability of serialized records</li> <li>Explicit bounded buffering</li> </ul> <p>Batches MUST NOT be formed by: - Timers - Load heuristics - Background aggregation - Dynamic resizing based on latency</p> <p>Batch size MUST be: - Explicitly bounded - Deterministic - Configuration-defined or compile-time defined</p>"},{"location":"PERF_WAL_BATCHING/#5-invariant-preservation-matrix","title":"5. Invariant Preservation Matrix","text":"<p>(Referenced from <code>PERF_INVARIANTS.md</code>)</p>"},{"location":"PERF_WAL_BATCHING/#durability","title":"Durability","text":"<ul> <li>D-1 (Acknowledged Write Durability): Preserved</li> <li>D-2 (Atomic Commit Boundary): Preserved</li> <li>D-3 (No Silent Downgrade): Preserved</li> </ul>"},{"location":"PERF_WAL_BATCHING/#determinism","title":"Determinism","text":"<ul> <li>DET-1 (Crash Determinism): Preserved</li> <li>DET-2 (Replay Equivalence): Preserved</li> <li>DET-3 (Bounded Execution): Preserved</li> </ul>"},{"location":"PERF_WAL_BATCHING/#mvcc","title":"MVCC","text":"<ul> <li>MVCC-1, MVCC-2, MVCC-3: Preserved</li> </ul>"},{"location":"PERF_WAL_BATCHING/#replication","title":"Replication","text":"<ul> <li>REP-1, REP-2, REP-3: Preserved</li> </ul>"},{"location":"PERF_WAL_BATCHING/#failure-recovery","title":"Failure &amp; Recovery","text":"<ul> <li>FR-1, FR-2, FR-3: Preserved</li> </ul>"},{"location":"PERF_WAL_BATCHING/#observability","title":"Observability","text":"<ul> <li>OBS-1, OBS-2: Preserved</li> </ul>"},{"location":"PERF_WAL_BATCHING/#disablement","title":"Disablement","text":"<ul> <li>DIS-1, DIS-2, DIS-3: Preserved</li> </ul> <p>No invariant is weakened.</p>"},{"location":"PERF_WAL_BATCHING/#6-semantic-equivalence-argument","title":"6. Semantic Equivalence Argument","text":"<p>WAL Batching is semantically equivalent to baseline because:</p> <ul> <li>The WAL byte stream is a strict concatenation of baseline records</li> <li>Record boundaries are unchanged</li> <li>Record ordering is unchanged</li> <li>Checksums validate each record independently</li> <li>fsync semantics are unchanged</li> <li>Replay reads records identically</li> </ul> <p>From the perspective of: - Clients - Recovery - Replicas</p> <p>The WAL is indistinguishable from baseline emission.</p>"},{"location":"PERF_WAL_BATCHING/#7-failure-matrix","title":"7. Failure Matrix","text":""},{"location":"PERF_WAL_BATCHING/#71-crash-before-write","title":"7.1 Crash Before Write","text":"<ul> <li>Baseline: no WAL data written</li> <li>Batched: no WAL data written</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_WAL_BATCHING/#72-crash-during-batched-write","title":"7.2 Crash During Batched Write","text":"<p>Possible outcomes: - No bytes written - Partial buffer written</p> <p>In all cases: - Partial records are detected by checksum - Replay behavior matches baseline partial-write behavior</p> <p>Equivalent.</p>"},{"location":"PERF_WAL_BATCHING/#73-crash-after-batched-write-before-fsync","title":"7.3 Crash After Batched Write, Before fsync","text":"<ul> <li>Baseline: data may be lost</li> <li>Batched: data may be lost</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_WAL_BATCHING/#74-crash-after-fsync","title":"7.4 Crash After fsync","text":"<ul> <li>Baseline: records durable</li> <li>Batched: records durable</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_WAL_BATCHING/#75-disk-error-during-write","title":"7.5 Disk Error During Write","text":"<ul> <li>Error surfaced immediately</li> <li>Commit fails</li> <li>No acknowledgment</li> </ul> <p>Equivalent.</p>"},{"location":"PERF_WAL_BATCHING/#8-recovery-proof","title":"8. Recovery Proof","text":"<ul> <li>WAL replay logic is unchanged</li> <li>Replay reads sequential records</li> <li>Checksum validation is per-record</li> <li>No batching metadata exists</li> </ul> <p>Replay determinism is preserved.</p>"},{"location":"PERF_WAL_BATCHING/#9-disablement-rollback","title":"9. Disablement &amp; Rollback","text":""},{"location":"PERF_WAL_BATCHING/#91-disablement-mechanism","title":"9.1 Disablement Mechanism","text":"<p>WAL Batching MUST be disableable via:</p> <ul> <li>Compile-time flag or</li> <li>Startup configuration</li> </ul> <p>Disablement restores: - One write per WAL record</p>"},{"location":"PERF_WAL_BATCHING/#92-compatibility-proof","title":"9.2 Compatibility Proof","text":"<ul> <li>WAL format unchanged</li> <li>Snapshot format unchanged</li> <li>Checkpoint format unchanged</li> </ul> <p>Batched WAL is readable without batching enabled.</p>"},{"location":"PERF_WAL_BATCHING/#93-no-ghost-state","title":"9.3 No Ghost State","text":"<ul> <li>No persistent batching metadata</li> <li>No WAL flags</li> <li>No snapshot annotations</li> </ul> <p>All batching state is in-memory and discardable.</p>"},{"location":"PERF_WAL_BATCHING/#10-observability","title":"10. Observability","text":"<p>Permitted metrics (passive only):</p> <ul> <li>wal_batch.records_per_write</li> <li>wal_batch.bytes_per_write</li> <li>wal_batch.write_syscalls</li> </ul> <p>Metrics MUST NOT: - Influence batch size - Influence flushing - Influence grouping</p>"},{"location":"PERF_WAL_BATCHING/#11-testing-requirements","title":"11. Testing Requirements","text":"<p>WAL Batching MUST introduce:</p> <ul> <li>WAL equivalence tests</li> <li>Partial-write fault injection tests</li> <li>Crash-recovery tests</li> <li>Enable \u2192 write \u2192 crash \u2192 disable \u2192 recover tests</li> <li>Replication prefix validation tests</li> </ul> <p>All existing tests MUST pass unmodified.</p>"},{"location":"PERF_WAL_BATCHING/#12-explicit-non-goals","title":"12. Explicit Non-Goals","text":"<p>WAL Batching does NOT aim to:</p> <ul> <li>Change fsync frequency (see Group Commit)</li> <li>Reduce durability guarantees</li> <li>Introduce adaptive buffering</li> <li>Change WAL semantics</li> </ul> <p>It optimizes syscall efficiency only.</p>"},{"location":"PERF_WAL_BATCHING/#13-final-rule","title":"13. Final Rule","text":"<p>WAL Batching is valid only if the WAL could have been written record-by-record and no observer could ever tell.</p> <p>If replay, replication, or recovery can distinguish it, WAL Batching is invalid.</p> <p>END OF DOCUMENT</p>"},{"location":"PROJECT_PLAN/","title":"AeroDB High-Level Architecture Design","text":"<p>Design document for Phase 0 \u2014 Minimum Viable Infrastructure</p> <p>Single-node, schema-mandatory, WAL-backed, deterministic database engine.</p>"},{"location":"PROJECT_PLAN/#1-system-overview","title":"1. System Overview","text":"<p>aerodb is a single-node document database engine with mandatory schemas, deterministic behavior, and WAL-backed durability. It prioritizes correctness, predictability, and operational clarity over performance, flexibility, or feature breadth.</p> <pre><code>graph TB\n    subgraph \"Client Interface\"\n        API[API Layer]\n    end\n\n    subgraph \"Query Processing\"\n        Parser[Query Parser]\n        Validator[Schema Validator]\n        Planner[Deterministic Query Planner]\n        Executor[Query Executor]\n    end\n\n    subgraph \"Storage Engine\"\n        WAL[Write-Ahead Log]\n        Index[B-Tree Index Manager]\n        Storage[Document Storage]\n        Checksum[Checksum Validator]\n    end\n\n    subgraph \"Recovery\"\n        Recovery[Recovery Manager]\n    end\n\n    API --&gt; Parser\n    Parser --&gt; Validator\n    Validator --&gt; Planner\n    Planner --&gt; Executor\n    Executor --&gt; WAL\n    Executor --&gt; Index\n    WAL --&gt; Storage\n    Index --&gt; Storage\n    Storage --&gt; Checksum\n    Recovery --&gt; WAL\n    Recovery --&gt; Storage</code></pre>"},{"location":"PROJECT_PLAN/#2-major-components-and-responsibilities","title":"2. Major Components and Responsibilities","text":""},{"location":"PROJECT_PLAN/#21-api-layer","title":"2.1 API Layer","text":"<p>Responsibility: Accept client requests, route to query processing, return results or explicit errors.</p> Function Behavior Accept requests Parse wire protocol, extract operation Return results Success with data, or explicit error code Reject malformed requests Fail loudly with structured error Serialize execution Enforce single-threaded execution (see \u00a72.11) <p>Invariants Upheld: - F1 (Fail Loudly): All errors are explicit and returned to client - F2 (No Partial Success): Request either fully succeeds or fully fails - O3 (Observable System State): All operations are logged</p>"},{"location":"PROJECT_PLAN/#22-query-parser","title":"2.2 Query Parser","text":"<p>Responsibility: Parse query syntax into an internal representation. No interpretation, no guessing.</p> Function Behavior Parse query Convert wire format to AST Reject malformed queries Explicit syntax error with location No implicit defaults Missing fields cause rejection, not default values <p>Invariants Upheld: - Q3 (Execution Never Guesses): Ambiguous queries are rejected - F3 (Errors Are Deterministic): Same malformed query \u2192 same error</p>"},{"location":"PROJECT_PLAN/#23-schema-validator","title":"2.3 Schema Validator","text":"<p>Responsibility: Enforce that all documents conform to their declared schema before any write.</p> Function Behavior Validate documents Check all fields against schema definition Reject invalid documents Fail write, no partial persistence Validate schema references Ensure document references valid schema version <p>Invariants Upheld: - S1 (Schema Presence Is Mandatory): No schemaless writes - S2 (Schema Validity Is Enforced on Write): Invalid data never enters storage - S3 (Schema Versions Are Explicit): Documents reference explicit schema version - S4 (Schema Violations Are Fatal): Validation failure = write rejection</p>"},{"location":"PROJECT_PLAN/#24-deterministic-query-planner","title":"2.4 Deterministic Query Planner","text":"<p>Responsibility: Generate a query execution plan that is deterministic, bounded, and explainable.</p> Function Behavior Select index Choose based on query predicates and available indexes (deterministic rules, no heuristics) Estimate cost Compute upper bound on data scanned, time, memory Reject unbounded queries Queries without provable bounds are rejected before execution Produce explain plan Human-readable plan for any query <p>Determinism Mechanism: 1. Index selection is rule-based (not statistics-driven heuristics) 2. Rules are versioned and explicit 3. Same (query, schema, indexes) \u2192 same plan</p> <p>Invariants Upheld: - T1 (Deterministic Planning): Same inputs \u2192 same plan - T3 (Planner Changes Are Explicit): Any rule change is versioned/opt-in - Q1 (Queries Must Be Bounded): Unbounded queries rejected - Q2 (No Implicit Full Scans): Scans require explicit declaration</p>"},{"location":"PROJECT_PLAN/#25-query-executor","title":"2.5 Query Executor","text":"<p>Responsibility: Execute the plan produced by the planner. No rewriting, no optimization.</p> Function Behavior Execute plan steps Follow plan exactly as specified Enforce limits Stop at declared limits (time, rows, memory) Return deterministic results Stable ordering via indexed fields or primary key <p>Invariants Upheld: - T2 (Deterministic Execution): No timing/thread-dependent behavior - Q3 (Execution Never Guesses): Execute plan as specified</p>"},{"location":"PROJECT_PLAN/#26-write-ahead-log-wal","title":"2.6 Write-Ahead Log (WAL)","text":"<p>Responsibility: Ensure all acknowledged writes are durable before acknowledgment.</p> Function Behavior Append log entry Write operation to WAL with checksum Sync to disk Explicit <code>fsync</code> before acknowledgment Provide recovery source WAL is the source of truth for crash recovery <p>Invariants Upheld: - D1 (No Acknowledged Write Is Ever Lost): WAL sync before ack - R1 (WAL Precedes Acknowledgement): Mandatory - R2 (Recovery Is Deterministic): WAL enables deterministic replay</p>"},{"location":"PROJECT_PLAN/#27-document-storage","title":"2.7 Document Storage","text":"<p>Responsibility: Store documents on disk in a structured format with integrity validation.</p> Function Behavior Persist documents Write to disk with schema version reference Include checksums Every record has integrity checksum Support reads Retrieve documents by primary key or index lookup <p>Invariants Upheld: - D2 (Data Corruption Is Never Ignored): Checksums enable detection - D3 (Reads Never Observe Invalid State): Only schema-valid data stored</p>"},{"location":"PROJECT_PLAN/#28-b-tree-index-manager","title":"2.8 B-Tree Index Manager","text":"<p>Responsibility: Maintain B-tree indexes for efficient, bounded lookups.</p> Function Behavior Create/drop indexes Explicit index management only Update indexes Indexes updated as part of write operation (see \u00a73.1) Support lookups Equality and bounded range queries <p>Invariants Upheld: - Q1 (Queries Must Be Bounded): Indexes enable bounded execution - T1 (Deterministic Planning): Index availability is explicit</p>"},{"location":"PROJECT_PLAN/#29-checksum-validator","title":"2.9 Checksum Validator","text":"<p>Responsibility: Validate integrity of all data read from storage.</p> Function Behavior Compute checksums on write Attach checksum to each record Validate checksums on read Reject corrupted data Halt on corruption Fail operation, log explicitly <p>Invariants Upheld: - D2 (Data Corruption Is Never Ignored): Detection is mandatory - K1 (Corruption Detection Is Mandatory): Checksums on all records - K2 (Corruption Is Never Silently Repaired): Halt, don't repair</p>"},{"location":"PROJECT_PLAN/#210-recovery-manager","title":"2.10 Recovery Manager","text":"<p>Responsibility: Restore database to consistent state after crash.</p> Function Behavior Replay WAL Apply all committed entries from WAL to storage Verify consistency Confirm all checksums, schema validity Report recovery status Explicit success/failure with details <p>Invariants Upheld: - R2 (Recovery Is Deterministic): Same WAL \u2192 same state - R3 (Recovery Completeness Is Verifiable): Explicit status report</p>"},{"location":"PROJECT_PLAN/#211-execution-concurrency-model","title":"2.11 Execution Concurrency Model","text":"<p>Responsibility: Enforce deterministic, single-threaded execution.</p> <p>Phase 0 Model: Single global execution lock.</p> Aspect Rule Request serialization All client requests acquire a global execution lock before processing Lock scope Lock held from request start through acknowledgment No parallel execution Only one operation (read or write) executes at any time No async execution All operations are synchronous end-to-end <p>Enforcement: - API Layer acquires global lock on request entry - Lock released only after:   - Write: WAL fsync and acknowledgment   - Read: Result returned to client - If lock is held, subsequent requests block</p> <p>Invariants Upheld: - T2 (Deterministic Execution): No concurrent execution eliminates timing dependencies</p>"},{"location":"PROJECT_PLAN/#212-configuration-manager","title":"2.12 Configuration Manager","text":"<p>Responsibility: Validate and enforce configuration constraints.</p> <p>Phase 0 Configuration Surface:</p> Parameter Type Constraint <code>data_dir</code> Path Immutable after first start; must be writable <code>wal_sync_mode</code> Enum Must be <code>fsync</code> (other modes rejected) <code>max_wal_size_bytes</code> Integer Immutable; must be &gt; 0 <code>max_memory_bytes</code> Integer Immutable; must be &gt; 0 <p>Forbidden Configurations: - Any mode that disables WAL fsync - Any mode that weakens schema validation - Any mode that bypasses checksums - Any mode that allows partial success</p> <p>Invariants Upheld: - O2 (Config Cannot Violate Safety): Unsafe configurations rejected at startup</p>"},{"location":"PROJECT_PLAN/#3-write-atomicity-model","title":"3. Write Atomicity Model","text":""},{"location":"PROJECT_PLAN/#31-atomicity-boundary","title":"3.1 Atomicity Boundary","text":"<p>Single-Document Atomicity: Each write operation (insert, update, delete) modifies exactly one document atomically.</p> <p>Atomicity Guarantee: - A write operation is atomic at the document level - Partial document updates are never observable - All secondary state (indexes) is updated as part of the same atomic operation</p> <p>Index State Model: Indexes are derived, rebuildable state.</p> Property Rule Index durability Index updates are NOT separately logged in WAL WAL contents WAL contains only document operations (insert/update/delete) Recovery behavior Indexes are rebuilt from document storage during recovery Consistency Index state always matches document storage after recovery completes <p>Write Operation Atomicity Stages:</p> <ol> <li>Append to WAL (with checksum)</li> <li>Fsync WAL to disk</li> <li>Apply to Document Storage (with checksum)</li> <li>Update B-Tree Indexes (in-memory, derived from storage)</li> <li>Acknowledgment to client</li> </ol> <p>Critical Rule: Steps 1-3 are the durability boundary. Index updates (step 4) occur after durability is guaranteed but before acknowledgment. If a crash occurs after step 3 but before step 4, recovery rebuilds indexes from storage.</p> <p>Invariants Upheld: - D1 (No Acknowledged Write Lost): WAL fsync guarantees durability - F2 (No Partial Success): Document + index update completes or entire operation fails - C1 (Single-Document Atomicity): Only one document modified per operation</p>"},{"location":"PROJECT_PLAN/#4-write-path","title":"4. Write Path","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant API\n    participant Parser\n    participant SchemaValidator\n    participant Planner\n    participant WAL\n    participant Storage\n    participant Index\n\n    Client-&gt;&gt;API: Write Request (insert/update/delete)\n    API-&gt;&gt;API: Acquire global execution lock\n    API-&gt;&gt;Parser: Parse Operation\n    Parser-&gt;&gt;SchemaValidator: Validate Document Against Schema\n\n    alt Schema Invalid\n        SchemaValidator--&gt;&gt;API: Reject (Schema Violation Error)\n        API-&gt;&gt;API: Release lock\n        API--&gt;&gt;Client: Error Response\n    end\n\n    SchemaValidator-&gt;&gt;Planner: Plan Write Operation\n    Planner-&gt;&gt;Planner: Verify write is bounded (update/delete)\n\n    alt Unbounded Write\n        Planner--&gt;&gt;API: Reject (Unbounded Operation Error)\n        API-&gt;&gt;API: Release lock\n        API--&gt;&gt;Client: Error Response\n    end\n\n    Planner-&gt;&gt;WAL: Append Log Entry (with checksum)\n    WAL-&gt;&gt;WAL: fsync to disk\n    WAL-&gt;&gt;Storage: Apply to document storage\n    Storage-&gt;&gt;Index: Update B-tree index (derived state)\n    Storage--&gt;&gt;API: Acknowledgment\n    API-&gt;&gt;API: Release lock\n    API--&gt;&gt;Client: Success Response</code></pre>"},{"location":"PROJECT_PLAN/#write-path-steps","title":"Write Path Steps","text":"<ol> <li>Client Request: Client sends write operation (insert, update, delete)</li> <li>Acquire Lock: API layer acquires global execution lock (\u00a72.11)</li> <li>Parse: API layer parses request into internal representation</li> <li>Schema Validation: </li> <li>Document validated against declared schema version</li> <li>Invalid documents rejected immediately (S2, S4)</li> <li>Plan Bounded Check: </li> <li>For updates/deletes: verify operation targets bounded set (\u00a74.1)</li> <li>Unbounded updates/deletes rejected</li> <li>WAL Append: </li> <li>Document operation written to WAL with checksum</li> <li>This step must complete before acknowledgment (R1)</li> <li>WAL Sync: </li> <li>Explicit <code>fsync</code> to guarantee durability (D1)</li> <li>Durability boundary: write is now recoverable</li> <li>Apply to Storage: </li> <li>Document persisted to storage with checksum</li> <li>Update Index: </li> <li>B-tree indexes updated (derived state, rebuildable from storage)</li> <li>Acknowledgment: <ul> <li>Success returned to client only after all steps complete</li> </ul> </li> <li>Release Lock: Global execution lock released</li> </ol> <p>Critical Guarantee: No write is acknowledged until WAL is synced to disk. This ensures D1 (No Acknowledged Write Is Ever Lost).</p>"},{"location":"PROJECT_PLAN/#41-bounded-updatedelete-rules","title":"4.1 Bounded Update/Delete Rules","text":"<p>Definition: A write operation is bounded if the set of affected documents can be determined with a provable upper bound before execution.</p> <p>Allowed Predicates for Updates and Deletes:</p> Predicate Type Example Bounded? Reason Primary key equality <code>{_id: \"abc123\"}</code> \u2713 Yes Targets exactly one document Indexed field equality <code>{email: \"user@example.com\"}</code> \u2713 Yes Index lookup provides bounded set Indexed field range with explicit limit <code>{age: {$gte: 25, $lte: 30}, $limit: 100}</code> \u2713 Yes Index range + limit = bounded Non-indexed field <code>{favoriteColor: \"blue\"}</code> \u2717 No Requires full scan (unbounded) Range without limit <code>{age: {$gte: 25}}</code> \u2717 No Unbounded upper range Empty predicate <code>{}</code> \u2717 No Targets entire collection (unbounded) <p>Enforcement Rules:</p> <ol> <li>Primary Key Operations: Always bounded (exactly one document)</li> <li>Indexed Equality: Bounded by index lookup</li> <li>Indexed Range: Bounded only if explicit <code>$limit</code> is provided</li> <li>Non-Indexed Fields: Always rejected (unbounded)</li> <li>Bulk Operations: Allowed only if predicate is bounded and limit is explicit</li> </ol> <p>Rejection Behavior: - Unbounded updates/deletes are rejected at planning stage - Error code: <code>UNBOUNDED_OPERATION</code> - Error message includes specific reason (e.g., \"non-indexed field\", \"missing limit\")</p> <p>Invariants Upheld: - Q1 (Queries Must Be Bounded): All operations have provable bounds - Q3 (Execution Never Guesses): System does not guess how many documents will be affected</p>"},{"location":"PROJECT_PLAN/#5-read-path","title":"5. Read Path","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant API\n    participant Parser\n    participant Planner\n    participant Executor\n    participant Index\n    participant Storage\n    participant Checksum\n\n    Client-&gt;&gt;API: Query Request\n    API-&gt;&gt;API: Acquire global execution lock\n    API-&gt;&gt;Parser: Parse Query\n    Parser-&gt;&gt;Planner: Request Execution Plan\n\n    Planner-&gt;&gt;Planner: Determine index to use\n    Planner-&gt;&gt;Planner: Estimate cost (scan, time, memory)\n\n    alt Unbounded Cost\n        Planner--&gt;&gt;API: Reject (Unbounded Query Error)\n        API-&gt;&gt;API: Release lock\n        API--&gt;&gt;Client: Error Response\n    end\n\n    Planner--&gt;&gt;Executor: Execution Plan\n    Executor-&gt;&gt;Index: B-tree lookup (if indexed)\n    Index-&gt;&gt;Storage: Retrieve documents\n    Storage-&gt;&gt;Checksum: Validate checksums\n\n    alt Checksum Invalid\n        Checksum--&gt;&gt;API: Reject (Corruption Detected)\n        API-&gt;&gt;API: Release lock\n        API--&gt;&gt;Client: Error Response\n    end\n\n    Checksum--&gt;&gt;Executor: Valid documents\n    Executor-&gt;&gt;Executor: Apply filter, sort, limit\n    Executor--&gt;&gt;API: Result set\n    API-&gt;&gt;API: Release lock\n    API--&gt;&gt;Client: Success Response with data</code></pre>"},{"location":"PROJECT_PLAN/#read-path-steps","title":"Read Path Steps","text":"<ol> <li>Client Request: Client sends query (find, filter, sort, limit)</li> <li>Acquire Lock: API layer acquires global execution lock (\u00a72.11)</li> <li>Parse: API layer parses query into AST</li> <li>Plan Generation:</li> <li>Planner selects index based on deterministic rules (T1)</li> <li>Planner estimates cost upper bound</li> <li>Unbounded queries rejected (Q1, Q2)</li> <li>Plan Returned: Human-readable plan available for explain</li> <li>Execution:</li> <li>Executor follows plan exactly (T2)</li> <li>Index lookup for bounded data access</li> <li>Documents retrieved from storage</li> <li>Schema Version Filtering: Documents filtered by schema version (\u00a75.1)</li> <li>Checksum Validation:</li> <li>Every document checksummed on read</li> <li>Corrupted documents cause operation failure (D2, K2)</li> <li>Filter/Sort/Limit:</li> <li>Applied in deterministic order</li> <li>Sort only on indexed fields (as per SCOPE.md)</li> <li>Result Return:<ul> <li>Ordered, deterministic result set returned</li> <li>Ordering guaranteed by index or primary key (T2)</li> </ul> </li> <li>Release Lock: Global execution lock released</li> </ol> <p>Critical Guarantee: Execution is deterministic\u2014same query on same data always produces same results in same order.</p>"},{"location":"PROJECT_PLAN/#51-schema-version-semantics-for-reads","title":"5.1 Schema Version Semantics for Reads","text":"<p>Phase 0 Rule: Queries operate on documents of a single, explicitly specified schema version.</p> Aspect Behavior Query schema version Must be explicitly specified in query Multi-version reads Not supported in Phase 0 Version mismatch Documents with different schema versions are excluded from results Default version Forbidden; version must be explicit <p>Query Syntax Requirement: <pre><code>find({...predicates...}, {schema_version: \"v1\"})\n</code></pre></p> <p>Read Semantics:</p> <ol> <li>Explicit Version Match: Only documents with <code>schema_version == \"v1\"</code> are read</li> <li>Incompatible Versions: Documents with other schema versions are transparently skipped</li> <li>No Cross-Version Operations: Cannot query across multiple schema versions in Phase 0</li> </ol> <p>Example:</p> Document ID Schema Version Query: <code>schema_version: \"v2\"</code> Result doc1 v1 Excluded Not returned doc2 v2 Matched Returned doc3 v2 Matched Returned <p>Error Cases:</p> Scenario Behavior Query without schema version Rejected with <code>SCHEMA_VERSION_REQUIRED</code> error Schema version does not exist Rejected with <code>UNKNOWN_SCHEMA_VERSION</code> error No documents match version Return empty result set (not an error) <p>Invariants Upheld: - S3 (Schema Versions Are Explicit): Queries must specify version - D3 (Reads Never Observe Invalid State): Only schema-valid data for specified version</p>"},{"location":"PROJECT_PLAN/#6-determinism-enforcement","title":"6. Determinism Enforcement","text":""},{"location":"PROJECT_PLAN/#61-query-planning-determinism","title":"6.1 Query Planning Determinism","text":"<p>Mechanism: Rule-based index selection with explicit versioning.</p> Factor How Determinism Is Ensured Index selection Fixed priority rules (e.g., prefer equality over range) No statistics-driven optimization Avoid cost estimation variance from data distribution Rule versioning Any rule change is versioned, requires explicit opt-in Explain plan Human-readable output shows exact reasoning <p>Invariants: T1, T3</p>"},{"location":"PROJECT_PLAN/#62-query-execution-determinism","title":"6.2 Query Execution Determinism","text":"<p>Mechanism: Explicit result ordering and no runtime variance.</p> Factor How Determinism Is Ensured Result ordering Always ordered by index traversal or primary key No parallel execution Single global execution lock (\u00a72.11) No timing dependence Execution does not depend on wall-clock or thread state Enforcement of limits Hard stops at declared limits <p>Invariants: T2</p>"},{"location":"PROJECT_PLAN/#63-crash-recovery-determinism","title":"6.3 Crash Recovery Determinism","text":"<p>Mechanism: Sequential WAL replay with deterministic application.</p> Factor How Determinism Is Ensured WAL ordering Entries applied in strict append order No heuristics All valid entries applied, corrupted entries cause halt Checksum verification Corrupted WAL entries cause explicit failure Explicit status Recovery reports success/failure explicitly <p>Invariants: R2, R3</p>"},{"location":"PROJECT_PLAN/#7-crash-recovery","title":"7. Crash Recovery","text":""},{"location":"PROJECT_PLAN/#71-recovery-conceptual-flow","title":"7.1 Recovery Conceptual Flow","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; DetectUncleanShutdown\n    DetectUncleanShutdown --&gt; ScanWAL: No clean shutdown marker\n    DetectUncleanShutdown --&gt; NormalStartup: Clean shutdown marker\n\n    ScanWAL --&gt; ValidateEntries: Read WAL from beginning\n    ValidateEntries --&gt; ReplayEntries: All checksums valid\n    ValidateEntries --&gt; HaltWithError: Any checksum failure\n\n    ReplayEntries --&gt; ApplyToStorage: Apply each entry sequentially\n    ApplyToStorage --&gt; RebuildIndexes: All WAL entries applied\n\n    RebuildIndexes --&gt; VerifyConsistency: Indexes rebuilt from storage\n    VerifyConsistency --&gt; ReportSuccess: Storage consistent\n    VerifyConsistency --&gt; HaltWithError: Consistency failure\n\n    ReportSuccess --&gt; NormalStartup\n    HaltWithError --&gt; [*]\n    NormalStartup --&gt; [*]</code></pre>"},{"location":"PROJECT_PLAN/#72-recovery-steps","title":"7.2 Recovery Steps","text":"<ol> <li>Detect Unclean Shutdown: Check for clean shutdown marker</li> <li>Scan WAL from Beginning: Phase 0 has no checkpointing; WAL replay starts at entry 0</li> <li>Validate Entries: Verify checksum of each WAL entry</li> <li>Any corrupted entry: halt and report (\u00a77.3)</li> <li>Replay Entries: Apply entries to storage in strict append order</li> <li>Same WAL \u2192 same resulting state (R2)</li> <li>Rebuild Indexes: Reconstruct all B-tree indexes from document storage</li> <li>Verify Consistency: Confirm storage matches replayed state</li> <li>Report Status: Explicit success/failure with details (R3)</li> <li>Success: database ready</li> <li>Failure: database does not start, operator intervention required</li> </ol>"},{"location":"PROJECT_PLAN/#73-wal-corruption-policy-phase-0","title":"7.3 WAL Corruption Policy (Phase 0)","text":"<p>Policy: Any WAL corruption halts startup. No partial replay.</p> Scenario Behavior Checksum failure in any WAL entry Halt startup immediately Truncated WAL file Halt startup immediately Unreadable WAL file Halt startup immediately Partial WAL entry at end of file Halt startup immediately <p>No Partial Replay: If any WAL entry is corrupted, the database refuses to start.</p> <p>Rationale: - Partial replay is non-deterministic (depends on corruption location) - Cannot distinguish between \"never written\" and \"corrupted after write\" - Predictable failure is safer than unpredictable recovery</p> <p>Operational Response: - Operator must restore from backup - WAL corruption is treated as catastrophic failure - System logs specific WAL entry number and checksum failure details</p> <p>Invariants Upheld: - K2 (Corruption Is Never Silently Repaired): Halt, don't repair - R2 (Recovery Is Deterministic): No heuristic partial replay - R3 (Recovery Completeness Is Verifiable): Explicit halt with reason</p>"},{"location":"PROJECT_PLAN/#74-checkpointing-strategy-phase-0","title":"7.4 Checkpointing Strategy (Phase 0)","text":"<p>Phase 0 Rule: Checkpointing does NOT exist.</p> Aspect Behavior WAL replay start point Always begins at WAL entry 0 (beginning) Checkpoints Not implemented in Phase 0 WAL truncation Not performed in Phase 0 Recovery time Proportional to total WAL size <p>Implications:</p> <ul> <li>Every recovery replays the entire WAL from the beginning</li> <li>WAL grows unbounded during a single session</li> <li>Clean shutdown writes shutdown marker but does not truncate WAL</li> <li>Restart after clean shutdown still replays full WAL</li> </ul> <p>Deferred Work (post-Phase 0): - Periodic checkpointing - WAL truncation after checkpoint - Incremental recovery from last checkpoint</p> <p>Invariants Upheld: - R2 (Recovery Is Deterministic): Full replay eliminates ambiguity</p>"},{"location":"PROJECT_PLAN/#75-recovery-guarantees","title":"7.5 Recovery Guarantees","text":"Guarantee Mechanism No data loss for acknowledged writes WAL synced before ack Deterministic result Sequential replay from beginning, no heuristics Corruption is fatal Any WAL corruption halts startup (\u00a77.3) Explicit status Recovery logs success or exact failure reason Index consistency Indexes rebuilt from storage after replay <p>Invariants Upheld: D1, R1, R2, R3, K1, K2</p>"},{"location":"PROJECT_PLAN/#8-configuration-constraints","title":"8. Configuration Constraints","text":""},{"location":"PROJECT_PLAN/#81-configuration-surface-phase-0","title":"8.1 Configuration Surface (Phase 0)","text":"<p>Principle: Minimal configuration surface with safe-only defaults.</p> Parameter Default Mutability Validation <code>data_dir</code> (required) Immutable after first start Must be writable directory <code>wal_sync_mode</code> <code>fsync</code> Immutable Only <code>fsync</code> allowed; other values rejected <code>max_wal_size_bytes</code> <code>1073741824</code> (1GB) Immutable Must be &gt; 0 <code>max_memory_bytes</code> <code>536870912</code> (512MB) Immutable Must be &gt; 0"},{"location":"PROJECT_PLAN/#82-forbidden-configurations","title":"8.2 Forbidden Configurations","text":"<p>The following configurations are rejected at startup:</p> Forbidden Setting Reason <code>wal_sync_mode != fsync</code> Weakens durability (violates D1, R1) Disable schema validation Violates S1, S2 Disable checksums Violates K1 Allow unbounded queries Violates Q1 Partial success mode Violates F2"},{"location":"PROJECT_PLAN/#83-configuration-validation","title":"8.3 Configuration Validation","text":"<p>Startup Behavior:</p> <ol> <li>Parse configuration file</li> <li>Validate all parameters against allowed values</li> <li>Reject any unsafe configuration with explicit error</li> <li>Log all configuration values at startup</li> </ol> <p>Error Example: <pre><code>FATAL: Invalid configuration\n  Parameter: wal_sync_mode\n  Value: \"none\"\n  Reason: WAL fsync cannot be disabled (violates durability guarantee D1)\n  Allowed values: [\"fsync\"]\n</code></pre></p> <p>Invariants Upheld: - O2 (Config Cannot Violate Safety): Unsafe configurations rejected</p>"},{"location":"PROJECT_PLAN/#9-invariant-to-component-mapping","title":"9. Invariant-to-Component Mapping","text":"Invariant Component(s) Responsible D1 (No Acknowledged Write Lost) WAL, Storage D2 (Corruption Never Ignored) Checksum Validator, Recovery Manager D3 (Reads Never Observe Invalid State) Schema Validator, Checksum Validator, Storage R1 (WAL Precedes Acknowledgement) WAL R2 (Recovery Is Deterministic) Recovery Manager, WAL R3 (Recovery Completeness Verifiable) Recovery Manager S1 (Schema Presence Mandatory) Schema Validator S2 (Schema Enforced on Write) Schema Validator S3 (Schema Versions Explicit) Schema Validator, Storage, Query Parser S4 (Schema Violations Fatal) Schema Validator Q1 (Queries Must Be Bounded) Query Planner Q2 (No Implicit Full Scans) Query Planner Q3 (Execution Never Guesses) Query Parser, Query Planner T1 (Deterministic Planning) Query Planner T2 (Deterministic Execution) Query Executor, Execution Concurrency Model T3 (Planner Changes Explicit) Query Planner F1 (Fail Loudly) All components F2 (No Partial Success) API Layer, all write operations F3 (Errors Are Deterministic) All components O1 (Environment-Independent) All components O2 (Config Cannot Violate Safety) Configuration Manager O3 (Observable System State) API Layer, all components K1 (Corruption Detection Mandatory) Checksum Validator, WAL K2 (Corruption Never Silently Repaired) Checksum Validator, Recovery Manager C1 (Single-Document Atomicity) WAL, Storage, Index Manager (\u00a73) C2 (Read-After-Write Consistency) Single-threaded execution (\u00a72.11)"},{"location":"PROJECT_PLAN/#10-trade-offs-and-non-goals","title":"10. Trade-offs and Non-Goals","text":""},{"location":"PROJECT_PLAN/#101-deliberate-trade-offs","title":"10.1 Deliberate Trade-offs","text":"Trade-off What Is Sacrificed What Is Gained Deterministic planning over adaptive optimization Potentially suboptimal plans for edge cases Predictable, repeatable behavior Fsync on every write Write latency Durability guarantee (D1) No heuristics Less \"intelligent\" query optimization Explainable, auditable behavior Reject unbounded queries Some queries require user restructuring System stability, no runaway operations Single-threaded execution Parallelism/throughput Determinism, simplicity Halt on corruption Availability Data integrity (never serve corrupt data) No checkpointing (Phase 0) Longer recovery time Simpler implementation, guaranteed determinism Indexes as derived state Recovery rebuilds indexes Simpler WAL, smaller log size"},{"location":"PROJECT_PLAN/#102-what-is-deliberately-not-optimized","title":"10.2 What Is Deliberately NOT Optimized","text":"<p>Per SCOPE.md and VISION.md, the following are explicitly not goals for Phase 0:</p> Non-Goal Reason Maximum throughput Correctness over performance Minimal latency Fsync guarantees add latency; safety matters more Query flexibility Bounded, schema-valid operations only Schemaless convenience Schema presence is mandatory Automatic optimization Determinism requires explicit control Multi-node scalability Out of scope (single-node only) Feature breadth Scope discipline is a feature Fast recovery No checkpointing in Phase 0; full WAL replay"},{"location":"PROJECT_PLAN/#103-explicit-non-features-phase-0","title":"10.3 Explicit Non-Features (Phase 0)","text":"<ul> <li>Joins</li> <li>Aggregations</li> <li>Multi-document transactions</li> <li>Replication</li> <li>Sharding</li> <li>Auto-indexing</li> <li>Full-text search</li> <li>Adaptive query rewriting</li> <li>Checkpointing</li> <li>WAL truncation</li> <li>Multi-version schema reads</li> </ul>"},{"location":"PROJECT_PLAN/#11-summary","title":"11. Summary","text":"<p>This architecture defines a strict, deterministic, single-node document database with:</p> <ul> <li>Mandatory schemas enforced at write time with explicit version references</li> <li>WAL-backed durability with explicit fsync before acknowledgment</li> <li>Deterministic query planning using rule-based index selection (no heuristics)</li> <li>Deterministic execution via single global execution lock (no concurrency)</li> <li>Deterministic crash recovery via full WAL replay from beginning (no checkpointing in Phase 0)</li> <li>Fail-loud semantics for all error conditions</li> <li>Checksum-based corruption detection with halt-on-corruption policy (no silent repair)</li> <li>Single-document atomicity with indexes as derived, recoverable state</li> <li>Bounded operations with formal rules for update/delete predicates</li> <li>Single schema version per query (no cross-version reads in Phase 0)</li> <li>Minimal, safe-only configuration with explicit rejection of unsafe settings</li> </ul> <p>Every component is designed to uphold one or more invariants from INVARIANTS.md. Trade-offs are explicit and align with VISION.md priorities: correctness over performance, predictability over cleverness, explicitness over magic.</p>"},{"location":"REALTIME_ARCHITECTURE/","title":"Phase 10: Real-Time Architecture","text":"<p>Document Type: Technical Architecture Phase: 10 - Real-Time Subscriptions Status: Active</p>"},{"location":"REALTIME_ARCHITECTURE/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Client Applications                          \u2502\n\u2502              WebSocket connections to /realtime                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u25b2\n                              \u2502 WebSocket (wss://)\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     WebSocket Server                             \u2502\n\u2502  - Connection management                                         \u2502\n\u2502  - Authentication (JWT from ?token= or header)                   \u2502\n\u2502  - Subscription routing                                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Subscription Manager                         \u2502\n\u2502  - Track client subscriptions                                    \u2502\n\u2502  - Filter events by subscription predicates                      \u2502\n\u2502  - Apply RLS before delivery                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u25b2\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Event Dispatcher                             \u2502\n\u2502  - Receive events from Event Log                                 \u2502\n\u2502  - Fan-out to subscribed clients                                 \u2502\n\u2502  - Non-deterministic (best-effort)                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u25b2\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Event Log (Deterministic)                    \u2502\n\u2502  - WAL \u2192 Event transformation                                    \u2502\n\u2502  - Sequence numbers for ordering                                 \u2502\n\u2502  - In-memory ring buffer (configurable size)                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u25b2\n                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     WAL (Write-Ahead Log)                        \u2502\n\u2502  - Source of truth for all mutations                             \u2502\n\u2502  - Deterministic and durable                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"REALTIME_ARCHITECTURE/#module-structure","title":"Module Structure","text":"<pre><code>src/realtime/\n\u251c\u2500\u2500 mod.rs           # Module entry, exports\n\u251c\u2500\u2500 errors.rs        # Real-time error types\n\u251c\u2500\u2500 event.rs         # Event types (DatabaseEvent, BroadcastEvent)\n\u251c\u2500\u2500 event_log.rs     # WAL \u2192 Event transformation\n\u251c\u2500\u2500 subscription.rs  # Subscription management\n\u251c\u2500\u2500 dispatcher.rs    # Event fan-out\n\u251c\u2500\u2500 broadcast.rs     # Pub/sub channels\n\u251c\u2500\u2500 presence.rs      # User presence tracking\n\u2514\u2500\u2500 server.rs        # WebSocket server (tokio-tungstenite)\n</code></pre>"},{"location":"REALTIME_ARCHITECTURE/#data-flow","title":"Data Flow","text":"<ol> <li>Write committed to WAL</li> <li>Event Log observes WAL \u2192 Creates <code>DatabaseEvent</code></li> <li>Dispatcher receives event \u2192 Looks up subscriptions</li> <li>Per-subscription: Apply RLS filter \u2192 Deliver if allowed</li> <li>Client receives event over WebSocket</li> </ol>"},{"location":"REALTIME_ARCHITECTURE/#integration-points","title":"Integration Points","text":"Component Integration WAL (Phase 1) Event Log reads committed entries Auth (Phase 8) JWT validation, RlsContext REST API (Phase 9) Shared RLS enforcement"},{"location":"REALTIME_BROADCAST_MODEL/","title":"Phase 10: Broadcast Model","text":"<p>Document Type: Technical Specification Phase: 10 - Real-Time Subscriptions Status: Active</p>"},{"location":"REALTIME_BROADCAST_MODEL/#overview","title":"Overview","text":"<p>Broadcast channels allow clients to send messages to each other without persisting to the database.</p>"},{"location":"REALTIME_BROADCAST_MODEL/#channel-types","title":"Channel Types","text":""},{"location":"REALTIME_BROADCAST_MODEL/#public-channels","title":"Public Channels","text":"<p>Anyone can join and broadcast:</p> <pre><code>realtime:broadcast:public-announcements\n</code></pre>"},{"location":"REALTIME_BROADCAST_MODEL/#private-channels","title":"Private Channels","text":"<p>Require membership (checked via RLS):</p> <pre><code>realtime:broadcast:private-team-123\n</code></pre>"},{"location":"REALTIME_BROADCAST_MODEL/#message-format","title":"Message Format","text":""},{"location":"REALTIME_BROADCAST_MODEL/#send","title":"Send","text":"<pre><code>{\n  \"type\": \"broadcast\",\n  \"topic\": \"realtime:broadcast:chat-room-1\",\n  \"event\": \"message\",\n  \"payload\": {\n    \"text\": \"Hello, world!\"\n  }\n}\n</code></pre>"},{"location":"REALTIME_BROADCAST_MODEL/#receive","title":"Receive","text":"<pre><code>{\n  \"type\": \"broadcast\",\n  \"topic\": \"realtime:broadcast:chat-room-1\",\n  \"event\": \"message\",\n  \"payload\": {\n    \"text\": \"Hello, world!\",\n    \"sender_id\": \"user-uuid\"\n  }\n}\n</code></pre>"},{"location":"REALTIME_BROADCAST_MODEL/#channel-isolation","title":"Channel Isolation","text":"<ul> <li>Channels are isolated by name</li> <li>No cross-channel message leakage</li> <li>RLS can restrict channel access</li> </ul>"},{"location":"REALTIME_BROADCAST_MODEL/#rate-limiting","title":"Rate Limiting","text":"Limit Value Messages per second 10 Message size 64KB Channels per connection 100"},{"location":"REALTIME_DETERMINISM_BOUNDARY/","title":"Phase 10: Determinism Boundary","text":"<p>Document Type: Normative Specification Phase: 10 - Real-Time Subscriptions Status: Active</p>"},{"location":"REALTIME_DETERMINISM_BOUNDARY/#the-boundary","title":"The Boundary","text":"<p>AeroDB maintains strict determinism through Phase 7. Phase 10 introduces explicit non-determinism for real-time delivery.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         DETERMINISTIC ZONE                \u2502\n\u2502  WAL \u2192 Event Log \u2192 Sequence Numbers       \u2502\n\u2502  Same input \u2192 Same output                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2551\n                    \u2551 \u2190 DETERMINISM BOUNDARY\n                    \u2551\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       NON-DETERMINISTIC ZONE              \u2502\n\u2502  Dispatcher \u2192 WebSocket \u2192 Client          \u2502\n\u2502  Best-effort, no ordering guarantees      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"REALTIME_DETERMINISM_BOUNDARY/#what-is-deterministic","title":"What IS Deterministic","text":"Component Guarantee Event generation Same WAL \u2192 Same events Sequence numbers Monotonically increasing Event content Immutable once created Event ordering in log Matches WAL order"},{"location":"REALTIME_DETERMINISM_BOUNDARY/#what-is-not-deterministic","title":"What is NOT Deterministic","text":"Component Why Delivery timing Network latency varies Client receive order Multiple TCP connections Reconnection behavior Client-dependent Presence state Eventually consistent"},{"location":"REALTIME_DETERMINISM_BOUNDARY/#client-responsibilities","title":"Client Responsibilities","text":"<ol> <li>Handle out-of-order events using sequence numbers</li> <li>Implement idempotency for event processing</li> <li>Support reconnection with resume from last sequence</li> <li>Tolerate missed events during disconnection</li> </ol>"},{"location":"REALTIME_DETERMINISM_BOUNDARY/#why-this-design","title":"Why This Design?","text":"<p>\"It is better to be explicitly non-deterministic than to pretend guarantees that don't exist.\"</p> <p>Real-time delivery over networks cannot be deterministic. AeroDB acknowledges this honestly.</p>"},{"location":"REALTIME_EVENT_MODEL/","title":"Phase 10: Event Model","text":"<p>Document Type: Technical Specification Phase: 10 - Real-Time Subscriptions Status: Active</p>"},{"location":"REALTIME_EVENT_MODEL/#event-types","title":"Event Types","text":""},{"location":"REALTIME_EVENT_MODEL/#database-events","title":"Database Events","text":"<p>Generated from WAL entries:</p> <pre><code>pub enum EventType {\n    INSERT,\n    UPDATE,\n    DELETE,\n}\n\npub struct DatabaseEvent {\n    /// Monotonically increasing sequence number\n    pub sequence: u64,\n\n    /// Event type\n    pub event_type: EventType,\n\n    /// Collection name\n    pub collection: String,\n\n    /// Record ID\n    pub record_id: String,\n\n    /// New record data (for INSERT/UPDATE)\n    pub new_data: Option&lt;Value&gt;,\n\n    /// Old record data (for UPDATE/DELETE)\n    pub old_data: Option&lt;Value&gt;,\n\n    /// Timestamp of the event\n    pub timestamp: DateTime&lt;Utc&gt;,\n\n    /// User who made the change (if authenticated)\n    pub user_id: Option&lt;Uuid&gt;,\n}\n</code></pre>"},{"location":"REALTIME_EVENT_MODEL/#broadcast-events","title":"Broadcast Events","text":"<p>User-generated messages to channels:</p> <pre><code>pub struct BroadcastEvent {\n    /// Channel name\n    pub channel: String,\n\n    /// Event name (user-defined)\n    pub event: String,\n\n    /// Payload\n    pub payload: Value,\n\n    /// Sender user ID\n    pub sender_id: Option&lt;Uuid&gt;,\n\n    /// Timestamp\n    pub timestamp: DateTime&lt;Utc&gt;,\n}\n</code></pre>"},{"location":"REALTIME_EVENT_MODEL/#wal-event-transformation","title":"WAL \u2192 Event Transformation","text":""},{"location":"REALTIME_EVENT_MODEL/#deterministic-mapping","title":"Deterministic Mapping","text":"WAL Record Type Event Type Behavior Insert INSERT new_data = record Update UPDATE old_data = before, new_data = after Delete DELETE old_data = record"},{"location":"REALTIME_EVENT_MODEL/#invariant-rt-e1","title":"Invariant: RT-E1","text":"<p>Same WAL sequence \u2192 Same event sequence</p> <p>The Event Log transformation is deterministic and reproducible.</p>"},{"location":"REALTIME_EVENT_MODEL/#event-serialization","title":"Event Serialization","text":"<p>Events sent over WebSocket as JSON:</p> <pre><code>{\n  \"type\": \"postgres_changes\",\n  \"payload\": {\n    \"event\": \"INSERT\",\n    \"schema\": \"public\",\n    \"table\": \"posts\",\n    \"new\": { \"id\": \"...\", \"title\": \"...\" },\n    \"old\": null,\n    \"commit_timestamp\": \"2026-02-06T00:00:00Z\"\n  }\n}\n</code></pre> <p>Compatible with Supabase Realtime protocol for client SDK compatibility.</p>"},{"location":"REALTIME_INVARIANTS/","title":"Phase 10: Real-Time Invariants","text":"<p>Document Type: Normative Specification Phase: 10 - Real-Time Subscriptions Status: Active</p>"},{"location":"REALTIME_INVARIANTS/#event-log-invariants","title":"Event Log Invariants","text":""},{"location":"REALTIME_INVARIANTS/#rt-e1-deterministic-transformation","title":"RT-E1: Deterministic Transformation","text":"<p>Same WAL \u2192 Same events. Event generation is reproducible.</p>"},{"location":"REALTIME_INVARIANTS/#rt-e2-monotonic-sequence","title":"RT-E2: Monotonic Sequence","text":"<p>Event sequence numbers are monotonically increasing, gapless.</p>"},{"location":"REALTIME_INVARIANTS/#rt-e3-immutable-events","title":"RT-E3: Immutable Events","text":"<p>Once an event is created, it cannot be modified.</p>"},{"location":"REALTIME_INVARIANTS/#delivery-invariants","title":"Delivery Invariants","text":""},{"location":"REALTIME_INVARIANTS/#rt-d1-best-effort-delivery","title":"RT-D1: Best-Effort Delivery","text":"<p>No guarantee of delivery. Clients must handle missed events.</p>"},{"location":"REALTIME_INVARIANTS/#rt-d2-no-ordering-guarantee","title":"RT-D2: No Ordering Guarantee","text":"<p>Events may arrive out of order. Use sequence numbers for ordering.</p>"},{"location":"REALTIME_INVARIANTS/#rt-d3-rls-filtered","title":"RT-D3: RLS Filtered","text":"<p>Events are filtered by RLS before delivery. No unauthorized access.</p>"},{"location":"REALTIME_INVARIANTS/#subscription-invariants","title":"Subscription Invariants","text":""},{"location":"REALTIME_INVARIANTS/#rt-s1-explicit-subscribe","title":"RT-S1: Explicit Subscribe","text":"<p>No implicit subscriptions. Clients must explicitly subscribe.</p>"},{"location":"REALTIME_INVARIANTS/#rt-s2-scoped-delivery","title":"RT-S2: Scoped Delivery","text":"<p>Events only delivered to subscribed clients.</p>"},{"location":"REALTIME_INVARIANTS/#rt-s3-clean-unsubscribe","title":"RT-S3: Clean Unsubscribe","text":"<p>Unsubscribe immediately stops delivery (best-effort).</p>"},{"location":"REALTIME_INVARIANTS/#presence-invariants","title":"Presence Invariants","text":""},{"location":"REALTIME_INVARIANTS/#rt-p1-eventually-consistent","title":"RT-P1: Eventually Consistent","text":"<p>Presence is eventually consistent, not immediately consistent.</p>"},{"location":"REALTIME_INVARIANTS/#rt-p2-heartbeat-required","title":"RT-P2: Heartbeat Required","text":"<p>No heartbeat for 60s = considered offline.</p>"},{"location":"REALTIME_INVARIANTS/#broadcast-invariants","title":"Broadcast Invariants","text":""},{"location":"REALTIME_INVARIANTS/#rt-b1-no-persistence","title":"RT-B1: No Persistence","text":"<p>Broadcast messages are not persisted.</p>"},{"location":"REALTIME_INVARIANTS/#rt-b2-channel-isolation","title":"RT-B2: Channel Isolation","text":"<p>Messages in channel A never leak to channel B.</p>"},{"location":"REALTIME_PRESENCE_MODEL/","title":"Phase 10: Presence Model","text":"<p>Document Type: Technical Specification Phase: 10 - Real-Time Subscriptions Status: Active</p>"},{"location":"REALTIME_PRESENCE_MODEL/#overview","title":"Overview","text":"<p>Presence tracks which users are currently connected to a channel.</p>"},{"location":"REALTIME_PRESENCE_MODEL/#presence-state","title":"Presence State","text":"<pre><code>pub struct PresenceState {\n    /// User ID\n    pub user_id: Uuid,\n\n    /// User metadata (online status, custom data)\n    pub metadata: Value,\n\n    /// When user joined\n    pub joined_at: DateTime&lt;Utc&gt;,\n\n    /// Last heartbeat\n    pub last_seen: DateTime&lt;Utc&gt;,\n}\n</code></pre>"},{"location":"REALTIME_PRESENCE_MODEL/#events","title":"Events","text":""},{"location":"REALTIME_PRESENCE_MODEL/#track-join","title":"Track (Join)","text":"<pre><code>{\n  \"type\": \"presence\",\n  \"topic\": \"realtime:presence:lobby\",\n  \"event\": \"track\",\n  \"payload\": {\n    \"status\": \"online\",\n    \"typing\": false\n  }\n}\n</code></pre>"},{"location":"REALTIME_PRESENCE_MODEL/#untrack-leave","title":"Untrack (Leave)","text":"<pre><code>{\n  \"type\": \"presence\",\n  \"event\": \"untrack\"\n}\n</code></pre>"},{"location":"REALTIME_PRESENCE_MODEL/#sync-get-all","title":"Sync (Get All)","text":"<p>Server sends current state on join:</p> <pre><code>{\n  \"type\": \"presence\",\n  \"event\": \"sync\",\n  \"payload\": {\n    \"user-1\": { \"status\": \"online\" },\n    \"user-2\": { \"status\": \"away\" }\n  }\n}\n</code></pre>"},{"location":"REALTIME_PRESENCE_MODEL/#liveness-detection","title":"Liveness Detection","text":"<ul> <li>Heartbeat interval: 30 seconds</li> <li>Timeout: 60 seconds (2 missed heartbeats)</li> <li>Explicit leave on disconnect</li> </ul>"},{"location":"REALTIME_PRESENCE_MODEL/#invariant-rt-p1","title":"Invariant: RT-P1","text":"<p>Presence is eventually consistent, not immediately consistent.</p> <p>Users may appear briefly after disconnect due to heartbeat window.</p>"},{"location":"REALTIME_READINESS/","title":"Phase 10: Readiness Checklist","text":"<p>Document Type: Freeze Criteria Phase: 10 - Real-Time Subscriptions Status: In Progress</p>"},{"location":"REALTIME_READINESS/#documentation","title":"Documentation","text":"Document Status REALTIME_VISION.md \u2705 REALTIME_ARCHITECTURE.md \u2705 REALTIME_EVENT_MODEL.md \u2705 REALTIME_SUBSCRIPTION_MODEL.md \u2705 REALTIME_BROADCAST_MODEL.md \u2705 REALTIME_PRESENCE_MODEL.md \u2705 REALTIME_DETERMINISM_BOUNDARY.md \u2705 REALTIME_INVARIANTS.md \u2705 REALTIME_TESTING_STRATEGY.md \u2705 REALTIME_READINESS.md \u2705"},{"location":"REALTIME_READINESS/#implementation","title":"Implementation","text":"Module Status Tests mod.rs \u2610 N/A errors.rs \u2610 \u2610 event.rs \u2610 \u2610 event_log.rs \u2610 \u2610 subscription.rs \u2610 \u2610 dispatcher.rs \u2610 \u2610 broadcast.rs \u2610 \u2610 presence.rs \u2610 \u2610"},{"location":"REALTIME_READINESS/#freeze-criteria","title":"Freeze Criteria","text":""},{"location":"REALTIME_READINESS/#must-have","title":"Must Have","text":"<ul> <li> Event Log with deterministic transformation</li> <li> Subscription management</li> <li> RLS filtering on events</li> <li> Unit tests passing</li> </ul>"},{"location":"REALTIME_READINESS/#should-have","title":"Should Have","text":"<ul> <li> Broadcast channels</li> <li> Presence tracking</li> <li> WebSocket server</li> </ul>"},{"location":"REALTIME_READINESS/#nice-to-have","title":"Nice to Have","text":"<ul> <li> Resume from sequence number</li> <li> Connection pooling</li> </ul>"},{"location":"REALTIME_READINESS/#freeze-status","title":"Freeze Status","text":"<p>Status: NOT READY</p> <p>Implementation pending.</p>"},{"location":"REALTIME_SUBSCRIPTION_MODEL/","title":"Phase 10: Subscription Model","text":"<p>Document Type: Technical Specification Phase: 10 - Real-Time Subscriptions Status: Active</p>"},{"location":"REALTIME_SUBSCRIPTION_MODEL/#subscription-types","title":"Subscription Types","text":""},{"location":"REALTIME_SUBSCRIPTION_MODEL/#database-changes","title":"Database Changes","text":"<p>Subscribe to INSERT/UPDATE/DELETE on collections:</p> <pre><code>{\n  \"type\": \"subscribe\",\n  \"topic\": \"realtime:public:posts\",\n  \"event\": \"*\",\n  \"filter\": \"author_id=eq.123\"\n}\n</code></pre>"},{"location":"REALTIME_SUBSCRIPTION_MODEL/#broadcast","title":"Broadcast","text":"<p>Subscribe to user-defined channels:</p> <pre><code>{\n  \"type\": \"subscribe\",\n  \"topic\": \"realtime:broadcast:chat-room-1\"\n}\n</code></pre>"},{"location":"REALTIME_SUBSCRIPTION_MODEL/#presence","title":"Presence","text":"<p>Subscribe to user presence:</p> <pre><code>{\n  \"type\": \"subscribe\",\n  \"topic\": \"realtime:presence:lobby\"\n}\n</code></pre>"},{"location":"REALTIME_SUBSCRIPTION_MODEL/#subscription-lifecycle","title":"Subscription Lifecycle","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    subscribe    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  NONE   \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502  PENDING   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                   \u2502\n                                   \u2502 ack\n                                   \u25bc\n                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                             \u2502   ACTIVE   \u2502\n                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                   \u2502\n                                   \u2502 unsubscribe / disconnect\n                                   \u25bc\n                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                             \u2502   REMOVED  \u2502\n                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"REALTIME_SUBSCRIPTION_MODEL/#subscription-filtering","title":"Subscription Filtering","text":""},{"location":"REALTIME_SUBSCRIPTION_MODEL/#collection-filters","title":"Collection Filters","text":"<p>PostgREST-style syntax:</p> <ul> <li><code>author_id=eq.123</code> - Equals</li> <li><code>status=in.(draft,published)</code> - In list</li> <li><code>created_at=gt.2026-01-01</code> - Greater than</li> </ul>"},{"location":"REALTIME_SUBSCRIPTION_MODEL/#rls-filtering","title":"RLS Filtering","text":"<p>Before delivery, each event is checked against RLS:</p> <ol> <li>Extract user_id from subscription context</li> <li>Check if user can access the record</li> <li>Only deliver if RLS passes</li> </ol>"},{"location":"REALTIME_SUBSCRIPTION_MODEL/#subscription-registry","title":"Subscription Registry","text":"<pre><code>pub struct SubscriptionRegistry {\n    /// Subscriptions by topic\n    by_topic: HashMap&lt;String, Vec&lt;Subscription&gt;&gt;,\n\n    /// Subscriptions by connection ID\n    by_connection: HashMap&lt;String, Vec&lt;String&gt;&gt;,\n}\n</code></pre>"},{"location":"REALTIME_TESTING_STRATEGY/","title":"Phase 10: Testing Strategy","text":"<p>Document Type: Technical Specification Phase: 10 - Real-Time Subscriptions Status: Active</p>"},{"location":"REALTIME_TESTING_STRATEGY/#test-categories","title":"Test Categories","text":""},{"location":"REALTIME_TESTING_STRATEGY/#unit-tests","title":"Unit Tests","text":"Component Coverage Target event.rs 100% event_log.rs 95% subscription.rs 90% dispatcher.rs 85% broadcast.rs 90% presence.rs 90%"},{"location":"REALTIME_TESTING_STRATEGY/#integration-tests","title":"Integration Tests","text":"Scenario Dependencies End-to-end event flow Event Log, Dispatcher Subscription filtering Subscription, RLS Broadcast channels Broadcast, WebSocket Presence sync Presence, WebSocket"},{"location":"REALTIME_TESTING_STRATEGY/#critical-test-scenarios","title":"Critical Test Scenarios","text":""},{"location":"REALTIME_TESTING_STRATEGY/#event-log","title":"Event Log","text":"<ol> <li>WAL entry produces correct event type</li> <li>Sequence numbers are gapless</li> <li>Same WAL replayed = same events</li> </ol>"},{"location":"REALTIME_TESTING_STRATEGY/#subscriptions","title":"Subscriptions","text":"<ol> <li>Subscribe receives confirmation</li> <li>Matching events delivered</li> <li>Non-matching events filtered</li> <li>RLS prevents unauthorized access</li> </ol>"},{"location":"REALTIME_TESTING_STRATEGY/#dispatcher","title":"Dispatcher","text":"<ol> <li>Events fan-out to all subscribers</li> <li>Unsubscribed clients don't receive</li> <li>Disconnected clients cleaned up</li> </ol>"},{"location":"REALTIME_TESTING_STRATEGY/#broadcast","title":"Broadcast","text":"<ol> <li>Messages delivered to channel</li> <li>Non-subscribers don't receive</li> <li>Rate limiting enforced</li> </ol>"},{"location":"REALTIME_TESTING_STRATEGY/#presence","title":"Presence","text":"<ol> <li>Track adds user to presence</li> <li>Untrack removes user</li> <li>Timeout removes user after 60s</li> </ol>"},{"location":"REALTIME_TESTING_STRATEGY/#determinism-tests","title":"Determinism Tests","text":""},{"location":"REALTIME_TESTING_STRATEGY/#rt-e1-test","title":"RT-E1 Test","text":"<pre><code>#[test]\nfn same_wal_same_events() {\n    let wal = create_test_wal();\n    let events1 = EventLog::replay(&amp;wal);\n    let events2 = EventLog::replay(&amp;wal);\n    assert_eq!(events1, events2);\n}\n</code></pre>"},{"location":"REALTIME_TESTING_STRATEGY/#coverage-requirements","title":"Coverage Requirements","text":"Component Minimum Event Log 95% Subscription 90% Overall 85%"},{"location":"REALTIME_VISION/","title":"Phase 10: Real-Time Vision","text":"<p>Document Type: Vision Statement Phase: 10 - Real-Time Subscriptions Status: Active</p>"},{"location":"REALTIME_VISION/#goal","title":"Goal","text":"<p>Enable real-time event subscriptions over WebSocket, allowing clients to receive database changes as they happen, while preserving AeroDB's determinism guarantees where possible.</p>"},{"location":"REALTIME_VISION/#philosophy","title":"Philosophy","text":""},{"location":"REALTIME_VISION/#determinism-boundary","title":"Determinism Boundary","text":"<p>AeroDB introduces a clear determinism boundary in Phase 10:</p> Layer Determinism Guarantee WAL Deterministic Same writes \u2192 Same log Event Log Deterministic Same WAL \u2192 Same events Dispatcher Non-Deterministic Best-effort delivery Client Non-Deterministic Must handle out-of-order <p>Key Insight: The Event Log is the last deterministic layer. Clients see a projection that may differ due to network conditions.</p>"},{"location":"REALTIME_VISION/#core-principles","title":"Core Principles","text":"<ol> <li>Event Log as Source of Truth - Database events derived from WAL</li> <li>Explicit Non-Determinism - Dispatcher makes no ordering guarantees</li> <li>RLS-Filtered Delivery - Events filtered per-user before dispatch</li> <li>Fail-Open for Delivery - Missed events don't crash the system</li> <li>Explicit Subscriptions - No implicit broadcast</li> </ol>"},{"location":"REALTIME_VISION/#non-goals","title":"Non-Goals","text":"<ul> <li>Exactly-once delivery (at-least-once is acceptable)</li> <li>Global ordering of events across all clients</li> <li>Guaranteed delivery (clients must handle reconnection)</li> <li>Persistent event history (events are ephemeral)</li> </ul>"},{"location":"REALTIME_VISION/#success-criteria","title":"Success Criteria","text":"<ol> <li>Clients receive events within 100ms of commit (p95)</li> <li>RLS filtering applied to all events</li> <li>System handles 10k concurrent WebSocket connections</li> <li>Clean reconnection with resume from sequence number</li> </ol>"},{"location":"REPLICATION_INVARIANTS/","title":"Invariants","text":""},{"location":"REPLICATION_INVARIANTS/#aerodb-phase-2-mvcc-invariants","title":"AeroDB Phase 2 \u2014 MVCC Invariants","text":""},{"location":"REPLICATION_INVARIANTS/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>All invariants herein are non-negotiable</li> <li>Phase-1 invariants remain in force unless explicitly restated as unchanged</li> <li>No implementation details appear here</li> </ul>"},{"location":"REPLICATION_INVARIANTS/#1-phase-1-invariants-that-remain-unchanged","title":"1. Phase-1 Invariants That Remain Unchanged","text":"<p>The following Phase-1 invariants are fully preserved under MVCC. MVCC must not weaken, reinterpret, or bypass them.</p>"},{"location":"REPLICATION_INVARIANTS/#11-durability-invariants","title":"1.1 Durability Invariants","text":"<ul> <li>Any write acknowledged to a client is durable</li> <li> <p>Durability is defined by:</p> </li> <li> <p>WAL append</p> </li> <li>Checksum verification</li> <li>fsync completion</li> <li>MVCC metadata is subject to the same durability rules as document data</li> </ul>"},{"location":"REPLICATION_INVARIANTS/#12-recovery-invariants","title":"1.2 Recovery Invariants","text":"<ul> <li>Recovery is deterministic</li> <li> <p>WAL replay produces:</p> </li> <li> <p>Identical document state</p> </li> <li>Identical MVCC version state</li> <li>Recovery never guesses, skips, or heals inconsistencies</li> </ul>"},{"location":"REPLICATION_INVARIANTS/#13-corruption-detection-invariants","title":"1.3 Corruption Detection Invariants","text":"<ul> <li>All persisted MVCC data is checksummed</li> <li> <p>Corruption is:</p> </li> <li> <p>Always detected</p> </li> <li>Never repaired silently</li> <li>Detection halts recovery with explicit error</li> </ul>"},{"location":"REPLICATION_INVARIANTS/#14-query-determinism-invariants","title":"1.4 Query Determinism Invariants","text":"<ul> <li> <p>Queries are:</p> </li> <li> <p>Bounded</p> </li> <li>Deterministic</li> <li>Independent of timing or thread scheduling</li> <li>MVCC visibility must not introduce nondeterministic results</li> </ul>"},{"location":"REPLICATION_INVARIANTS/#15-snapshot-checkpoint-invariants","title":"1.5 Snapshot &amp; Checkpoint Invariants","text":"<ul> <li> <p>Snapshots are:</p> </li> <li> <p>Read-only</p> </li> <li>fsync-safe</li> <li>Manifest-driven</li> <li>MVCC state included in snapshots must be complete and self-consistent</li> <li>Checkpoints remain crash-safe and WAL-truncation-safe</li> </ul>"},{"location":"REPLICATION_INVARIANTS/#2-core-mvcc-invariants-new","title":"2. Core MVCC Invariants (New)","text":"<p>These invariants define what must always be true once MVCC exists.</p>"},{"location":"REPLICATION_INVARIANTS/#21-version-immutability-invariant","title":"2.1 Version Immutability Invariant","text":"<ul> <li>Once created, a document version is immutable</li> <li>No in-place modification of historical data is allowed</li> <li>Updates create new versions only</li> <li>Deletes are represented as explicit tombstone versions</li> </ul> <p>History is append-only in meaning, even if storage optimizations exist.</p>"},{"location":"REPLICATION_INVARIANTS/#22-visibility-determinism-invariant","title":"2.2 Visibility Determinism Invariant","text":"<ul> <li> <p>Given:</p> </li> <li> <p>A database state</p> </li> <li>A read view identifier</li> <li>The set of visible versions is fully deterministic</li> <li> <p>Visibility:</p> </li> <li> <p>Does not depend on wall-clock time</p> </li> <li>Does not depend on thread interleaving</li> <li>Does not depend on runtime heuristics</li> </ul> <p>The same inputs always produce the same visible results.</p>"},{"location":"REPLICATION_INVARIANTS/#23-read-view-stability-invariant","title":"2.3 Read View Stability Invariant","text":"<ul> <li>A read operation observes a stable view</li> <li> <p>Once established, a read view:</p> </li> <li> <p>Never changes</p> </li> <li>Never sees partial writes</li> <li>Never sees future versions</li> </ul> <p>Readers are never blocked by writers for correctness.</p>"},{"location":"REPLICATION_INVARIANTS/#24-write-atomicity-invariant","title":"2.4 Write Atomicity Invariant","text":"<ul> <li> <p>A write either:</p> </li> <li> <p>Produces a fully visible new version, or</p> </li> <li>Produces nothing</li> <li> <p>No reader may observe:</p> </li> <li> <p>Half-written versions</p> </li> <li>Partially linked metadata</li> <li>Atomicity holds across crashes and recovery</li> </ul>"},{"location":"REPLICATION_INVARIANTS/#25-commit-ordering-invariant","title":"2.5 Commit Ordering Invariant","text":"<ul> <li>All committed versions have a total, deterministic order</li> <li> <p>That order:</p> </li> <li> <p>Is preserved across restarts</p> </li> <li>Is reproducible during WAL replay</li> <li>There are no \u201cties\u201d or ambiguous commit positions</li> </ul> <p>This ordering is the backbone of visibility, recovery, and replication.</p>"},{"location":"REPLICATION_INVARIANTS/#26-snapshot-compatibility-invariant","title":"2.6 Snapshot Compatibility Invariant","text":"<ul> <li>MVCC must integrate with existing snapshot semantics</li> <li> <p>A snapshot:</p> </li> <li> <p>Represents a valid MVCC cut</p> </li> <li>Contains all versions required to satisfy that cut</li> <li> <p>No snapshot may reference:</p> </li> <li> <p>Missing versions</p> </li> <li>External state</li> <li>Implicit history</li> </ul>"},{"location":"REPLICATION_INVARIANTS/#27-crash-safety-invariant-mvcc-specific","title":"2.7 Crash Safety Invariant (MVCC-Specific)","text":"<p>At any crash point:</p> <ul> <li> <p>Recovery must land in one of two states:</p> </li> <li> <p>Before a version exists</p> </li> <li>After the version exists fully</li> <li>No intermediate MVCC state is valid</li> <li>WAL is the sole authority for resolving ambiguity</li> </ul>"},{"location":"REPLICATION_INVARIANTS/#28-garbage-collection-safety-invariant","title":"2.8 Garbage Collection Safety Invariant","text":"<ul> <li> <p>A version may be reclaimed only if:</p> </li> <li> <p>It is provably invisible to all possible read views</p> </li> <li> <p>GC decisions must be:</p> </li> <li> <p>Deterministic</p> </li> <li>Recoverable</li> <li>Replayable</li> <li>GC must never race visibility correctness</li> </ul> <p>Space may be sacrificed for correctness, never the reverse.</p>"},{"location":"REPLICATION_INVARIANTS/#29-replication-readiness-invariant","title":"2.9 Replication Readiness Invariant","text":"<p>Even before replication is implemented:</p> <ul> <li> <p>MVCC semantics must be:</p> </li> <li> <p>Serializable into WAL</p> </li> <li>Reconstructible on another node</li> <li>No local-only shortcuts</li> <li>No hidden state outside formal persistence</li> </ul>"},{"location":"REPLICATION_INVARIANTS/#3-explicitly-forbidden-behaviors","title":"3. Explicitly Forbidden Behaviors","text":"<p>MVCC must never:</p> <ul> <li>Infer visibility from system time</li> <li>Allow \u201cbest-effort\u201d reads</li> <li>Auto-resolve write-write conflicts silently</li> <li>Skip MVCC metadata during recovery</li> <li>Leak uncommitted state to readers</li> <li>Introduce implicit isolation levels</li> </ul> <p>If behavior cannot be described as an invariant, it does not exist.</p>"},{"location":"REPLICATION_INVARIANTS/#4-invariant-enforcement-philosophy","title":"4. Invariant Enforcement Philosophy","text":"<ul> <li> <p>Invariants are enforced by:</p> </li> <li> <p>Design</p> </li> <li>WAL structure</li> <li>Recovery logic</li> <li>Tests prove enforcement</li> <li>Observability only reports, never enforces</li> </ul>"},{"location":"REPLICATION_PROOFS/","title":"REPLICATION_PROOFS.md","text":""},{"location":"REPLICATION_PROOFS/#aerodb-phase-2-mvcc-correctness-proofs","title":"AeroDB Phase 2 \u2014 MVCC Correctness Proofs","text":""},{"location":"REPLICATION_PROOFS/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It provides argument-based proofs of MVCC correctness</li> <li>Proofs are invariant-driven, not implementation-dependent</li> <li>No algorithms or data structures appear here</li> </ul>"},{"location":"REPLICATION_PROOFS/#1-proof-methodology","title":"1. Proof Methodology","text":"<p>All proofs in this document are based on:</p> <ul> <li>Explicit invariants (Phase-1 + Phase-2)</li> <li>Deterministic WAL semantics</li> <li>Exhaustive failure enumeration</li> <li>Absence of heuristics or timing assumptions</li> </ul> <p>Each proof answers one question:</p> <p>\u201cWhy is this behavior always correct, regardless of execution order or crash timing?\u201d</p>"},{"location":"REPLICATION_PROOFS/#2-proof-of-visibility-correctness","title":"2. Proof of Visibility Correctness","text":""},{"location":"REPLICATION_PROOFS/#claim","title":"Claim","text":"<p>For any read operation, the set of visible versions is correct and deterministic.</p>"},{"location":"REPLICATION_PROOFS/#argument","title":"Argument","text":"<ol> <li> <p>Visibility is defined solely by:</p> </li> <li> <p>Version commit identity</p> </li> <li>Read view upper bound</li> <li> <p>Commit identities are:</p> </li> <li> <p>Totally ordered</p> </li> <li>WAL-governed</li> <li>Deterministically replayed</li> <li>A read view is immutable once established</li> <li> <p>Visibility rule selects:</p> </li> <li> <p>The maximum commit identity \u2264 read upper bound</p> </li> </ol> <p>Therefore:</p> <ul> <li>Visibility does not depend on timing</li> <li>Visibility does not depend on concurrency</li> <li>Visibility does not depend on execution order</li> </ul> <p>Conclusion: Visibility is deterministic and correct by construction.</p>"},{"location":"REPLICATION_PROOFS/#3-proof-of-snapshot-isolation","title":"3. Proof of Snapshot Isolation","text":""},{"location":"REPLICATION_PROOFS/#claim_1","title":"Claim","text":"<p>AeroDB MVCC provides deterministic snapshot isolation.</p>"},{"location":"REPLICATION_PROOFS/#argument_1","title":"Argument","text":"<ol> <li>A read view fixes a commit identity boundary</li> <li>No versions beyond this boundary are visible</li> <li>All reads within an operation use the same boundary</li> <li>Writes only become visible after commit identity durability</li> </ol> <p>Therefore:</p> <ul> <li>No dirty reads are possible</li> <li>No non-repeatable reads are possible</li> <li>No phantom visibility changes are possible</li> </ul> <p>Conclusion: Snapshot isolation is guaranteed without locks or heuristics.</p>"},{"location":"REPLICATION_PROOFS/#4-proof-of-write-atomicity","title":"4. Proof of Write Atomicity","text":""},{"location":"REPLICATION_PROOFS/#claim_2","title":"Claim","text":"<p>Writes are atomically visible or invisible, never partial.</p>"},{"location":"REPLICATION_PROOFS/#argument_2","title":"Argument","text":"<ol> <li>Visibility is tied to commit identity durability</li> <li>Commit identity is WAL-persisted as a single authority</li> <li>Versions without a durable commit identity are invisible</li> <li>Versions with a durable commit identity must be complete or recovery fails</li> </ol> <p>Therefore:</p> <ul> <li>Partial visibility cannot occur</li> <li>Atomicity is enforced at the visibility boundary</li> </ul> <p>Conclusion: Write atomicity is guaranteed across crashes.</p>"},{"location":"REPLICATION_PROOFS/#5-proof-of-recovery-determinism","title":"5. Proof of Recovery Determinism","text":""},{"location":"REPLICATION_PROOFS/#claim_3","title":"Claim","text":"<p>Recovery reconstructs the exact MVCC state deterministically.</p>"},{"location":"REPLICATION_PROOFS/#argument_3","title":"Argument","text":"<ol> <li>WAL is replayed in strict order</li> <li>Commit identities are derived from WAL order</li> <li>Version creation is replayed deterministically</li> <li>GC and snapshot events are WAL-represented</li> </ol> <p>Therefore:</p> <ul> <li>Recovery outcome is uniquely determined by WAL</li> <li>No ambiguity exists after replay</li> </ul> <p>Conclusion: Recovery is deterministic and reproducible.</p>"},{"location":"REPLICATION_PROOFS/#6-proof-of-crash-safety","title":"6. Proof of Crash Safety","text":""},{"location":"REPLICATION_PROOFS/#claim_4","title":"Claim","text":"<p>All crash points resolve to valid MVCC states.</p>"},{"location":"REPLICATION_PROOFS/#argument_4","title":"Argument","text":"<ol> <li>All failure points are enumerated in <code>MVCC_FAILURE_MATRIX.md</code></li> <li> <p>Each crash point maps to:</p> </li> <li> <p>Commit exists fully, or</p> </li> <li>Commit does not exist at all</li> <li>No intermediate visibility state is allowed</li> </ol> <p>Therefore:</p> <ul> <li>Crashes cannot introduce undefined states</li> <li>Corruption is detected, not repaired</li> </ul> <p>Conclusion: Crash safety is complete and explicit.</p>"},{"location":"REPLICATION_PROOFS/#7-proof-of-snapshot-correctness","title":"7. Proof of Snapshot Correctness","text":""},{"location":"REPLICATION_PROOFS/#claim_5","title":"Claim","text":"<p>Snapshots represent valid, self-contained MVCC states.</p>"},{"location":"REPLICATION_PROOFS/#argument_5","title":"Argument","text":"<ol> <li> <p>Snapshots capture:</p> </li> <li> <p>All versions \u2264 snapshot boundary</p> </li> <li>All MVCC metadata</li> <li>WAL replay resumes strictly after snapshot boundary</li> <li>Snapshots impose retention constraints on GC</li> </ol> <p>Therefore:</p> <ul> <li>Snapshots can serve reads independently</li> <li>Snapshots preserve visibility semantics</li> </ul> <p>Conclusion: Snapshots are correct MVCC cuts.</p>"},{"location":"REPLICATION_PROOFS/#8-proof-of-garbage-collection-safety","title":"8. Proof of Garbage Collection Safety","text":""},{"location":"REPLICATION_PROOFS/#claim_6","title":"Claim","text":"<p>GC never removes a version that could be visible.</p>"},{"location":"REPLICATION_PROOFS/#argument_6","title":"Argument","text":"<ol> <li> <p>GC eligibility requires:</p> </li> <li> <p>Version commit identity &lt; visibility lower bound</p> </li> <li>No snapshot retention</li> <li>Recovery safety</li> <li>Visibility lower bound is explicit and deterministic</li> <li>GC actions are WAL-recorded</li> </ol> <p>Therefore:</p> <ul> <li>No visible or potentially visible version is reclaimed</li> <li>GC is replay-safe</li> </ul> <p>Conclusion: GC is safe by proof, not probability.</p>"},{"location":"REPLICATION_PROOFS/#9-proof-of-phase-1-compatibility","title":"9. Proof of Phase-1 Compatibility","text":""},{"location":"REPLICATION_PROOFS/#claim_7","title":"Claim","text":"<p>MVCC does not alter Phase-1 behavior.</p>"},{"location":"REPLICATION_PROOFS/#argument_7","title":"Argument","text":"<ol> <li> <p>Phase-1 behavior is equivalent to:</p> </li> <li> <p>Single-version chains</p> </li> <li>Read views always at latest commit</li> <li>MVCC generalizes, never replaces, Phase-1 semantics</li> <li>All Phase-1 invariants remain unchanged</li> </ol> <p>Therefore:</p> <ul> <li>Identical inputs produce identical outputs</li> <li>Phase-1 tests remain valid</li> </ul> <p>Conclusion: MVCC is a strict superset of Phase-1 behavior.</p>"},{"location":"REPLICATION_PROOFS/#10-proof-of-replication-readiness","title":"10. Proof of Replication Readiness","text":""},{"location":"REPLICATION_PROOFS/#claim_8","title":"Claim","text":"<p>MVCC semantics are replication-safe.</p>"},{"location":"REPLICATION_PROOFS/#argument_8","title":"Argument","text":"<ol> <li> <p>All MVCC state is:</p> </li> <li> <p>WAL-represented</p> </li> <li>Deterministic</li> <li>Commit identities define a total order</li> <li>Visibility rules are stateless beyond WAL</li> </ol> <p>Therefore:</p> <ul> <li>MVCC state can be reconstructed on another node</li> <li>No local-only behavior exists</li> </ul> <p>Conclusion: Replication can consume MVCC without redefining it.</p>"},{"location":"REPLICATION_PROOFS/#11-global-correctness-theorem","title":"11. Global Correctness Theorem","text":""},{"location":"REPLICATION_PROOFS/#statement","title":"Statement","text":"<p>Given the Phase-1 invariants, the Phase-2 MVCC invariants, and the WAL as the sole authority, AeroDB MVCC guarantees:</p> <ul> <li>Deterministic visibility</li> <li>Atomic writes</li> <li>Snapshot isolation</li> <li>Crash-safe recovery</li> <li>Safe garbage collection</li> <li>Phase-1 behavioral equivalence</li> </ul> <p>Under all execution orders and crash scenarios.</p>"},{"location":"REPLICATION_PROOFS/#12-end-of-mvcc-design-phase","title":"12. End of MVCC Design Phase","text":"<p>At this point:</p> <ul> <li>MVCC design is complete</li> <li>All invariants are specified</li> <li>All failure modes are defined</li> <li>No implementation assumptions remain</li> </ul>"},{"location":"REPLICATION_READINESS/","title":"REPLICATION_READINESS.md","text":""},{"location":"REPLICATION_READINESS/#aerodb-phase-2-replication-readiness-checklist","title":"AeroDB \u2014 Phase 2 Replication Readiness Checklist","text":""},{"location":"REPLICATION_READINESS/#status","title":"Status","text":"<ul> <li>This document tracks replication implementation completeness</li> <li>All items must be verified before replication is production-ready</li> <li>Semantic freeze is enforced</li> </ul>"},{"location":"REPLICATION_READINESS/#1-semantic-freeze-declaration","title":"1. Semantic Freeze Declaration","text":"<p>Phase-1 semantics are FROZEN.</p> <p>MVCC semantics are FROZEN.</p> <p>Replication CONSUMES existing correctness. Any deviation is a correctness bug.</p>"},{"location":"REPLICATION_READINESS/#2-core-implementation-status","title":"2. Core Implementation Status","text":""},{"location":"REPLICATION_READINESS/#replication-01-roles-authority","title":"REPLICATION-01: Roles &amp; Authority \u2705","text":"<ul> <li> ReplicationRole (Primary, Replica)</li> <li> ReplicationState state machine</li> <li> HaltReason enumeration</li> <li> Authority enforcement (write admission, commit authority)</li> <li> Dual-primary detection</li> </ul>"},{"location":"REPLICATION_READINESS/#replication-02-wal-shipping","title":"REPLICATION-02: WAL Shipping \u2705","text":"<ul> <li> WalPosition tracking</li> <li> WalSender (Primary-side)</li> <li> WalReceiver (Replica-side)</li> <li> Prefix validation (Replica_WAL == Prefix(Primary_WAL))</li> <li> Gap detection \u2192 ReplicationHalted</li> </ul>"},{"location":"REPLICATION_READINESS/#replication-03-snapshot-transfer","title":"REPLICATION-03: Snapshot Transfer \u2705","text":"<ul> <li> SnapshotMetadata</li> <li> SnapshotReceiver lifecycle</li> <li> Eligibility checks (Primary-only, complete, validated)</li> <li> Atomic installation</li> <li> WAL resume after boundary</li> </ul>"},{"location":"REPLICATION_READINESS/#replication-04-replica-reads","title":"REPLICATION-04: Replica Reads \u2705","text":"<ul> <li> ReadEligibility enum</li> <li> ReplicaReadAdmission</li> <li> Boundary check: R.read_upper_bound \u2264 C_replica</li> <li> Refusal paths (halted, gap, snapshot, recovery)</li> </ul>"},{"location":"REPLICATION_READINESS/#replication-05-failure-matrix","title":"REPLICATION-05: Failure Matrix \u2705","text":"<ul> <li> ReplicationCrashPoint enumeration</li> <li> FailureOutcome mapping</li> <li> FailureState tracking</li> <li> All crash points from FAILURE_MATRIX.md</li> </ul>"},{"location":"REPLICATION_READINESS/#replication-06-recovery","title":"REPLICATION-06: Recovery \u2705","text":"<ul> <li> PrimaryRecovery (WAL/MVCC verification)</li> <li> ReplicaRecovery (prefix/snapshot verification)</li> <li> RecoveryValidation enum</li> <li> Halt on uncertainty</li> </ul>"},{"location":"REPLICATION_READINESS/#replication-07-compatibility","title":"REPLICATION-07: Compatibility \u2705","text":"<ul> <li> Phase1Compatibility assertions</li> <li> MvccCompatibility assertions</li> <li> CompatibilityCheck verification</li> </ul>"},{"location":"REPLICATION_READINESS/#3-test-coverage","title":"3. Test Coverage","text":"Module Tests role 9 authority 8 errors 2 wal_sender 5 wal_receiver 7 snapshot_transfer 8 replica_reads 10 failure_matrix 9 recovery 10 compatibility 6 <p>Total: 74+ replication tests</p>"},{"location":"REPLICATION_READINESS/#4-phase-1-compatibility-guarantees","title":"4. Phase-1 Compatibility Guarantees","text":"<p>Per REPLICATION_COMPATIBILITY.md \u00a72:</p> <ul> <li> WAL remains sole durability authority</li> <li> fsync semantics unchanged</li> <li> WAL replay rules identical</li> <li> Storage invariants intact</li> <li> Query engine unchanged</li> </ul>"},{"location":"REPLICATION_READINESS/#5-mvcc-compatibility-guarantees","title":"5. MVCC Compatibility Guarantees","text":"<p>Per REPLICATION_COMPATIBILITY.md \u00a73:</p> <ul> <li> CommitIds globally ordered</li> <li> CommitIds immutable</li> <li> CommitIds only from Primary</li> <li> Visibility semantics unchanged</li> <li> GC rules unchanged</li> </ul>"},{"location":"REPLICATION_READINESS/#6-invariant-summary","title":"6. Invariant Summary","text":"<p>From REPLICATION_INVARIANTS.md:</p> # Invariant Status 1 Single-Writer \u2705 Enforced 2 Commit Authority \u2705 Enforced 3 Prefix Validity \u2705 Enforced 4 Gap Detection \u2705 Enforced 5 Fail-Stop \u2705 Enforced"},{"location":"REPLICATION_READINESS/#7-readiness-certification","title":"7. Readiness Certification","text":"<ul> <li> All REPLICATION-01 through REPLICATION-07 implemented</li> <li> All tests pass</li> <li> Phase-1 semantics preserved</li> <li> MVCC semantics preserved</li> <li> Fail-stop on uncertainty</li> </ul> <p>Replication adds nodes, not meanings.</p>"},{"location":"REPLICATION_ROADMAP/","title":"REPLICATION_ROADMAP.md","text":""},{"location":"REPLICATION_ROADMAP/#aerodb-phase-2b-replication-roadmap","title":"AeroDB Phase 2B \u2014 Replication Roadmap","text":""},{"location":"REPLICATION_ROADMAP/#status","title":"Status","text":"<ul> <li>This document governs replication design sequencing</li> <li>It defines what must be designed, in what order, and why</li> <li>No implementation is permitted until all design stages are approved</li> <li>Phase-1 and MVCC semantics are frozen and authoritative</li> </ul>"},{"location":"REPLICATION_ROADMAP/#1-replication-entry-conditions-already-satisfied","title":"1. Replication Entry Conditions (Already Satisfied)","text":"<p>Replication work proceeds under the following verified conditions:</p> <ul> <li>Phase-1 is complete, correct, and frozen</li> <li>MVCC (Phase 2A) is complete, correct, and frozen</li> <li>WAL, CommitId, snapshot, and GC semantics are authoritative</li> <li>Crash testing infrastructure exists and is deterministic</li> </ul> <p>Replication is an extension, not a correction.</p>"},{"location":"REPLICATION_ROADMAP/#2-design-first-rule-strict","title":"2. Design-First Rule (Strict)","text":"<p>Replication follows the same rule as MVCC:</p> <p>No code before specs No optimization before correctness No liveness before safety</p> <p>Every document below must be approved before moving forward.</p>"},{"location":"REPLICATION_ROADMAP/#3-replication-design-stages","title":"3. Replication Design Stages","text":""},{"location":"REPLICATION_ROADMAP/#stage-1-replication-model-definition-conceptual","title":"Stage 1 \u2014 Replication Model Definition (Conceptual)","text":"<p>This stage defines what replication is, not how it is implemented.</p>"},{"location":"REPLICATION_ROADMAP/#31-replication_modelmd","title":"3.1 <code>REPLICATION_MODEL.md</code>","text":"<p>Purpose</p> <ul> <li>Define the Primary / Replica roles formally</li> <li>Define authority boundaries</li> <li>Define allowed and forbidden state transitions</li> </ul> <p>Must Answer</p> <ul> <li>What makes a node a Primary?</li> <li>What makes a node a Replica?</li> <li>When must writes be rejected?</li> <li>What states are legal vs illegal?</li> </ul> <p>Exit Criteria</p> <ul> <li>Single-writer invariant is unambiguous</li> <li>No dual-authority state exists</li> <li>No time-based assumptions appear</li> </ul>"},{"location":"REPLICATION_ROADMAP/#stage-2-state-transfer-semantics-design-only","title":"Stage 2 \u2014 State Transfer Semantics (Design Only)","text":"<p>This stage defines how state moves, without code.</p>"},{"location":"REPLICATION_ROADMAP/#32-replication_log_flowmd","title":"3.2 <code>REPLICATION_LOG_FLOW.md</code>","text":"<p>Purpose</p> <ul> <li>Define WAL shipping semantics</li> <li>Define ordering guarantees</li> <li>Define gap detection and handling</li> </ul> <p>Must Answer</p> <ul> <li>Is replication log-based, snapshot-based, or hybrid?</li> <li>How are WAL gaps detected?</li> <li>How is ordering preserved?</li> <li>What happens if records are missing?</li> </ul> <p>Constraints</p> <ul> <li>WAL is the unit of truth</li> <li>CommitId ordering is preserved exactly</li> </ul>"},{"location":"REPLICATION_ROADMAP/#33-replication_snapshot_transfermd","title":"3.3 <code>REPLICATION_SNAPSHOT_TRANSFER.md</code>","text":"<p>Purpose</p> <ul> <li>Define snapshot-based replication bootstrap</li> <li>Define snapshot + WAL catch-up semantics</li> </ul> <p>Must Answer</p> <ul> <li>When is snapshot transfer required?</li> <li>How is snapshot completeness verified?</li> <li>How does a Replica resume WAL replay?</li> </ul> <p>Exit Criteria</p> <ul> <li>Snapshot transfer does not alter semantics</li> <li>WAL replay resumes deterministically</li> </ul>"},{"location":"REPLICATION_ROADMAP/#stage-3-read-semantics-safety","title":"Stage 3 \u2014 Read Semantics &amp; Safety","text":"<p>This stage defines what Replicas are allowed to expose.</p>"},{"location":"REPLICATION_ROADMAP/#34-replication_read_semanticsmd","title":"3.4 <code>REPLICATION_READ_SEMANTICS.md</code>","text":"<p>Purpose</p> <ul> <li>Define whether Replicas may serve reads</li> <li>Define MVCC interaction on Replicas</li> <li>Define read refusal conditions</li> </ul> <p>Must Answer</p> <ul> <li>Can Replicas serve reads?</li> <li>Under what commit boundary?</li> <li>How is staleness defined explicitly?</li> <li>When must reads be refused?</li> </ul> <p>Constraints</p> <ul> <li>No speculative reads</li> <li>No future visibility</li> <li>No weakening of MVCC rules</li> </ul>"},{"location":"REPLICATION_ROADMAP/#stage-4-failure-crash-semantics","title":"Stage 4 \u2014 Failure &amp; Crash Semantics","text":"<p>This stage defines what happens when things go wrong.</p>"},{"location":"REPLICATION_ROADMAP/#35-replication_failure_matrixmd","title":"3.5 <code>REPLICATION_FAILURE_MATRIX.md</code>","text":"<p>Purpose</p> <ul> <li>Enumerate every meaningful replication failure</li> <li>Define explicit outcomes</li> </ul> <p>Must Cover</p> <ul> <li>Primary crash</li> <li>Replica crash</li> <li>Network partition</li> <li>Partial WAL transfer</li> <li>Snapshot transfer interruption</li> <li>WAL corruption during replication</li> </ul> <p>Exit Criteria</p> <ul> <li>Every failure maps to exactly one outcome</li> <li>No \u201cundefined\u201d or \u201cbest-effort\u201d states</li> </ul>"},{"location":"REPLICATION_ROADMAP/#stage-5-recovery-restart-semantics","title":"Stage 5 \u2014 Recovery &amp; Restart Semantics","text":"<p>This stage defines how nodes come back safely.</p>"},{"location":"REPLICATION_ROADMAP/#36-replication_recoverymd","title":"3.6 <code>REPLICATION_RECOVERY.md</code>","text":"<p>Purpose</p> <ul> <li>Define restart behavior for Primary and Replicas</li> <li>Define safety checks before resuming replication</li> </ul> <p>Must Answer</p> <ul> <li>How does a Replica validate its history?</li> <li>How does a Primary reassert authority?</li> <li>When must nodes refuse to start?</li> </ul>"},{"location":"REPLICATION_ROADMAP/#stage-6-compatibility-proof","title":"Stage 6 \u2014 Compatibility &amp; Proof","text":"<p>This stage proves replication does not break AeroDB.</p>"},{"location":"REPLICATION_ROADMAP/#37-replication_compatibilitymd","title":"3.7 <code>REPLICATION_COMPATIBILITY.md</code>","text":"<p>Purpose</p> <ul> <li>Prove Phase-1 + MVCC compatibility</li> <li>Prove snapshot and restore correctness</li> </ul>"},{"location":"REPLICATION_ROADMAP/#38-replication_proofsmd","title":"3.8 <code>REPLICATION_PROOFS.md</code>","text":"<p>Purpose</p> <ul> <li> <p>Argument-based proofs for:</p> </li> <li> <p>No divergence</p> </li> <li>Deterministic replay</li> <li>Safe lag</li> <li>Crash correctness</li> </ul> <p>Replication correctness must be provable without code.</p>"},{"location":"REPLICATION_ROADMAP/#stage-7-implementation-gating","title":"Stage 7 \u2014 Implementation Gating","text":"<p>Only after all design documents are approved:</p>"},{"location":"REPLICATION_ROADMAP/#39-replication_build_promptsmd","title":"3.9 <code>REPLICATION_BUILD_PROMPTS.md</code>","text":"<ul> <li>Step-by-step implementation prompts</li> <li>Crash-gated, spec-linked</li> <li>No heuristic shortcuts</li> </ul>"},{"location":"REPLICATION_ROADMAP/#310-replication_readinessmd","title":"3.10 <code>REPLICATION_READINESS.md</code>","text":"<ul> <li>Readiness checklist</li> <li>Semantic freeze statement</li> <li>Explicit non-features list</li> </ul> <p>After this, replication semantics are frozen.</p>"},{"location":"REPLICATION_ROADMAP/#4-explicit-deferrals","title":"4. Explicit Deferrals","text":"<p>The following are explicitly deferred beyond this roadmap:</p> <ul> <li>Automatic leader election</li> <li>Dynamic membership</li> <li>Quorum writes</li> <li>Read-your-own-writes on Replicas</li> <li>Performance optimizations</li> <li>Geo-replication</li> </ul> <p>If needed, they require a new phase.</p>"},{"location":"REPLICATION_ROADMAP/#5-roadmap-summary","title":"5. Roadmap Summary","text":"<p>Replication design proceeds in this exact order:</p> <ol> <li>Authority model</li> <li>WAL &amp; snapshot flow</li> <li>Read semantics</li> <li>Failure matrix</li> <li>Recovery rules</li> <li>Compatibility &amp; proofs</li> <li>Build prompts</li> <li>Semantic freeze</li> </ol> <p>Skipping any step is a correctness violation.</p>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/","title":"REPLICATION RUNTIME ARCHITECTURE","text":""},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#status","title":"Status","text":"<ul> <li>Phase: 5</li> <li>Authority: Normative</li> <li>Scope: Runtime structure of replication implementation</li> <li>Depends on:</li> <li><code>OBSERVABILITY_VISION.md</code></li> <li><code>OBSERVABILITY_INVARIANTS.md</code></li> <li><code>OBSERVABILITY_IMPLEMENTATION_ORDER.md</code></li> <li><code>REPL_*</code> specifications</li> <li><code>MVCC_*</code> specifications</li> <li><code>CORE_*</code> specifications</li> </ul> <p>This document defines the only permitted runtime architecture for AeroDB replication in Phase 5.</p> <p>If implementation deviates from this architecture, correctness proofs no longer apply.</p>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#1-purpose","title":"1. Purpose","text":"<p>Replication correctness depends as much on runtime structure as on logic.</p> <p>This document: - Prevents hidden authority - Prevents accidental concurrency - Makes failure boundaries explicit - Ensures explainability of replication behavior</p> <p>This is an architecture document, not a behavior redesign.</p>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#2-architectural-principles","title":"2. Architectural Principles","text":""},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#a-1-single-authority-per-responsibility","title":"A-1: Single Authority Per Responsibility","text":"<p>Each replication responsibility MUST have: - Exactly one owner - Exactly one mutation path - Explicit read-only consumers</p> <p>Shared mutable ownership is forbidden.</p>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#a-2-explicit-state-machines","title":"A-2: Explicit State Machines","text":"<p>All replication components MUST: - Be driven by explicit state machines - Enumerate all states - Validate transitions</p> <p>Implicit or boolean-driven states are forbidden.</p>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#a-3-deterministic-concurrency","title":"A-3: Deterministic Concurrency","text":"<p>Concurrency is permitted ONLY when: - Responsibilities are disjoint - Ordering is explicit - State transitions are serialized</p> <p>Timing-based coordination is forbidden.</p>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#3-high-level-runtime-components","title":"3. High-Level Runtime Components","text":"<p>Replication runtime consists of five components. They communicate via explicit channels and immutable messages.</p> <pre><code>+------------------+\n| Primary Runtime  |\n+------------------+\n|\n| WAL Segments (immutable)\nv\n+------------------+       +------------------+\n| WAL Receiver     | ----&gt; | WAL Validator    |\n+------------------+       +------------------+\n|\nv\n+------------------+\n| WAL Applier      |\n+------------------+\n|\nv\n+------------------+\n| Replica State    |\n+------------------+\n|\nv\n+------------------+\n| Read Safety Gate |\n+------------------+\n\n````\n\n---\n\n## 4. Primary-Side Architecture (Minimal)\n\n### 4.1 Primary Responsibilities\n\nThe Primary:\n- Assigns CommitIds\n- Appends WAL\n- Exposes WAL segments for shipping\n\nPrimary replication logic MUST be:\n- Read-only with respect to replication\n- Passive (no push, only serve)\n\nThere are **no replication threads on the Primary**.\n\n---\n\n## 5. Replica-Side Architecture (Authoritative)\n\nAll replication runtime complexity lives on the **Replica**.\n\n---\n\n### 5.1 Replica Supervisor\n\n**Role:** Top-level state owner\n\nResponsibilities:\n- Replica lifecycle\n- Crash recovery orchestration\n- State transitions between stages\n\nProperties:\n- Single-threaded\n- Owns replica global state enum\n- Exposes state to DX\n\nForbidden:\n- Performing WAL IO directly\n- Applying WAL\n- Serving reads\n\n---\n\n### 5.2 WAL Receiver\n\n**Role:** WAL ingress only\n\nResponsibilities:\n- Receive WAL segments\n- Enforce ordering\n- Persist raw WAL bytes\n\nProperties:\n- Single-threaded or async task\n- No validation\n- No state mutation beyond WAL storage\n\nInput:\n- Primary WAL stream\n\nOutput:\n- Immutable WAL segments\n\nForbidden:\n- Applying WAL\n- Advancing CommitId\n- Skipping segments\n\n---\n\n### 5.3 WAL Validator\n\n**Role:** WAL correctness proof\n\nResponsibilities:\n- Check checksums\n- Verify continuity\n- Validate segment boundaries\n\nProperties:\n- Deterministic\n- Stateless across runs (except checkpoints)\n- Restart-safe\n\nInput:\n- WAL segments from Receiver\n\nOutput:\n- Validated WAL segments OR explicit failure\n\nForbidden:\n- Mutating storage\n- Advancing CommitId\n\n---\n\n### 5.4 WAL Applier\n\n**Role:** State mutation engine\n\nResponsibilities:\n- Apply validated WAL to storage\n- Advance replica CommitId\n- Maintain replay checkpoints\n\nProperties:\n- Single-threaded\n- Crash-safe\n- Deterministic\n\nInput:\n- Validated WAL segments\n\nOutput:\n- Updated replica storage\n\nForbidden:\n- Serving reads\n- Skipping validation\n- Applying speculative WAL\n\n---\n\n### 5.5 Replica State Store\n\n**Role:** Canonical replica metadata\n\nResponsibilities:\n- Store:\n  - Replica CommitId\n  - Applied WAL offset\n  - Snapshot bootstrap metadata\n- Persist restart-safe state\n\nProperties:\n- Mutated only by:\n  - Replica Supervisor\n  - WAL Applier (scoped)\n\nForbidden:\n- Concurrent mutation\n- Hidden derived state\n\n---\n\n### 5.6 Read Safety Gate\n\n**Role:** Read authorization\n\nResponsibilities:\n- Evaluate read safety predicates\n- Enforce MVCC visibility rules\n- Refuse unsafe reads\n\nProperties:\n- Read-only\n- Pure function of observable state\n- Explainable via DX\n\nForbidden:\n- Heuristics\n- Timing assumptions\n- Lag-based shortcuts\n\n---\n\n## 6. State Machines (Mandatory)\n\n### 6.1 Replica Global State\n\n```text\nDisabled\n  \u2193\nInitializing\n  \u2193\nReceivingWAL\n  \u2193\nValidatingWAL\n  \u2193\nApplyingWAL\n  \u2193\nRecovering\n  \u2193\nReady (read-safe OR read-blocked)\n````\n\nTransitions MUST:\n\n* Be explicit\n* Be logged\n* Be observable\n\n---\n\n### 6.2 WAL Segment State\n\n```text\nReceived \u2192 Validated \u2192 Applied\n</code></pre> <p>No skipping allowed. No rollback allowed except via crash recovery.</p>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#7-concurrency-model","title":"7. Concurrency Model","text":""},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#allowed-concurrency","title":"Allowed Concurrency","text":"<ul> <li>WAL Receiver may run concurrently with Validator</li> <li>Validator may run concurrently with Applier ONLY via queueing</li> <li>Read Safety Gate runs concurrently but is read-only</li> </ul>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#forbidden-concurrency","title":"Forbidden Concurrency","text":"<ul> <li>Multiple Appliers</li> <li>Receiver applying WAL</li> <li>Validator mutating storage</li> <li>Read path mutating replica state</li> </ul>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#8-failure-boundaries","title":"8. Failure Boundaries","text":"<p>Each component MUST fail independently and explicitly.</p> Component Failure Effect Receiver Stops replication Validator Blocks application Applier Triggers recovery Supervisor Replica unavailable Read Gate Refuses reads <p>No cascading silent failure is allowed.</p>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#9-observability-requirements","title":"9. Observability Requirements","text":"<p>Each component MUST expose:</p> <ul> <li>Current state</li> <li>Blocking reason</li> <li>Last successful transition</li> </ul> <p>DX APIs MUST surface:</p> <ul> <li>Replica global state</li> <li>WAL offsets</li> <li>CommitIds</li> <li>Read safety status</li> </ul>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#10-explainability-requirements","title":"10. Explainability Requirements","text":"<p>For any replica state, the system MUST be able to explain:</p> <ul> <li>Why replication is blocked</li> <li>Why a read is allowed or denied</li> <li>Why a WAL segment is rejected</li> </ul> <p>Explanations MUST reference:</p> <ul> <li>State machine states</li> <li>WAL offsets</li> <li>CommitIds</li> </ul>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#11-forbidden-architecture-patterns","title":"11. Forbidden Architecture Patterns","text":"<p>Explicitly forbidden:</p> <ul> <li>Background \u201cbest effort\u201d threads</li> <li>Shared mutable state across components</li> <li>Lock-based correctness without state checks</li> <li>Implicit progress via retries</li> <li>Timing-based coordination</li> </ul> <p>If any of these appear, the implementation is invalid.</p>"},{"location":"REPLICATION_RUNTIME_ARCHITECTURE/#12-final-rule","title":"12. Final Rule","text":"<p>Replication correctness lives in structure, not in clever code.</p> <p>If runtime ownership is clear, correctness follows.</p> <p>END OF DOCUMENT</p>"},{"location":"REPLICATION_VISION/","title":"REPLICATION_VISION.md","text":""},{"location":"REPLICATION_VISION/#aerodb-phase-2-vision","title":"AeroDB Phase 2 \u2014 Vision","text":""},{"location":"REPLICATION_VISION/#status","title":"Status","text":"<ul> <li>Phase-1 is complete, correct, tested, and frozen</li> <li>Phase-2 builds on top of Phase-1 without modifying or weakening it</li> <li>This document defines intent and boundaries only</li> <li>No implementation details appear here</li> </ul>"},{"location":"REPLICATION_VISION/#purpose-of-phase-2","title":"Purpose of Phase 2","text":"<p>Phase 2 extends AeroDB from a single-version, single-timeline database into a system capable of:</p> <ul> <li>Concurrent readers and writers</li> <li>Stable, repeatable read views</li> <li>Deterministic historical visibility</li> <li>Strictly defined isolation guarantees</li> </ul> <p>This is achieved through Multi-Version Concurrency Control (MVCC), designed to coexist with AeroDB\u2019s Phase-1 durability, recovery, and determinism guarantees.</p> <p>MVCC in AeroDB exists to make correctness scalable, not to chase throughput at the expense of safety.</p>"},{"location":"REPLICATION_VISION/#non-negotiable-continuity-from-phase-1","title":"Non-Negotiable Continuity from Phase 1","text":"<p>All Phase-1 guarantees remain fully intact and unchanged.</p>"},{"location":"REPLICATION_VISION/#the-following-are-explicitly-preserved","title":"The following are explicitly preserved:","text":"<ul> <li> <p>Durability</p> </li> <li> <p>No acknowledged write is ever lost</p> </li> <li>fsync semantics remain authoritative</li> <li> <p>Deterministic Recovery</p> </li> <li> <p>WAL replay produces identical state</p> </li> <li>MVCC metadata must replay deterministically</li> <li> <p>Corruption Detection</p> </li> <li> <p>Checksums remain mandatory</p> </li> <li>No silent repair, no best-effort recovery</li> <li> <p>Bounded Queries</p> </li> <li> <p>MVCC does not introduce unbounded scans</p> </li> <li> <p>Crash Safety</p> </li> <li> <p>Every MVCC state transition must be crash-recoverable</p> </li> <li> <p>Observability Neutrality</p> </li> <li> <p>Metrics and logs never influence MVCC behavior</p> </li> </ul> <p>MVCC is an extension, never a reinterpretation, of Phase-1 correctness.</p>"},{"location":"REPLICATION_VISION/#what-mvcc-means-in-aerodb","title":"What MVCC Means in AeroDB","text":"<p>In AeroDB, MVCC is:</p> <ul> <li>Explicit \u2014 visibility rules are defined in specs, not inferred</li> <li>Deterministic \u2014 no timing-based or scheduler-dependent behavior</li> <li>Versioned \u2014 documents have well-defined historical versions</li> <li>Auditable \u2014 visibility decisions can be reasoned about post-hoc</li> <li>Recoverable \u2014 all MVCC state is WAL-governed</li> </ul> <p>MVCC is not a performance hack or a concurrency band-aid. It is a correctness model for time, visibility, and isolation.</p>"},{"location":"REPLICATION_VISION/#what-mvcc-is-not","title":"What MVCC Is Not","text":"<p>AeroDB MVCC will not:</p> <ul> <li>Introduce \u201ceventual\u201d visibility without formal definition</li> <li>Depend on wall-clock time for correctness</li> <li>Allow ambiguous isolation levels</li> <li>Hide conflicts or auto-resolve inconsistencies</li> <li>Bypass WAL, snapshot, or checkpoint guarantees</li> <li>Assume optimistic success paths</li> </ul> <p>If a behavior cannot be precisely specified, it does not exist.</p>"},{"location":"REPLICATION_VISION/#high-level-mvcc-goals","title":"High-Level MVCC Goals","text":"<p>Phase-2 MVCC must provide:</p> <ol> <li> <p>Stable Read Views</p> </li> <li> <p>Readers observe a consistent snapshot</p> </li> <li> <p>Reads are not affected by concurrent writes</p> </li> <li> <p>Well-Defined Write Semantics</p> </li> <li> <p>Writers create new versions, never mutate history</p> </li> <li> <p>Conflicts are explicit and deterministic</p> </li> <li> <p>Snapshot Visibility</p> </li> <li> <p>MVCC integrates with existing snapshot and checkpoint mechanisms</p> </li> <li> <p>Snapshot semantics remain predictable and fsync-safe</p> </li> <li> <p>Deterministic Garbage Collection</p> </li> <li> <p>Old versions are reclaimed only when provably unreachable</p> </li> <li> <p>GC is correctness-driven, not heuristic-driven</p> </li> <li> <p>Replication-Ready Semantics</p> </li> <li> <p>MVCC state can be replicated deterministically in later Phase-2 work</p> </li> <li>No local-only shortcuts</li> </ol>"},{"location":"REPLICATION_VISION/#explicit-deferrals","title":"Explicit Deferrals","text":"<p>This document intentionally does not define:</p> <ul> <li>Isolation levels (defined later)</li> <li>Version storage layout</li> <li>Transaction APIs</li> <li>Locking or lock-free strategies</li> <li>Performance optimizations</li> <li>Garbage collection algorithms</li> </ul> <p>Those belong in subsequent Phase-2 documents, governed by this vision.</p>"},{"location":"REPLICATION_VISION/#phase-2-design-ethos","title":"Phase-2 Design Ethos","text":"<p>Correctness first. Determinism second. Explicitness always. Performance only when proven safe.</p> <p>MVCC in AeroDB is not about being fast first \u2014 it is about being right forever.</p>"},{"location":"REPL_COMPATIBILITY/","title":"REPLICATION_COMPATIBILITY.md","text":""},{"location":"REPL_COMPATIBILITY/#aerodb-replication-compatibility-invariant-preservation","title":"AeroDB \u2014 Replication Compatibility &amp; Invariant Preservation","text":""},{"location":"REPL_COMPATIBILITY/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It proves replication does not alter existing semantics</li> <li>All compatibility guarantees are non-negotiable</li> <li>No implementation details appear here</li> <li>Phase-1 and MVCC semantics are frozen and preserved</li> </ul>"},{"location":"REPL_COMPATIBILITY/#1-purpose-of-compatibility-guarantees","title":"1. Purpose of Compatibility Guarantees","text":"<p>Replication must integrate with AeroDB such that:</p> <ul> <li>All existing guarantees remain true</li> <li>No subsystem requires reinterpretation</li> <li>No \u201creplication-only\u201d semantics exist</li> </ul> <p>If replication changes meaning, it is incorrect.</p>"},{"location":"REPL_COMPATIBILITY/#2-phase-1-compatibility-unchanged","title":"2. Phase-1 Compatibility (Unchanged)","text":"<p>Replication must preserve all Phase-1 guarantees exactly.</p>"},{"location":"REPL_COMPATIBILITY/#21-wal-semantics","title":"2.1 WAL Semantics","text":"<ul> <li>WAL remains the sole durability authority</li> <li>fsync semantics are unchanged</li> <li>WAL replay rules are identical</li> <li>Replication does not introduce WAL shortcuts</li> </ul> <p>A non-replicated node and a Primary must behave identically.</p>"},{"location":"REPL_COMPATIBILITY/#22-storage-semantics","title":"2.2 Storage Semantics","text":"<ul> <li>Append-only storage invariants remain intact</li> <li>Checksums remain mandatory</li> <li>Tombstone semantics are unchanged</li> <li>Corruption is detected and halts execution</li> </ul> <p>Replication must not introduce silent repair paths.</p>"},{"location":"REPL_COMPATIBILITY/#23-query-engine-semantics","title":"2.3 Query Engine Semantics","text":"<ul> <li>Parsing, planning, and execution are unchanged</li> <li>Determinism and boundedness are preserved</li> <li>Query results are identical for identical read views</li> </ul> <p>Replication influences where reads occur, not what they return.</p>"},{"location":"REPL_COMPATIBILITY/#3-mvcc-compatibility-unchanged","title":"3. MVCC Compatibility (Unchanged)","text":"<p>Replication must preserve all MVCC invariants.</p>"},{"location":"REPL_COMPATIBILITY/#31-commitid-semantics","title":"3.1 CommitId Semantics","text":"<ul> <li>CommitIds are globally ordered</li> <li>CommitIds are immutable</li> <li>CommitIds originate only from the Primary</li> <li>Replicas must not infer or modify CommitIds</li> </ul> <p>CommitId meaning is identical on all nodes.</p>"},{"location":"REPL_COMPATIBILITY/#32-visibility-semantics","title":"3.2 Visibility Semantics","text":"<ul> <li>Snapshot isolation rules are unchanged</li> <li>Read view construction rules are unchanged</li> <li>Visibility resolution is identical on Primary and Replica</li> </ul> <p>Replication must not weaken isolation.</p>"},{"location":"REPL_COMPATIBILITY/#33-garbage-collection-semantics","title":"3.3 Garbage Collection Semantics","text":"<ul> <li>GC eligibility rules remain unchanged</li> <li>Snapshots impose identical retention constraints</li> <li>WAL-recorded GC events are replayed identically</li> </ul> <p>Replication must not introduce \u201clocal-only GC\u201d.</p>"},{"location":"REPL_COMPATIBILITY/#4-snapshot-compatibility","title":"4. Snapshot Compatibility","text":"<p>Replication must preserve snapshot semantics:</p> <ul> <li>Snapshots represent valid MVCC cuts</li> <li>Snapshot commit boundaries are authoritative</li> <li>Snapshot restore behavior is identical</li> <li>Snapshot format and validation rules are unchanged</li> </ul> <p>Snapshot transfer does not reinterpret snapshots.</p>"},{"location":"REPL_COMPATIBILITY/#5-backup-restore-compatibility","title":"5. Backup &amp; Restore Compatibility","text":"<p>Replication must not alter:</p> <ul> <li>Backup determinism</li> <li>Restore atomicity</li> <li>Restore validation rules</li> </ul> <p>Backups taken on a Primary or Replica must be:</p> <ul> <li>Semantically equivalent</li> <li>Restore-identical</li> </ul> <p>Replication does not create a new backup class.</p>"},{"location":"REPL_COMPATIBILITY/#6-observability-compatibility","title":"6. Observability Compatibility","text":"<ul> <li>Logging remains side-effect free</li> <li>Metrics remain observational only</li> <li>Replication state may be observed</li> <li>Replication state must not influence behavior</li> </ul> <p>Observability must not affect correctness.</p>"},{"location":"REPL_COMPATIBILITY/#7-configuration-compatibility","title":"7. Configuration Compatibility","text":"<ul> <li>Replication configuration must be explicit</li> <li>No implicit defaults</li> <li>No adaptive role changes</li> </ul> <p>Misconfiguration must result in refusal, not guesswork.</p>"},{"location":"REPL_COMPATIBILITY/#8-crash-testing-compatibility","title":"8. Crash Testing Compatibility","text":"<p>Replication must integrate with:</p> <ul> <li>Existing crash harness</li> <li>Deterministic kill points</li> <li>Phase-1 and MVCC crash matrices</li> </ul> <p>Replication crashes must produce outcomes consistent with:</p> <ul> <li>Phase-1 crash semantics</li> <li>MVCC crash semantics</li> <li>Replication failure matrix</li> </ul>"},{"location":"REPL_COMPATIBILITY/#9-explicitly-forbidden-compatibility-breaks","title":"9. Explicitly Forbidden Compatibility Breaks","text":"<p>Replication must never:</p> <ul> <li>Change Phase-1 observable behavior</li> <li>Change MVCC semantics</li> <li>Introduce new durability meanings</li> <li>Introduce timing-based behavior</li> <li>Introduce best-effort fallbacks</li> </ul> <p>Any such change is a correctness violation.</p>"},{"location":"REPL_COMPATIBILITY/#10-compatibility-summary","title":"10. Compatibility Summary","text":"<p>Replication compatibility guarantees:</p> <ul> <li>Phase-1 remains authoritative</li> <li>MVCC remains frozen</li> <li>All semantics are preserved</li> <li>Replication is a transparent extension</li> </ul> <p>Replication adds nodes, not meanings.</p>"},{"location":"REPL_FAILURE_MATRIX/","title":"REPLICATION_FAILURE_MATRIX.md","text":""},{"location":"REPL_FAILURE_MATRIX/#aerodb-replication-failure-partition-matrix","title":"AeroDB \u2014 Replication Failure &amp; Partition Matrix","text":""},{"location":"REPL_FAILURE_MATRIX/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It enumerates every meaningful replication failure</li> <li>Every failure maps to exactly one correct outcome</li> <li>No implementation details appear here</li> <li>Phase-1 and MVCC semantics are frozen and preserved</li> </ul>"},{"location":"REPL_FAILURE_MATRIX/#1-purpose-of-the-failure-matrix","title":"1. Purpose of the Failure Matrix","text":"<p>Replication correctness depends on one rule:</p> <p>There must be no ambiguous outcomes under failure.</p> <p>This document defines:</p> <ul> <li>What can fail</li> <li>When it can fail</li> <li>What state may exist at failure time</li> <li>What recovery outcome is allowed</li> </ul> <p>If a failure is not described here, it is illegal.</p>"},{"location":"REPL_FAILURE_MATRIX/#2-failure-dimensions","title":"2. Failure Dimensions","text":"<p>Replication failures are classified along four axes:</p> <ol> <li>Node failure (Primary or Replica crash)</li> <li>Network failure (partition, delay, duplication)</li> <li>State transfer failure (WAL or snapshot)</li> <li>Corruption failure (data integrity)</li> </ol> <p>Each failure is analyzed independently and in combination.</p>"},{"location":"REPL_FAILURE_MATRIX/#3-primary-side-failures","title":"3. Primary-Side Failures","text":""},{"location":"REPL_FAILURE_MATRIX/#31-primary-crash-before-wal-commit","title":"3.1 Primary Crash Before WAL Commit","text":"<p>Failure Point</p> <ul> <li>Crash before WAL fsync of a commit</li> </ul> <p>State at Failure</p> <ul> <li>No durable commit</li> <li>No authoritative history extension</li> </ul> <p>Required Outcome</p> <ul> <li>Commit does not exist</li> <li>Replicas never observe it</li> <li>Recovery is identical to Phase-1 behavior</li> </ul>"},{"location":"REPL_FAILURE_MATRIX/#32-primary-crash-after-wal-commit-before-replication","title":"3.2 Primary Crash After WAL Commit, Before Replication","text":"<p>Failure Point</p> <ul> <li>Commit durable on Primary</li> <li>WAL not yet shipped to Replicas</li> </ul> <p>State at Failure</p> <ul> <li>Commit exists only on Primary</li> </ul> <p>Required Outcome</p> <ul> <li>Commit is durable</li> <li>Replicas will receive it after Primary recovery</li> <li>No Replica may invent or infer it</li> </ul> <p>Durability is not weakened by replication.</p>"},{"location":"REPL_FAILURE_MATRIX/#33-primary-crash-during-wal-shipping","title":"3.3 Primary Crash During WAL Shipping","text":"<p>Failure Point</p> <ul> <li>WAL partially transferred</li> </ul> <p>State at Failure</p> <ul> <li> <p>Replica may have:</p> </li> <li> <p>Some records</p> </li> <li>Or none</li> </ul> <p>Required Outcome</p> <ul> <li>Replica detects incomplete transfer</li> <li>Replica halts replication</li> <li>WAL transfer resumes explicitly</li> </ul> <p>Partial history must not be applied silently.</p>"},{"location":"REPL_FAILURE_MATRIX/#4-replica-side-failures","title":"4. Replica-Side Failures","text":""},{"location":"REPL_FAILURE_MATRIX/#41-replica-crash-before-wal-append","title":"4.1 Replica Crash Before WAL Append","text":"<p>Failure Point</p> <ul> <li>Crash before WAL record durability</li> </ul> <p>State at Failure</p> <ul> <li>Record not durable</li> </ul> <p>Required Outcome</p> <ul> <li>Record is lost on Replica</li> <li>Retransmission required</li> <li>No inconsistency introduced</li> </ul>"},{"location":"REPL_FAILURE_MATRIX/#42-replica-crash-after-wal-append","title":"4.2 Replica Crash After WAL Append","text":"<p>Failure Point</p> <ul> <li>WAL record durably appended</li> <li>Replay incomplete</li> </ul> <p>State at Failure</p> <ul> <li>WAL is authoritative</li> </ul> <p>Required Outcome</p> <ul> <li>Recovery replays WAL deterministically</li> <li>Replica state advances correctly</li> </ul>"},{"location":"REPL_FAILURE_MATRIX/#43-replica-crash-during-snapshot-installation","title":"4.3 Replica Crash During Snapshot Installation","text":"<p>Failure Point</p> <ul> <li>Snapshot partially applied</li> </ul> <p>State at Failure</p> <ul> <li>Incomplete snapshot</li> </ul> <p>Required Outcome</p> <ul> <li>Snapshot is discarded</li> <li>Replica remains in prior valid state</li> <li>No partial state survives</li> </ul>"},{"location":"REPL_FAILURE_MATRIX/#5-network-failures","title":"5. Network Failures","text":""},{"location":"REPL_FAILURE_MATRIX/#51-network-partition-primary-replica","title":"5.1 Network Partition (Primary \u2194 Replica)","text":"<p>Failure Point</p> <ul> <li>WAL transfer interrupted</li> </ul> <p>State at Failure</p> <ul> <li>Replica lags</li> </ul> <p>Required Outcome</p> <ul> <li>Replica stops applying WAL</li> <li>Reads may continue only if safe</li> <li>Writes remain Primary-only</li> </ul> <p>No speculative catch-up is allowed.</p>"},{"location":"REPL_FAILURE_MATRIX/#52-message-duplication-or-reordering","title":"5.2 Message Duplication or Reordering","text":"<p>Failure Point</p> <ul> <li>WAL records duplicated or reordered in transit</li> </ul> <p>State at Failure</p> <ul> <li>Replica detects mismatch</li> </ul> <p>Required Outcome</p> <ul> <li>Replica rejects invalid order</li> <li>Replication halts explicitly</li> </ul> <p>Transport unreliability must not affect correctness.</p>"},{"location":"REPL_FAILURE_MATRIX/#6-wal-integrity-failures","title":"6. WAL Integrity Failures","text":""},{"location":"REPL_FAILURE_MATRIX/#61-corrupted-wal-record-in-transit","title":"6.1 Corrupted WAL Record in Transit","text":"<p>Failure Point</p> <ul> <li>Checksum mismatch</li> </ul> <p>State at Failure</p> <ul> <li>Record unreadable</li> </ul> <p>Required Outcome</p> <ul> <li>Replica rejects record</li> <li>Replication halts</li> <li>Operator intervention required</li> </ul> <p>No repair attempts are allowed.</p>"},{"location":"REPL_FAILURE_MATRIX/#62-missing-wal-record-gap","title":"6.2 Missing WAL Record (Gap)","text":"<p>Failure Point</p> <ul> <li>WAL sequence discontinuity</li> </ul> <p>State at Failure</p> <ul> <li>History incomplete</li> </ul> <p>Required Outcome</p> <ul> <li>Replica halts</li> <li>Enters <code>ReplicationHalted</code></li> <li>No reads or writes allowed</li> </ul>"},{"location":"REPL_FAILURE_MATRIX/#7-snapshot-related-failures","title":"7. Snapshot-Related Failures","text":""},{"location":"REPL_FAILURE_MATRIX/#71-invalid-snapshot-transfer","title":"7.1 Invalid Snapshot Transfer","text":"<p>Failure Point</p> <ul> <li>Snapshot integrity check fails</li> </ul> <p>Required Outcome</p> <ul> <li>Snapshot rejected</li> <li>Replica remains unchanged</li> <li>Replication must restart</li> </ul>"},{"location":"REPL_FAILURE_MATRIX/#72-snapshot-boundary-mismatch","title":"7.2 Snapshot Boundary Mismatch","text":"<p>Failure Point</p> <ul> <li>Snapshot boundary conflicts with WAL history</li> </ul> <p>Required Outcome</p> <ul> <li>Fatal error</li> <li>Replica must not continue</li> </ul>"},{"location":"REPL_FAILURE_MATRIX/#8-divergence-detection","title":"8. Divergence Detection","text":""},{"location":"REPL_FAILURE_MATRIX/#81-replica-history-diverges-from-primary","title":"8.1 Replica History Diverges from Primary","text":"<p>Failure Point</p> <ul> <li>Replica WAL is not a prefix of Primary WAL</li> </ul> <p>Required Outcome</p> <ul> <li>Fatal correctness violation</li> <li>Replication halts</li> <li>Manual intervention required</li> </ul> <p>Divergence must never be auto-healed.</p>"},{"location":"REPL_FAILURE_MATRIX/#9-combined-failures","title":"9. Combined Failures","text":""},{"location":"REPL_FAILURE_MATRIX/#91-crash-network-partition","title":"9.1 Crash + Network Partition","text":"<p>Failure Point</p> <ul> <li>Replica crashes while partitioned</li> </ul> <p>Required Outcome</p> <ul> <li>Replica recovers locally</li> <li>Remains behind</li> <li>Resumes replication explicitly</li> </ul>"},{"location":"REPL_FAILURE_MATRIX/#92-crash-during-recovery","title":"9.2 Crash During Recovery","text":"<p>Failure Point</p> <ul> <li>Crash during recovery or replay</li> </ul> <p>Required Outcome</p> <ul> <li>Recovery restarts</li> <li>Deterministic outcome preserved</li> </ul>"},{"location":"REPL_FAILURE_MATRIX/#10-forbidden-recovery-outcomes","title":"10. Forbidden Recovery Outcomes","text":"<p>Recovery must never result in:</p> <ul> <li>Partial commits becoming visible</li> <li>Reordered commits</li> <li>Healed divergence</li> <li>Implicit authority assumption</li> <li>Mixed snapshot + WAL states</li> </ul> <p>Any such state is a fatal error.</p>"},{"location":"REPL_FAILURE_MATRIX/#11-determinism-guarantee","title":"11. Determinism Guarantee","text":"<p>For any failure scenario:</p> <ul> <li>Outcome is uniquely determined</li> <li>No heuristics are involved</li> <li>No timing assumptions are made</li> </ul> <p>Replication failure handling is purely state-driven.</p>"},{"location":"REPL_FAILURE_MATRIX/#12-failure-matrix-summary","title":"12. Failure Matrix Summary","text":"<p>Replication failure handling guarantees:</p> <ul> <li>No data loss</li> <li>No silent divergence</li> <li>No speculative recovery</li> <li>Explicit halting on uncertainty</li> </ul> <p>If replication cannot be proven correct, it must stop.</p>"},{"location":"REPL_INVARIANTS/","title":"REPLICATION_INVARIANTS.md","text":""},{"location":"REPL_INVARIANTS/#aerodb-phase-2b-replication-invariants","title":"AeroDB Phase 2B \u2014 Replication Invariants","text":""},{"location":"REPL_INVARIANTS/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>All invariants herein are non-negotiable</li> <li>Phase-1 and MVCC invariants remain fully in force</li> <li>Any behavior violating an invariant is a fatal correctness bug</li> <li>No implementation details appear here</li> </ul>"},{"location":"REPL_INVARIANTS/#1-invariants-preserved-from-earlier-phases-unchanged","title":"1. Invariants Preserved from Earlier Phases (Unchanged)","text":"<p>Replication must not weaken, reinterpret, or bypass any existing invariant.</p>"},{"location":"REPL_INVARIANTS/#11-phase-1-durability-invariants-unchanged","title":"1.1 Phase-1 Durability Invariants (UNCHANGED)","text":"<ul> <li>A write acknowledged by the system is never lost</li> <li>WAL fsync semantics remain the definition of durability</li> <li>No background, deferred, or \u201ceventual\u201d durability is permitted</li> <li>Replication does not redefine what \u201cdurable\u201d means</li> </ul> <p>If replication is disabled, behavior must be identical to Phase-1.</p>"},{"location":"REPL_INVARIANTS/#12-phase-1-recovery-invariants-unchanged","title":"1.2 Phase-1 Recovery Invariants (UNCHANGED)","text":"<ul> <li>Recovery is deterministic</li> <li>WAL replay produces exactly one valid state</li> <li>Corruption is detected and halts recovery</li> <li>No state is guessed, skipped, or healed</li> </ul> <p>Replication must not introduce recovery ambiguity.</p>"},{"location":"REPL_INVARIANTS/#13-mvcc-invariants-unchanged","title":"1.3 MVCC Invariants (UNCHANGED)","text":"<p>Replication must preserve all MVCC guarantees:</p> <ul> <li>CommitId total order is authoritative</li> <li>CommitIds are immutable and WAL-derived</li> <li>Visibility is snapshot-based and deterministic</li> <li>Version immutability is absolute</li> <li>GC is proof-based and WAL-governed</li> <li>MVCC semantics are frozen</li> </ul> <p>Replication consumes MVCC \u2014 it does not reinterpret it.</p>"},{"location":"REPL_INVARIANTS/#2-core-replication-invariants-new","title":"2. Core Replication Invariants (NEW)","text":"<p>These invariants define what replication is allowed to be.</p>"},{"location":"REPL_INVARIANTS/#21-single-writer-invariant","title":"2.1 Single-Writer Invariant","text":"<p>At any moment in time:</p> <ul> <li>Exactly one node may acknowledge writes</li> <li>That node is called the Primary</li> <li>All other nodes are Replicas</li> </ul> <p>No two nodes may acknowledge writes concurrently.</p> <p>If authority is unclear \u2192 writes must be rejected.</p>"},{"location":"REPL_INVARIANTS/#22-commit-authority-invariant","title":"2.2 Commit Authority Invariant","text":"<ul> <li>CommitIds are assigned only by the Primary</li> <li> <p>Replicas must never:</p> </li> <li> <p>Generate CommitIds</p> </li> <li>Renumber CommitIds</li> <li>Compress CommitIds</li> <li>Infer CommitIds</li> </ul> <p>If a Replica observes a CommitId not issued by the Primary \u2192 fatal error.</p>"},{"location":"REPL_INVARIANTS/#23-history-prefix-invariant","title":"2.3 History Prefix Invariant","text":"<p>For any Replica <code>R</code> and Primary <code>P</code>:</p> <pre><code>History(R) \u2286 Prefix(History(P))\n</code></pre> <p>Meaning:</p> <ul> <li>A Replica\u2019s WAL history must be a prefix of the Primary\u2019s history</li> <li>Replicas must never diverge, fork, or reorder history</li> <li>Replicas may lag, but never invent</li> </ul> <p>Divergence is a fatal condition.</p>"},{"location":"REPL_INVARIANTS/#24-deterministic-state-reconstruction-invariant","title":"2.4 Deterministic State Reconstruction Invariant","text":"<p>Given:</p> <ul> <li>The same WAL prefix</li> <li>The same snapshot (if any)</li> </ul> <p>All nodes must reconstruct identical state, including:</p> <ul> <li>Version chains</li> <li>MVCC metadata</li> <li>GC state</li> <li>Snapshot boundaries</li> </ul> <p>Replication must not introduce nondeterminism.</p>"},{"location":"REPL_INVARIANTS/#25-no-invisible-divergence-invariant","title":"2.5 No Invisible Divergence Invariant","text":"<p>If replication state differs between nodes:</p> <ul> <li>The difference must be detectable</li> <li>The system must fail explicitly</li> <li>Silent divergence is forbidden</li> </ul> <p>\u201cNo news\u201d is not correctness.</p>"},{"location":"REPL_INVARIANTS/#26-replica-read-safety-invariant","title":"2.6 Replica Read Safety Invariant","text":"<p>A Replica may serve reads only if:</p> <ul> <li>The read view is \u2264 the Replica\u2019s applied CommitId</li> <li>MVCC visibility rules can be satisfied locally</li> <li>No future commits are implied or assumed</li> </ul> <p>If safety cannot be proven \u2192 reads must be refused.</p>"},{"location":"REPL_INVARIANTS/#27-wal-completeness-invariant","title":"2.7 WAL Completeness Invariant","text":"<p>Replication must ensure:</p> <ul> <li>WAL records are transferred in order</li> <li>WAL records are transferred without gaps</li> <li>Partial WAL application is detectable</li> </ul> <p>If a WAL gap exists \u2192 Replica must stop.</p>"},{"location":"REPL_INVARIANTS/#28-snapshot-authority-invariant","title":"2.8 Snapshot Authority Invariant","text":"<p>Snapshots used for replication must:</p> <ul> <li>Represent a valid MVCC cut</li> <li>Be self-contained</li> <li>Carry explicit commit boundaries</li> <li>Never depend on implicit WAL state</li> </ul> <p>Snapshot + WAL replay must be sufficient to reconstruct state.</p>"},{"location":"REPL_INVARIANTS/#29-replication-crash-safety-invariant","title":"2.9 Replication Crash Safety Invariant","text":"<p>At any crash point:</p> <ul> <li>A node must recover into a state that satisfies all invariants</li> <li> <p>Partial replication state must be:</p> </li> <li> <p>Either fully applied</p> </li> <li>Or fully discarded</li> </ul> <p>Replication must not create \u201cin-between\u201d states.</p>"},{"location":"REPL_INVARIANTS/#210-no-heuristic-progress-invariant","title":"2.10 No Heuristic Progress Invariant","text":"<p>Replication must never:</p> <ul> <li>Guess leader status</li> <li>Assume liveness</li> <li>Rely on timing, heartbeats, or clocks</li> <li>Auto-resolve conflicts</li> </ul> <p>If progress cannot be proven \u2192 replication halts.</p>"},{"location":"REPL_INVARIANTS/#3-explicitly-forbidden-replication-behaviors","title":"3. Explicitly Forbidden Replication Behaviors","text":"<p>Replication must never:</p> <ul> <li>Allow two Primaries concurrently</li> <li>Allow Replicas to acknowledge writes</li> <li>Reorder WAL records</li> <li>Skip WAL records</li> <li>\u201cCatch up\u201d by inference</li> <li>Heal divergence automatically</li> <li>Expose uncommitted or speculative state</li> <li>Downgrade durability semantics</li> </ul> <p>Any such behavior is a correctness violation.</p>"},{"location":"REPL_INVARIANTS/#4-invariant-enforcement-philosophy","title":"4. Invariant Enforcement Philosophy","text":"<p>Replication invariants are enforced by:</p> <ul> <li>WAL structure</li> <li>Explicit state transitions</li> <li>Recovery logic</li> <li>Crash testing</li> </ul> <p>Not by:</p> <ul> <li>Monitoring</li> <li>Background reconciliation</li> <li>Operational assumptions</li> </ul>"},{"location":"REPL_INVARIANTS/#5-invariant-summary","title":"5. Invariant Summary","text":"<p>Replication in AeroDB guarantees:</p> <ul> <li>Single authoritative history</li> <li>Deterministic replication</li> <li>MVCC-correct reads</li> <li>Explicit failure on uncertainty</li> <li>No hidden or heuristic behavior</li> </ul> <p>Replication extends correctness \u2014 it never negotiates it.</p>"},{"location":"REPL_MODEL/","title":"REPLICATION_MODEL.md","text":""},{"location":"REPL_MODEL/#aerodb-replication-authority-role-model","title":"AeroDB \u2014 Replication Authority &amp; Role Model","text":""},{"location":"REPL_MODEL/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It defines what replication roles exist and what they are allowed to do</li> <li>It defines authority boundaries and illegal states</li> <li>No implementation details appear here</li> <li>Phase-1 and MVCC semantics are frozen and assumed correct</li> </ul>"},{"location":"REPL_MODEL/#1-purpose-of-the-replication-model","title":"1. Purpose of the Replication Model","text":"<p>The replication model defines:</p> <ul> <li>Who is allowed to create history</li> <li>Who is allowed to consume history</li> <li>What states are legal vs illegal</li> <li>When the system must refuse to operate</li> </ul> <p>Replication is fundamentally about authority over history, not data movement.</p>"},{"location":"REPL_MODEL/#2-fundamental-roles","title":"2. Fundamental Roles","text":"<p>Replication introduces exactly two roles.</p>"},{"location":"REPL_MODEL/#21-primary","title":"2.1 Primary","text":"<p>The Primary is the sole authority for:</p> <ul> <li>Accepting client writes</li> <li>Assigning <code>CommitId</code></li> <li>Appending authoritative WAL records</li> <li>Defining the global history order</li> </ul> <p>The Primary is the only node allowed to create new history.</p>"},{"location":"REPL_MODEL/#22-replica","title":"2.2 Replica","text":"<p>A Replica is a node that:</p> <ul> <li>Receives history from the Primary</li> <li>Applies history deterministically</li> <li>Never creates new history</li> <li>Never assigns <code>CommitId</code></li> </ul> <p>A Replica is purely derivative.</p>"},{"location":"REPL_MODEL/#3-authority-invariants-restated-precisely","title":"3. Authority Invariants (Restated Precisely)","text":""},{"location":"REPL_MODEL/#31-single-writer-authority-invariant","title":"3.1 Single-Writer Authority Invariant","text":"<p>At any moment:</p> <ul> <li>Exactly one node may act as Primary</li> <li>All other nodes must behave as Replicas</li> </ul> <p>If two nodes believe they are Primary \u2192 system must halt writes.</p>"},{"location":"REPL_MODEL/#32-commit-authority-invariant","title":"3.2 Commit Authority Invariant","text":"<ul> <li>Only the Primary may assign <code>CommitId</code></li> <li> <p>Replicas must reject:</p> </li> <li> <p>Local commit attempts</p> </li> <li>WAL entries that imply new CommitIds not issued by the Primary</li> </ul> <p>Commit authority is not transferable implicitly.</p>"},{"location":"REPL_MODEL/#4-role-state-machine-conceptual","title":"4. Role State Machine (Conceptual)","text":"<p>Each node exists in one of the following states.</p>"},{"location":"REPL_MODEL/#41-uninitialized","title":"4.1 <code>Uninitialized</code>","text":"<ul> <li>No authoritative history exists</li> <li>Node has no WAL authority</li> <li>Node must not accept traffic</li> </ul> <p>This state exists only before bootstrap.</p>"},{"location":"REPL_MODEL/#42-primaryactive","title":"4.2 <code>PrimaryActive</code>","text":"<ul> <li>Node is the sole write authority</li> <li> <p>Node may:</p> </li> <li> <p>Accept writes</p> </li> <li>Assign CommitIds</li> <li>Emit WAL records</li> <li> <p>Node must:</p> </li> <li> <p>Reject attempts to follow another Primary</p> </li> </ul>"},{"location":"REPL_MODEL/#43-replicaactive","title":"4.3 <code>ReplicaActive</code>","text":"<ul> <li>Node follows a specific Primary</li> <li> <p>Node may:</p> </li> <li> <p>Apply WAL records</p> </li> <li>Serve reads (only if allowed later)</li> <li> <p>Node must:</p> </li> <li> <p>Reject all writes</p> </li> <li>Reject CommitId assignment</li> </ul>"},{"location":"REPL_MODEL/#44-replicationhalted","title":"4.4 <code>ReplicationHalted</code>","text":"<ul> <li>Node has detected an invariant violation</li> <li> <p>Examples:</p> </li> <li> <p>WAL gap detected</p> </li> <li>Divergent history detected</li> <li>Authority ambiguity detected</li> </ul> <p>In this state:</p> <ul> <li>No reads</li> <li>No writes</li> <li>Explicit operator intervention required</li> </ul>"},{"location":"REPL_MODEL/#5-illegal-states-must-never-exist","title":"5. Illegal States (Must Never Exist)","text":"<p>The following states are forbidden:</p>"},{"location":"REPL_MODEL/#dual-primary","title":"\u274c Dual Primary","text":"<p>Two nodes accepting writes concurrently.</p>"},{"location":"REPL_MODEL/#replica-with-commit-authority","title":"\u274c Replica with Commit Authority","text":"<p>A Replica assigning CommitIds or acknowledging writes.</p>"},{"location":"REPL_MODEL/#history-fork","title":"\u274c History Fork","text":"<p>Replica history that is not a prefix of Primary history.</p>"},{"location":"REPL_MODEL/#implicit-promotion","title":"\u274c Implicit Promotion","text":"<p>A Replica becoming Primary without explicit, external reconfiguration.</p> <p>Any of these conditions \u2192 fatal correctness violation.</p>"},{"location":"REPL_MODEL/#6-authority-determination-rules","title":"6. Authority Determination Rules","text":"<p>Replication does not include:</p> <ul> <li>Leader election</li> <li>Consensus</li> <li>Heartbeats</li> <li>Leases</li> <li>Timeouts</li> </ul> <p>Authority is determined externally (operator, config, orchestration).</p> <p>If authority is unclear \u2192 the node must refuse to operate.</p>"},{"location":"REPL_MODEL/#7-write-admission-rules","title":"7. Write Admission Rules","text":"<p>A write request:</p> <ul> <li> <p>May be accepted only if:</p> </li> <li> <p>Node is in <code>PrimaryActive</code></p> </li> <li>WAL is writable</li> <li>No authority ambiguity exists</li> <li> <p>Must be rejected if:</p> </li> <li> <p>Node is a Replica</p> </li> <li>Node is ReplicationHalted</li> <li>Node cannot guarantee durability</li> </ul> <p>Write rejection is safer than incorrect admission.</p>"},{"location":"REPL_MODEL/#8-read-admission-rules-high-level","title":"8. Read Admission Rules (High-Level)","text":"<p>At this level:</p> <ul> <li> <p>Reads may be served by:</p> </li> <li> <p>Primary</p> </li> <li>Replica (subject to later rules)</li> <li> <p>Reads must be refused if:</p> </li> <li> <p>Visibility cannot be proven correct</p> </li> <li>MVCC rules cannot be satisfied</li> </ul> <p>Exact read rules are deferred to <code>REPLICATION_READ_SEMANTICS.md</code>.</p>"},{"location":"REPL_MODEL/#9-crash-perspective","title":"9. Crash Perspective","text":"<p>After a crash:</p> <ul> <li>A node must re-establish its role explicitly</li> <li> <p>A Replica must re-validate:</p> </li> <li> <p>Its WAL prefix</p> </li> <li>Its snapshot boundary</li> <li> <p>A Primary must ensure:</p> </li> <li> <p>No other node is acting as Primary</p> </li> </ul> <p>Crash recovery never infers authority.</p>"},{"location":"REPL_MODEL/#10-explicit-non-goals-restated","title":"10. Explicit Non-Goals (Restated)","text":"<p>This model does not define:</p> <ul> <li>Automatic failover</li> <li>Split-brain resolution</li> <li>Dynamic membership</li> <li>Consensus protocols</li> </ul> <p>These require a future phase.</p>"},{"location":"REPL_MODEL/#11-model-summary","title":"11. Model Summary","text":"<p>The replication model enforces:</p> <ul> <li>Single authoritative history</li> <li>Explicit authority boundaries</li> <li>Fail-stop behavior on uncertainty</li> <li>MVCC-preserving replication</li> </ul> <p>Replication correctness begins with authority clarity. If authority is ambiguous, correctness is impossible.</p>"},{"location":"REPL_PROOFS/","title":"REPLICATION_PROOFS.md","text":""},{"location":"REPL_PROOFS/#aerodb-phase-2b-replication-correctness-proofs","title":"AeroDB Phase 2B \u2014 Replication Correctness Proofs","text":""},{"location":"REPL_PROOFS/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It provides argument-based proofs of replication correctness</li> <li>Proofs rely only on invariants and WAL semantics</li> <li>No implementation assumptions appear here</li> <li>Phase-1 and MVCC semantics are frozen and assumed correct</li> </ul>"},{"location":"REPL_PROOFS/#1-proof-methodology","title":"1. Proof Methodology","text":"<p>All proofs in this document are constructed from:</p> <ul> <li>Phase-1 invariants</li> <li>MVCC invariants</li> <li>Replication invariants</li> <li>WAL as the sole authority</li> <li>Exhaustive failure enumeration</li> </ul> <p>Each proof answers the question:</p> <p>\u201cWhy does this behavior remain correct under all crashes, replays, and replication lag?\u201d</p>"},{"location":"REPL_PROOFS/#2-proof-of-single-writer-safety","title":"2. Proof of Single-Writer Safety","text":""},{"location":"REPL_PROOFS/#claim","title":"Claim","text":"<p>At most one node can create authoritative history at any time.</p>"},{"location":"REPL_PROOFS/#argument","title":"Argument","text":"<ol> <li>Only a node in <code>PrimaryActive</code> may assign <code>CommitId</code></li> <li>CommitIds originate solely from WAL records</li> <li>Replicas reject local commit attempts</li> <li>Authority is externally configured, never inferred</li> </ol> <p>Therefore:</p> <ul> <li>Only one node can create new WAL history</li> <li>No two nodes can legally acknowledge writes</li> </ul>"},{"location":"REPL_PROOFS/#conclusion","title":"Conclusion","text":"<p>Single-writer safety is enforced by authority rules, not timing.</p>"},{"location":"REPL_PROOFS/#3-proof-of-global-history-linearity","title":"3. Proof of Global History Linearity","text":""},{"location":"REPL_PROOFS/#claim_1","title":"Claim","text":"<p>All nodes observe a single, totally ordered history.</p>"},{"location":"REPL_PROOFS/#argument_1","title":"Argument","text":"<ol> <li>WAL records are totally ordered on the Primary</li> <li>Replication preserves strict WAL order</li> <li>Replicas apply only WAL prefixes</li> <li>Gaps and reordering are detected and fatal</li> </ol> <p>Therefore:</p> <ul> <li>Replica history is always a prefix of Primary history</li> <li>No forks or divergence can exist silently</li> </ul>"},{"location":"REPL_PROOFS/#conclusion_1","title":"Conclusion","text":"<p>Global history linearity is preserved deterministically.</p>"},{"location":"REPL_PROOFS/#4-proof-of-deterministic-state-reconstruction","title":"4. Proof of Deterministic State Reconstruction","text":""},{"location":"REPL_PROOFS/#claim_2","title":"Claim","text":"<p>Given identical WAL prefixes (and snapshots), all nodes reconstruct identical state.</p>"},{"location":"REPL_PROOFS/#argument_2","title":"Argument","text":"<ol> <li>WAL replay is deterministic (Phase-1 invariant)</li> <li>MVCC reconstruction is deterministic</li> <li>GC actions are WAL-represented</li> <li>Snapshot boundaries are explicit</li> </ol> <p>Therefore:</p> <ul> <li>State reconstruction is a pure function of WAL + snapshot</li> <li>No runtime or timing influence exists</li> </ul>"},{"location":"REPL_PROOFS/#conclusion_2","title":"Conclusion","text":"<p>Replication preserves deterministic replay.</p>"},{"location":"REPL_PROOFS/#5-proof-of-replica-read-safety","title":"5. Proof of Replica Read Safety","text":""},{"location":"REPL_PROOFS/#claim_3","title":"Claim","text":"<p>Replica reads never return incorrect or future-visible data.</p>"},{"location":"REPL_PROOFS/#argument_3","title":"Argument","text":"<ol> <li> <p>Replica reads are allowed only when:</p> </li> <li> <p>Read view \u2264 applied WAL prefix</p> </li> <li>Visibility rules are identical to Primary</li> <li>Read views are immutable</li> <li>WAL gaps or uncertainty force refusal</li> </ol> <p>Therefore:</p> <ul> <li>Replica reads are either correct or refused</li> <li>No speculative visibility exists</li> </ul>"},{"location":"REPL_PROOFS/#conclusion_3","title":"Conclusion","text":"<p>Replica reads are MVCC-correct or fail-stop.</p>"},{"location":"REPL_PROOFS/#6-proof-of-snapshot-bootstrap-equivalence","title":"6. Proof of Snapshot Bootstrap Equivalence","text":""},{"location":"REPL_PROOFS/#claim_4","title":"Claim","text":"<p>Snapshot + WAL bootstrap is semantically equivalent to full WAL replay.</p>"},{"location":"REPL_PROOFS/#argument_4","title":"Argument","text":"<ol> <li>Snapshot represents a valid MVCC cut at <code>C_snap</code></li> <li>Snapshot includes all state \u2264 <code>C_snap</code></li> <li>WAL replay resumes strictly after <code>C_snap</code></li> <li>No WAL entries \u2264 <code>C_snap</code> are replayed</li> </ol> <p>Therefore:</p> <ul> <li>Final reconstructed state is identical</li> <li>No history is skipped or rewritten</li> </ul>"},{"location":"REPL_PROOFS/#conclusion_4","title":"Conclusion","text":"<p>Snapshot transfer preserves full correctness.</p>"},{"location":"REPL_PROOFS/#7-proof-of-crash-safety-under-replication","title":"7. Proof of Crash Safety Under Replication","text":""},{"location":"REPL_PROOFS/#claim_5","title":"Claim","text":"<p>Replication introduces no undefined states under crash.</p>"},{"location":"REPL_PROOFS/#argument_5","title":"Argument","text":"<ol> <li>All crash points are enumerated in the failure matrix</li> <li>WAL durability defines commit existence</li> <li>Partial replication state is discarded</li> <li>Recovery is deterministic and idempotent</li> </ol> <p>Therefore:</p> <ul> <li>Every crash maps to exactly one valid recovery outcome</li> <li>No ambiguous state exists</li> </ul>"},{"location":"REPL_PROOFS/#conclusion_5","title":"Conclusion","text":"<p>Replication is crash-safe by construction.</p>"},{"location":"REPL_PROOFS/#8-proof-of-no-silent-divergence","title":"8. Proof of No Silent Divergence","text":""},{"location":"REPL_PROOFS/#claim_6","title":"Claim","text":"<p>Replication cannot silently diverge.</p>"},{"location":"REPL_PROOFS/#argument_6","title":"Argument","text":"<ol> <li>Replicas require WAL prefix equality</li> <li>Checksums and ordering enforce integrity</li> <li>Any divergence triggers <code>ReplicationHalted</code></li> <li>No auto-healing is permitted</li> </ol> <p>Therefore:</p> <ul> <li>Divergence is detectable</li> <li>Divergence is fatal, not hidden</li> </ul>"},{"location":"REPL_PROOFS/#conclusion_6","title":"Conclusion","text":"<p>Silent divergence is impossible.</p>"},{"location":"REPL_PROOFS/#9-proof-of-phase-1-mvcc-compatibility","title":"9. Proof of Phase-1 &amp; MVCC Compatibility","text":""},{"location":"REPL_PROOFS/#claim_7","title":"Claim","text":"<p>Replication does not alter Phase-1 or MVCC semantics.</p>"},{"location":"REPL_PROOFS/#argument_7","title":"Argument","text":"<ol> <li>WAL semantics are unchanged</li> <li>CommitId semantics are unchanged</li> <li>Visibility rules are unchanged</li> <li>GC rules are unchanged</li> <li>Snapshot semantics are unchanged</li> </ol> <p>Therefore:</p> <ul> <li>Replication adds no new meanings</li> <li>Existing behaviors remain authoritative</li> </ul>"},{"location":"REPL_PROOFS/#conclusion_7","title":"Conclusion","text":"<p>Replication is a strict extension, not a modification.</p>"},{"location":"REPL_PROOFS/#10-global-replication-correctness-theorem","title":"10. Global Replication Correctness Theorem","text":""},{"location":"REPL_PROOFS/#statement","title":"Statement","text":"<p>Given:</p> <ul> <li>Phase-1 invariants</li> <li>MVCC invariants</li> <li>Replication invariants</li> <li>WAL as the sole authority</li> </ul> <p>AeroDB replication guarantees:</p> <ul> <li>Single authoritative history</li> <li>Deterministic state propagation</li> <li>MVCC-correct reads</li> <li>Crash-safe recovery</li> <li>No silent divergence</li> </ul> <p>Under all crash, partition, and replay scenarios.</p>"},{"location":"REPL_PROOFS/#11-proof-closure","title":"11. Proof Closure","text":"<p>At this point:</p> <ul> <li>Replication semantics are fully specified</li> <li>All failure modes are defined</li> <li>Correctness arguments are complete</li> <li>No implementation assumptions remain</li> </ul> <p>Replication is now provably safe to implement.</p>"},{"location":"REPL_READ_RULES/","title":"REPLICATION_READ_SEMANTICS.md","text":""},{"location":"REPL_READ_RULES/#aerodb-replica-read-semantics-mvcc-safety","title":"AeroDB \u2014 Replica Read Semantics &amp; MVCC Safety","text":""},{"location":"REPL_READ_RULES/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It defines exactly what reads Replicas may or may not serve</li> <li>All rules are safety-first and fail-stop</li> <li>No implementation details appear here</li> <li>Phase-1 and MVCC semantics are frozen and assumed correct</li> </ul>"},{"location":"REPL_READ_RULES/#1-purpose-of-replica-read-semantics","title":"1. Purpose of Replica Read Semantics","text":"<p>Replication introduces a fundamental question:</p> <p>When is it safe for a Replica to answer a read?</p> <p>This document answers that question without weakening:</p> <ul> <li>MVCC visibility rules</li> <li>Deterministic behavior</li> <li>Crash safety</li> <li>Phase-1 correctness guarantees</li> </ul> <p>Replica reads are an optional capability, not a requirement.</p>"},{"location":"REPL_READ_RULES/#2-foundational-principle","title":"2. Foundational Principle","text":"<p>A Replica may serve a read if and only if it can prove that the result is identical to what the Primary would return for the same read view.</p> <p>If this proof cannot be made, the read must be refused.</p>"},{"location":"REPL_READ_RULES/#3-replica-read-modes-conceptual","title":"3. Replica Read Modes (Conceptual)","text":"<p>Replication defines exactly two conceptual read modes.</p>"},{"location":"REPL_READ_RULES/#31-primary-reads","title":"3.1 Primary Reads","text":"<ul> <li>Served by the Primary</li> <li>Always authoritative</li> <li>Always up-to-date</li> <li>Governed by standard MVCC rules</li> </ul> <p>Primary reads are unchanged by replication.</p>"},{"location":"REPL_READ_RULES/#32-replica-reads","title":"3.2 Replica Reads","text":"<ul> <li>Served by a Replica</li> <li>Always potentially stale</li> <li>Must obey strict safety rules</li> <li>Must never imply future visibility</li> </ul> <p>Replica reads are optional and explicitly constrained.</p>"},{"location":"REPL_READ_RULES/#4-replica-read-eligibility-rule-formal","title":"4. Replica Read Eligibility Rule (Formal)","text":"<p>A Replica may serve a read if and only if all of the following hold:</p> <ol> <li>The Replica is in state <code>ReplicaActive</code></li> <li>The Replica\u2019s applied WAL prefix ends at commit <code>C_replica</code></li> <li>The requested read view <code>R</code> satisfies:</li> </ol> <p><pre><code>R.read_upper_bound \u2264 C_replica\n</code></pre> 4. All MVCC metadata required for the read view exists locally 5. No WAL gaps or replication errors are present</p> <p>Failure of any condition \u2192 read must be refused.</p>"},{"location":"REPL_READ_RULES/#5-read-view-handling-on-replicas","title":"5. Read View Handling on Replicas","text":""},{"location":"REPL_READ_RULES/#51-read-view-creation","title":"5.1 Read View Creation","text":"<p>Replica read views:</p> <ul> <li>Are created locally</li> <li>Must use:</li> </ul> <p><pre><code>read_upper_bound = C_replica\n</code></pre> * Must not reference Primary state * Must not infer future commits</p> <p>Replica read views are never speculative.</p>"},{"location":"REPL_READ_RULES/#52-read-view-stability","title":"5.2 Read View Stability","text":"<p>Once created:</p> <ul> <li>The read view is immutable</li> <li>Subsequent WAL application must not affect it</li> <li>Reads observe a stable snapshot</li> </ul> <p>Replica reads obey exactly the same MVCC_VISIBILITY rules.</p>"},{"location":"REPL_READ_RULES/#6-visibility-guarantees-on-replicas","title":"6. Visibility Guarantees on Replicas","text":"<p>For any key <code>K</code>:</p> <ul> <li> <p>The Replica must select the visible version using:</p> </li> <li> <p>The same visibility resolver as the Primary</p> </li> <li>The same commit identity rules</li> <li>Results must be bit-for-bit identical to a Primary read at the same boundary</li> </ul> <p>If this cannot be guaranteed \u2192 read must be refused.</p>"},{"location":"REPL_READ_RULES/#7-range-queries-on-replicas","title":"7. Range Queries on Replicas","text":"<p>Range queries served by Replicas must:</p> <ul> <li>Use one shared read view</li> <li>Never mix visibility boundaries</li> <li>Never observe partial replication progress</li> </ul> <p>If WAL advances during the range scan:</p> <ul> <li>The scan must continue using the original read view</li> <li>WAL progress must not affect results</li> </ul>"},{"location":"REPL_READ_RULES/#8-read-refusal-conditions-mandatory","title":"8. Read Refusal Conditions (Mandatory)","text":"<p>A Replica must refuse reads if:</p> <ul> <li>Replication is halted</li> <li>WAL gaps are detected</li> <li>Snapshot installation is incomplete</li> <li>Replica is mid-recovery</li> <li>Replica state is uncertain</li> <li>Read view boundary cannot be proven safe</li> </ul> <p>Refusal is not a failure \u2014 it is correctness enforcement.</p>"},{"location":"REPL_READ_RULES/#9-crash-restart-semantics","title":"9. Crash &amp; Restart Semantics","text":"<p>After a crash:</p> <ul> <li> <p>Replica must re-validate:</p> </li> <li> <p>WAL prefix integrity</p> </li> <li>Snapshot boundary (if any)</li> <li>Replica must not serve reads until validation completes</li> </ul> <p>No \u201cbest-effort\u201d reads are allowed during recovery.</p>"},{"location":"REPL_READ_RULES/#10-interaction-with-gc","title":"10. Interaction with GC","text":"<p>Replica reads must respect GC rules:</p> <ul> <li>Versions required by read view must exist</li> <li>GC must never remove versions visible to replica reads</li> <li>Snapshot retention rules apply equally on Replicas</li> </ul> <p>GC safety is identical on Primary and Replica.</p>"},{"location":"REPL_READ_RULES/#11-explicitly-forbidden-replica-read-behaviors","title":"11. Explicitly Forbidden Replica Read Behaviors","text":"<p>Replica reads must never:</p> <ul> <li>Serve reads ahead of applied WAL</li> <li>Guess Primary commit state</li> <li>Use wall-clock time</li> <li>Use \u201clast known good\u201d shortcuts</li> <li>Relax MVCC visibility rules</li> <li>Mask replication errors</li> </ul> <p>Any of these constitutes a correctness violation.</p>"},{"location":"REPL_READ_RULES/#12-read-semantics-summary","title":"12. Read Semantics Summary","text":"<p>Replica read semantics guarantee:</p> <ul> <li>Deterministic, MVCC-correct results</li> <li>Explicit staleness boundaries</li> <li>Fail-stop behavior on uncertainty</li> <li>No semantic drift from Primary behavior</li> </ul> <p>A Replica may lag. It may never lie.</p>"},{"location":"REPL_RECOVERY_MODEL/","title":"REPLICATION_RECOVERY.md","text":""},{"location":"REPL_RECOVERY_MODEL/#aerodb-replication-recovery-restart-semantics","title":"AeroDB \u2014 Replication Recovery &amp; Restart Semantics","text":""},{"location":"REPL_RECOVERY_MODEL/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It defines how replication resumes after crashes or restarts</li> <li>All behavior is fail-stop and deterministic</li> <li>No implementation details appear here</li> <li>Phase-1 and MVCC semantics are frozen and preserved</li> </ul>"},{"location":"REPL_RECOVERY_MODEL/#1-purpose-of-replication-recovery","title":"1. Purpose of Replication Recovery","text":"<p>Replication recovery exists to answer one question only:</p> <p>After a crash or restart, is it safe for this node to participate in replication?</p> <p>If safety cannot be proven, the node must refuse to operate.</p> <p>Recovery prioritizes correctness over availability.</p>"},{"location":"REPL_RECOVERY_MODEL/#2-recovery-entry-conditions","title":"2. Recovery Entry Conditions","text":"<p>On startup, a node must determine:</p> <ul> <li>Its configured role (Primary or Replica)</li> <li>The integrity of its local state</li> <li>Whether replication can resume safely</li> </ul> <p>No implicit role inference is permitted.</p>"},{"location":"REPL_RECOVERY_MODEL/#3-primary-recovery-semantics","title":"3. Primary Recovery Semantics","text":""},{"location":"REPL_RECOVERY_MODEL/#31-primary-restart-preconditions","title":"3.1 Primary Restart Preconditions","text":"<p>A node configured as Primary must verify:</p> <ol> <li>Local WAL integrity</li> <li>WAL completeness (no gaps, no corruption)</li> <li>MVCC state consistency</li> <li>Snapshot correctness (if present)</li> </ol> <p>Failure of any check \u2192 startup aborts.</p>"},{"location":"REPL_RECOVERY_MODEL/#32-commit-authority-reassertion","title":"3.2 Commit Authority Reassertion","text":"<p>After recovery:</p> <ul> <li>The Primary reasserts commit authority</li> <li>CommitId assignment resumes strictly after the last durable CommitId</li> <li>No CommitId renumbering or rewriting is allowed</li> </ul> <p>The Primary must not assume replicas are synchronized.</p>"},{"location":"REPL_RECOVERY_MODEL/#33-write-admission-after-recovery","title":"3.3 Write Admission After Recovery","text":"<p>The Primary may accept writes only if:</p> <ul> <li>Local recovery completed successfully</li> <li>No replication invariant violations are detected</li> <li>Authority configuration is unchanged</li> </ul> <p>Replication state does not gate Primary write authority unless explicitly configured.</p>"},{"location":"REPL_RECOVERY_MODEL/#4-replica-recovery-semantics","title":"4. Replica Recovery Semantics","text":""},{"location":"REPL_RECOVERY_MODEL/#41-replica-restart-preconditions","title":"4.1 Replica Restart Preconditions","text":"<p>A Replica must verify:</p> <ol> <li>WAL integrity</li> <li>WAL prefix validity</li> <li>Snapshot boundary correctness (if present)</li> <li>MVCC metadata consistency</li> </ol> <p>Failure \u2192 Replica enters <code>ReplicationHalted</code>.</p>"},{"location":"REPL_RECOVERY_MODEL/#42-replica-history-validation","title":"4.2 Replica History Validation","text":"<p>A Replica must validate that:</p> <ul> <li>Its WAL is a valid prefix of the Primary\u2019s WAL</li> <li>No local WAL records exist beyond the Primary\u2019s history</li> <li>No divergence is present</li> </ul> <p>If validation cannot be performed \u2192 replication must not resume.</p>"},{"location":"REPL_RECOVERY_MODEL/#43-resuming-wal-application","title":"4.3 Resuming WAL Application","text":"<p>A Replica may resume WAL replay only if:</p> <ul> <li>WAL continuity is provable</li> <li>Next expected WAL record is known</li> <li>No gaps exist</li> </ul> <p>Otherwise, explicit operator intervention is required.</p>"},{"location":"REPL_RECOVERY_MODEL/#5-snapshot-interaction-during-recovery","title":"5. Snapshot Interaction During Recovery","text":""},{"location":"REPL_RECOVERY_MODEL/#51-recovery-from-snapshot","title":"5.1 Recovery from Snapshot","text":"<p>If a snapshot exists:</p> <ul> <li>Snapshot is loaded first</li> <li>Snapshot commit boundary is established</li> <li>WAL replay resumes strictly after boundary</li> </ul> <p>Snapshot correctness is mandatory.</p>"},{"location":"REPL_RECOVERY_MODEL/#52-snapshot-invalidation","title":"5.2 Snapshot Invalidation","text":"<p>If snapshot integrity cannot be proven:</p> <ul> <li>Snapshot must be discarded</li> <li>Replica must restart bootstrap explicitly</li> </ul> <p>No partial reuse is allowed.</p>"},{"location":"REPL_RECOVERY_MODEL/#6-crash-during-recovery","title":"6. Crash During Recovery","text":"<p>If a crash occurs:</p> <ul> <li>Recovery restarts from the beginning</li> <li>No partial recovery state persists</li> <li>Deterministic outcome is preserved</li> </ul> <p>Recovery is idempotent.</p>"},{"location":"REPL_RECOVERY_MODEL/#7-authority-ambiguity-handling","title":"7. Authority Ambiguity Handling","text":"<p>If a node detects:</p> <ul> <li>Conflicting role configuration</li> <li>Unclear Primary identity</li> <li>Divergent histories</li> </ul> <p>Then:</p> <ul> <li>Node must refuse to operate</li> <li>Node enters <code>ReplicationHalted</code></li> <li>No reads or writes are allowed</li> </ul> <p>Correctness requires explicit resolution.</p>"},{"location":"REPL_RECOVERY_MODEL/#8-interaction-with-read-semantics","title":"8. Interaction with Read Semantics","text":"<p>After recovery:</p> <ul> <li>Primary may serve reads immediately</li> <li> <p>Replica may serve reads only after:</p> </li> <li> <p>WAL prefix validation</p> </li> <li>Snapshot/WAL consistency validation</li> </ul> <p>Reads during uncertainty are forbidden.</p>"},{"location":"REPL_RECOVERY_MODEL/#9-explicitly-forbidden-recovery-behaviors","title":"9. Explicitly Forbidden Recovery Behaviors","text":"<p>Replication recovery must never:</p> <ul> <li>Guess missing WAL records</li> <li>Auto-truncate history</li> <li>Heal divergence</li> <li>Assume liveness of other nodes</li> <li>Resume partially validated state</li> </ul> <p>Any such behavior is a correctness violation.</p>"},{"location":"REPL_RECOVERY_MODEL/#10-determinism-guarantee","title":"10. Determinism Guarantee","text":"<p>Given identical local state:</p> <ul> <li>Recovery outcome is identical</li> <li>No timing or ordering effects exist</li> <li>Restart behavior is reproducible</li> </ul> <p>Replication recovery is a pure function of persisted state.</p>"},{"location":"REPL_RECOVERY_MODEL/#11-recovery-summary","title":"11. Recovery Summary","text":"<p>Replication recovery guarantees:</p> <ul> <li>Safe restart</li> <li>Explicit validation</li> <li>Deterministic resumption</li> <li>Fail-stop on uncertainty</li> </ul> <p>A node that cannot prove safety must refuse to run.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/","title":"REPLICATION_SNAPSHOT_TRANSFER.md","text":""},{"location":"REPL_SNAPSHOT_TRANSFER/#aerodb-replication-snapshot-transfer-semantics","title":"AeroDB \u2014 Replication Snapshot Transfer Semantics","text":""},{"location":"REPL_SNAPSHOT_TRANSFER/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It defines snapshot-based replication bootstrap</li> <li>It preserves MVCC snapshot semantics exactly</li> <li>No transport, protocol, or implementation details appear here</li> <li>Phase-1 and MVCC invariants are fully assumed and preserved</li> </ul>"},{"location":"REPL_SNAPSHOT_TRANSFER/#1-purpose-of-snapshot-transfer-in-replication","title":"1. Purpose of Snapshot Transfer in Replication","text":"<p>Snapshot transfer exists to solve one problem only:</p> <p>Efficiently initializing or re-synchronizing a Replica without replaying the entire WAL history, without altering correctness semantics.</p> <p>Snapshot transfer is not an optimization of semantics. It is a logically equivalent alternative to WAL-only bootstrap.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#2-snapshot-authority-in-replication","title":"2. Snapshot Authority in Replication","text":"<p>A snapshot used for replication:</p> <ul> <li>Is produced only by the Primary</li> <li>Represents a valid MVCC cut</li> <li>Is identical in meaning to a local snapshot</li> <li>Is authoritative up to its commit boundary</li> </ul> <p>Replica must treat the snapshot as ground truth up to that boundary.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#3-snapshot-eligibility-for-transfer","title":"3. Snapshot Eligibility for Transfer","text":"<p>A snapshot is eligible for replication transfer if and only if:</p> <ol> <li>It was created by the Primary</li> <li>It has a valid <code>snapshot_commit_boundary</code></li> <li>It is complete and self-contained</li> <li>It passed all snapshot integrity checks</li> <li>It has not been superseded or invalidated</li> </ol> <p>Any uncertainty \u2192 snapshot must be rejected.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#4-snapshot-transfer-semantics-conceptual","title":"4. Snapshot Transfer Semantics (Conceptual)","text":"<p>Snapshot transfer is defined abstractly as:</p> <ol> <li>Primary selects a snapshot with boundary <code>C_snap</code></li> <li>Snapshot data is transferred to the Replica</li> <li>Replica validates snapshot integrity</li> <li>Replica installs snapshot atomically</li> <li>Replica resumes WAL replay at:</li> </ol> <pre><code>CommitId &gt; C_snap\n</code></pre> <p>No step may be skipped or reordered.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#5-snapshot-installation-rules","title":"5. Snapshot Installation Rules","text":""},{"location":"REPL_SNAPSHOT_TRANSFER/#51-atomicity","title":"5.1 Atomicity","text":"<p>Snapshot installation on a Replica must be:</p> <ul> <li>Atomic</li> <li>All-or-nothing</li> <li>Crash-safe</li> </ul> <p>If a crash occurs:</p> <ul> <li>Before completion \u2192 snapshot is discarded</li> <li>After completion \u2192 snapshot is fully authoritative</li> </ul> <p>Partial snapshot state is forbidden.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#52-snapshot-validation-on-replica","title":"5.2 Snapshot Validation on Replica","text":"<p>Before accepting a snapshot, the Replica must validate:</p> <ul> <li>Snapshot checksum</li> <li>Manifest integrity</li> <li>Commit boundary consistency</li> <li>MVCC metadata completeness</li> <li>Absence of implicit WAL dependency</li> </ul> <p>Failure \u2192 snapshot rejected explicitly.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#6-wal-resume-semantics-after-snapshot","title":"6. WAL Resume Semantics After Snapshot","text":"<p>After snapshot installation:</p> <ul> <li> <p>Replica must discard:</p> </li> <li> <p>Any WAL state \u2264 <code>C_snap</code></p> </li> <li> <p>Replica must accept:</p> </li> <li> <p>WAL records with <code>CommitId &gt; C_snap</code></p> </li> <li> <p>WAL records must be:</p> </li> <li> <p>Contiguous</p> </li> <li>Ordered</li> <li>Gap-free</li> </ul> <p>Any violation \u2192 replication halts.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#7-snapshot-vs-local-state-interaction","title":"7. Snapshot vs Local State Interaction","text":""},{"location":"REPL_SNAPSHOT_TRANSFER/#71-empty-replica","title":"7.1 Empty Replica","text":"<p>If Replica has no prior state:</p> <ul> <li>Snapshot becomes the initial state</li> <li>WAL replay begins strictly after boundary</li> </ul>"},{"location":"REPL_SNAPSHOT_TRANSFER/#72-previously-initialized-replica","title":"7.2 Previously Initialized Replica","text":"<p>If Replica already has state:</p> <ul> <li> <p>Snapshot may be applied only if:</p> </li> <li> <p>Existing state is discarded explicitly</p> </li> <li>No mixed-state reuse occurs</li> </ul> <p>State reuse is forbidden unless explicitly validated (future phase).</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#8-interaction-with-mvcc-gc","title":"8. Interaction with MVCC &amp; GC","text":"<p>Snapshot transfer must preserve:</p> <ul> <li>All version chains \u2264 boundary</li> <li>All tombstones required for visibility</li> <li>All MVCC metadata</li> <li>GC eligibility constraints</li> </ul> <p>Replica must not:</p> <ul> <li>Recompute GC state</li> <li>Drop versions eagerly</li> <li>Apply local GC rules beyond snapshot semantics</li> </ul> <p>GC continues normally after replication resumes.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#9-crash-scenarios","title":"9. Crash Scenarios","text":""},{"location":"REPL_SNAPSHOT_TRANSFER/#91-crash-during-snapshot-transfer","title":"9.1 Crash During Snapshot Transfer","text":"<ul> <li>Snapshot is incomplete</li> <li>Replica must discard it</li> <li>Replica remains uninitialized or in prior state</li> </ul>"},{"location":"REPL_SNAPSHOT_TRANSFER/#92-crash-after-snapshot-install-before-wal-resume","title":"9.2 Crash After Snapshot Install, Before WAL Resume","text":"<ul> <li>Snapshot is authoritative</li> <li>WAL replay resumes after restart</li> </ul> <p>No ambiguity is allowed.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#10-explicitly-forbidden-behaviors","title":"10. Explicitly Forbidden Behaviors","text":"<p>Snapshot-based replication must never:</p> <ul> <li>Merge snapshot with partial WAL state</li> <li>Infer missing WAL entries</li> <li>Skip validation for speed</li> <li>Apply snapshot incrementally</li> <li>Modify snapshot contents</li> <li>Allow Replica to create snapshots</li> </ul> <p>Correctness &gt; convenience.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#11-equivalence-to-wal-only-bootstrap","title":"11. Equivalence to WAL-Only Bootstrap","text":"<p>Formally:</p> <p>A Replica initialized via snapshot + WAL replay must reach exactly the same state as a Replica initialized via full WAL replay.</p> <p>If this equivalence cannot be proven \u2192 snapshot transfer is invalid.</p>"},{"location":"REPL_SNAPSHOT_TRANSFER/#12-snapshot-transfer-summary","title":"12. Snapshot Transfer Summary","text":"<p>Snapshot transfer provides:</p> <ul> <li>Efficient replication bootstrap</li> <li>Deterministic MVCC state</li> <li>WAL-compatible continuation</li> <li>Crash-safe installation</li> </ul> <p>Snapshots shorten time \u2014 they never shorten history.</p>"},{"location":"REPL_VISION/","title":"REPLICATION_VISION.md","text":""},{"location":"REPL_VISION/#aerodb-phase-2b-replication-vision","title":"AeroDB Phase 2B \u2014 Replication Vision","text":""},{"location":"REPL_VISION/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It defines intent, scope, and boundaries</li> <li>No implementation details appear here</li> <li>Phase-1 and MVCC semantics are frozen and inviolable</li> </ul>"},{"location":"REPL_VISION/#1-purpose-of-replication-in-aerodb","title":"1. Purpose of Replication in AeroDB","text":"<p>Replication exists to extend AeroDB from a single-node, correctness-complete database into a multi-node system without weakening any existing guarantees.</p> <p>Replication in AeroDB is not a scaling shortcut. It is a durability, availability, and correctness extension.</p> <p>The primary goal is state continuity, not throughput.</p>"},{"location":"REPL_VISION/#2-non-negotiable-continuity","title":"2. Non-Negotiable Continuity","text":"<p>Replication must preserve all existing guarantees:</p>"},{"location":"REPL_VISION/#phase-1-unchanged","title":"Phase-1 (unchanged)","text":"<ul> <li>No acknowledged write is ever lost</li> <li>WAL is the sole durability authority</li> <li>Recovery is deterministic</li> <li>Corruption is detected, never repaired silently</li> <li>Queries are bounded and deterministic</li> <li>Snapshot, checkpoint, backup, restore semantics remain intact</li> </ul>"},{"location":"REPL_VISION/#phase-2-mvcc-unchanged","title":"Phase-2 MVCC (unchanged)","text":"<ul> <li>CommitId total order is authoritative</li> <li>Visibility is deterministic and snapshot-based</li> <li>Write atomicity is absolute</li> <li>GC rules are proof-based and WAL-governed</li> <li>MVCC semantics are frozen</li> </ul> <p>Replication consumes these properties. It does not reinterpret them.</p>"},{"location":"REPL_VISION/#3-replication-philosophy","title":"3. Replication Philosophy","text":"<p>Replication in AeroDB is:</p> <ul> <li>Deterministic \u2014 same WAL \u21d2 same state everywhere</li> <li>Explicit \u2014 no hidden quorum rules or timing tricks</li> <li>Fail-stop \u2014 uncertainty results in refusal, not guesses</li> <li>History-preserving \u2014 replicas never rewrite or \u201cheal\u201d history</li> <li>MVCC-aware \u2014 version semantics are preserved exactly</li> </ul> <p>Replication correctness is valued above availability.</p>"},{"location":"REPL_VISION/#4-what-replication-means-in-aerodb","title":"4. What Replication Means in AeroDB","text":"<p>At a high level, replication introduces:</p> <ul> <li> <p>A single Primary</p> </li> <li> <p>Sole authority for accepting writes</p> </li> <li>Sole assigner of CommitIds</li> <li> <p>One or more Replicas</p> </li> <li> <p>Receive ordered state from the Primary</p> </li> <li>Never generate new history</li> <li> <p>Deterministic State Propagation</p> </li> <li> <p>WAL-based replication</p> </li> <li>Explicit snapshot transfer when needed</li> </ul> <p>Replication is state replication, not command replication.</p>"},{"location":"REPL_VISION/#5-explicit-non-goals","title":"5. Explicit Non-Goals","text":"<p>Replication in this phase does not attempt to provide:</p> <ul> <li>Multi-leader writes</li> <li>Automatic leader election</li> <li>Write availability during primary loss</li> <li>Eventual consistency</li> <li>Conflict resolution</li> <li>Byzantine fault tolerance</li> </ul> <p>If a behavior is not specified, it does not exist.</p>"},{"location":"REPL_VISION/#6-replication-safety-model","title":"6. Replication Safety Model","text":"<p>Replication must obey the following high-level safety rules:</p> <ol> <li> <p>Single Writer Rule    Only one node may acknowledge writes at any time.</p> </li> <li> <p>CommitId Authority Rule    CommitIds are assigned only by the Primary.</p> </li> <li> <p>History Prefix Rule    A Replica\u2019s state must always be a prefix of the Primary\u2019s history.</p> </li> <li> <p>No Guessing Rule    If ordering, completeness, or authority is uncertain \u2192 replication halts.</p> </li> <li> <p>No Invisible Divergence Rule    Divergence must be detectable and fatal, never silent.</p> </li> </ol>"},{"location":"REPL_VISION/#7-replication-and-durability","title":"7. Replication and Durability","text":"<p>Replication does not redefine durability.</p> <ul> <li> <p>A write is durable when:</p> </li> <li> <p>WAL fsync semantics are satisfied per policy</p> </li> <li>Replication may strengthen durability guarantees</li> <li>Replication must never weaken them</li> </ul> <p>Acknowledgement semantics will be defined explicitly later.</p>"},{"location":"REPL_VISION/#8-replication-and-mvcc","title":"8. Replication and MVCC","text":"<p>Replication must preserve:</p> <ul> <li>CommitId ordering</li> <li>Version immutability</li> <li>Snapshot isolation</li> <li>GC eligibility rules</li> </ul> <p>A Replica must produce identical visibility outcomes for the same read view boundary.</p> <p>MVCC correctness is replicated, not recomputed.</p>"},{"location":"REPL_VISION/#9-crash-failure-perspective","title":"9. Crash &amp; Failure Perspective","text":"<p>Replication must be correct under:</p> <ul> <li>Primary crash</li> <li>Replica crash</li> <li>Network partition</li> <li>Partial WAL transfer</li> <li>Snapshot transfer interruption</li> </ul> <p>There are no undefined states. Every failure must map to a specified outcome.</p>"},{"location":"REPL_VISION/#10-design-deferrals","title":"10. Design Deferrals","text":"<p>This document intentionally does not define:</p> <ul> <li>WAL shipping mechanics</li> <li>Snapshot vs log transfer rules</li> <li>Replica read permissions</li> <li>Failure handling algorithms</li> <li>Promotion or leadership changes</li> </ul> <p>Those belong in subsequent replication documents.</p>"},{"location":"REPL_VISION/#11-vision-summary","title":"11. Vision Summary","text":"<p>Replication in AeroDB aims to:</p> <ul> <li>Extend correctness across nodes</li> <li>Preserve determinism end-to-end</li> <li>Make failure explicit and survivable</li> <li>Avoid all heuristic behavior</li> <li>Remain compatible with frozen MVCC semantics</li> </ul> <p>Replication is not an optimization. It is correctness, extended in space.</p>"},{"location":"REPL_WAL_FLOW/","title":"REPLICATION_LOG_FLOW.md","text":""},{"location":"REPL_WAL_FLOW/#aerodb-replication-log-flow-state-propagation","title":"AeroDB \u2014 Replication Log Flow &amp; State Propagation","text":""},{"location":"REPL_WAL_FLOW/#status","title":"Status","text":"<ul> <li>This document is authoritative</li> <li>It defines how history moves from Primary to Replica</li> <li>WAL is the only replicated unit of truth</li> <li>No implementation details or optimizations appear here</li> <li>Phase-1 and MVCC semantics are frozen and assumed correct</li> </ul>"},{"location":"REPL_WAL_FLOW/#1-purpose-of-log-flow-design","title":"1. Purpose of Log Flow Design","text":"<p>Replication correctness in AeroDB depends on one fact:</p> <p>All authoritative history is encoded in the WAL.</p> <p>This document defines:</p> <ul> <li>What is replicated</li> <li>In what order</li> <li>With what completeness guarantees</li> <li>How gaps and inconsistencies are detected</li> <li>When replication must stop</li> </ul> <p>Replication is history replication, not state reconstruction.</p>"},{"location":"REPL_WAL_FLOW/#2-replication-units","title":"2. Replication Units","text":""},{"location":"REPL_WAL_FLOW/#21-wal-as-the-replication-unit","title":"2.1 WAL as the Replication Unit","text":"<p>The WAL is:</p> <ul> <li>Totally ordered</li> <li>Checksummed</li> <li>CommitId-governed</li> <li>Deterministic under replay</li> </ul> <p>Replication must replicate WAL records verbatim.</p> <p>Replication must not:</p> <ul> <li>Re-encode WAL entries</li> <li>Reorder WAL entries</li> <li>Merge or split WAL entries</li> <li>Infer missing WAL entries</li> </ul>"},{"location":"REPL_WAL_FLOW/#22-replicated-record-scope","title":"2.2 Replicated Record Scope","text":"<p>All WAL records are replicated, including but not limited to:</p> <ul> <li>Commit identity records</li> <li>Version persistence records</li> <li>Snapshot markers</li> <li>GC records</li> <li>Checkpoint markers</li> </ul> <p>If a WAL record affects recovery or visibility, it must be replicated.</p>"},{"location":"REPL_WAL_FLOW/#3-ordering-guarantees","title":"3. Ordering Guarantees","text":""},{"location":"REPL_WAL_FLOW/#31-strict-order-preservation","title":"3.1 Strict Order Preservation","text":"<p>Replication must preserve:</p> <ul> <li>Byte-level WAL order</li> <li>CommitId ordering</li> <li>Logical causality</li> </ul> <p>For any two WAL records <code>A</code> and <code>B</code>:</p> <pre><code>If A precedes B on Primary WAL\n\u2192 A must precede B on Replica WAL\n</code></pre> <p>No exceptions.</p>"},{"location":"REPL_WAL_FLOW/#32-prefix-application-rule","title":"3.2 Prefix Application Rule","text":"<p>At any time, a Replica\u2019s applied WAL must satisfy:</p> <pre><code>Replica_WAL == Prefix(Primary_WAL)\n</code></pre> <p>Replicas may lag, but must never:</p> <ul> <li>Skip records</li> <li>Reorder records</li> <li>Invent records</li> </ul>"},{"location":"REPL_WAL_FLOW/#4-wal-transfer-semantics","title":"4. WAL Transfer Semantics","text":""},{"location":"REPL_WAL_FLOW/#41-transfer-model-abstract","title":"4.1 Transfer Model (Abstract)","text":"<p>Replication is defined abstractly as:</p> <ul> <li>Primary emits WAL records</li> <li>Replica receives WAL records</li> <li>Replica appends them to its WAL</li> <li>Replica replays them deterministically</li> </ul> <p>The transport mechanism is out of scope.</p>"},{"location":"REPL_WAL_FLOW/#42-durability-boundary","title":"4.2 Durability Boundary","text":"<p>A WAL record is considered replicated only when:</p> <ul> <li>It is durably appended to the Replica\u2019s WAL</li> <li>Its checksum is verified</li> <li>Its ordering is validated</li> </ul> <p>Partial receipt does not count.</p>"},{"location":"REPL_WAL_FLOW/#5-gap-detection","title":"5. Gap Detection","text":""},{"location":"REPL_WAL_FLOW/#51-explicit-gap-definition","title":"5.1 Explicit Gap Definition","text":"<p>A WAL gap exists if:</p> <ul> <li>Replica receives record <code>N+1</code></li> <li>Record <code>N</code> is missing or corrupted</li> </ul> <p>Gaps are detected by:</p> <ul> <li>WAL sequence metadata</li> <li>Checksums</li> <li>Explicit ordering markers</li> </ul>"},{"location":"REPL_WAL_FLOW/#52-gap-handling-rule","title":"5.2 Gap Handling Rule","text":"<p>If a gap is detected:</p> <ul> <li>Replica must stop applying WAL</li> <li>Replica enters <code>ReplicationHalted</code></li> <li>No reads or writes are allowed</li> </ul> <p>Gaps are fatal until resolved explicitly.</p>"},{"location":"REPL_WAL_FLOW/#6-snapshot-vs-wal-bootstrap","title":"6. Snapshot vs WAL Bootstrap","text":"<p>Replication supports two bootstrap paths, both correctness-equivalent.</p>"},{"location":"REPL_WAL_FLOW/#61-wal-only-bootstrap","title":"6.1 WAL-Only Bootstrap","text":"<p>Allowed only if:</p> <ul> <li>Replica has an empty state</li> <li>Full WAL history is available</li> <li>WAL replay cost is acceptable</li> </ul> <p>Replica behavior:</p> <ul> <li>Receive WAL from genesis</li> <li>Replay deterministically</li> </ul>"},{"location":"REPL_WAL_FLOW/#62-snapshot-based-bootstrap","title":"6.2 Snapshot-Based Bootstrap","text":"<p>Allowed when:</p> <ul> <li>WAL history is too large</li> <li>Replica is too far behind</li> <li>Operator initiates snapshot transfer</li> </ul> <p>Snapshot must:</p> <ul> <li>Represent a valid MVCC cut</li> <li>Include commit boundary</li> <li>Be self-contained</li> </ul> <p>After snapshot restore:</p> <ul> <li>Replica resumes WAL replay strictly after snapshot boundary</li> </ul>"},{"location":"REPL_WAL_FLOW/#7-snapshot-wal-consistency-rule","title":"7. Snapshot + WAL Consistency Rule","text":"<p>If snapshot boundary commit is <code>C_snap</code>:</p> <ul> <li>WAL replay must begin at:</li> </ul> <p><pre><code>CommitId &gt; C_snap\n</code></pre> * WAL entries \u2264 <code>C_snap</code> must not be replayed * WAL entries &gt; <code>C_snap</code> must be contiguous</p> <p>Violation \u2192 fatal error.</p>"},{"location":"REPL_WAL_FLOW/#8-replica-wal-validation","title":"8. Replica WAL Validation","text":"<p>Before applying replicated WAL, Replica must verify:</p> <ul> <li>WAL record integrity</li> <li>CommitId monotonicity</li> <li>No divergence from local history</li> <li>No conflicting records</li> </ul> <p>If validation fails \u2192 replication halts.</p>"},{"location":"REPL_WAL_FLOW/#9-interaction-with-mvcc","title":"9. Interaction with MVCC","text":"<p>Replication must preserve:</p> <ul> <li>CommitId assignment order</li> <li>Version creation order</li> <li>Snapshot boundaries</li> <li>GC eligibility semantics</li> </ul> <p>Replication must not:</p> <ul> <li>Recompute MVCC state</li> <li>Skip MVCC metadata</li> <li>Compact history implicitly</li> </ul> <p>Replica MVCC state must match Primary for the same WAL prefix.</p>"},{"location":"REPL_WAL_FLOW/#10-crash-semantics-during-replication","title":"10. Crash Semantics During Replication","text":""},{"location":"REPL_WAL_FLOW/#101-crash-during-wal-transfer","title":"10.1 Crash During WAL Transfer","text":"<p>If Replica crashes:</p> <ul> <li>Before WAL append \u2192 record is lost, retransmission required</li> <li>After WAL append \u2192 record is durable</li> </ul> <p>Recovery replays WAL deterministically.</p>"},{"location":"REPL_WAL_FLOW/#102-crash-during-snapshot-transfer","title":"10.2 Crash During Snapshot Transfer","text":"<p>If crash occurs:</p> <ul> <li> <p>Snapshot is either:</p> </li> <li> <p>Fully applied, or</p> </li> <li>Fully discarded</li> </ul> <p>No partial snapshot state is valid.</p>"},{"location":"REPL_WAL_FLOW/#11-explicitly-forbidden-behaviors","title":"11. Explicitly Forbidden Behaviors","text":"<p>Replication must never:</p> <ul> <li>Apply WAL out of order</li> <li>Skip WAL records</li> <li>\u201cFill gaps\u201d heuristically</li> <li>Reconstruct WAL from state</li> <li>Apply WAL without checksum verification</li> <li>Continue replication after divergence</li> </ul> <p>Correctness &gt; liveness.</p>"},{"location":"REPL_WAL_FLOW/#12-log-flow-summary","title":"12. Log Flow Summary","text":"<p>Replication log flow guarantees:</p> <ul> <li>Single authoritative history</li> <li>Deterministic state propagation</li> <li>Explicit detection of inconsistency</li> <li>Safe lag, never silent divergence</li> </ul> <p>If history cannot be proven identical, replication must stop.</p>"},{"location":"SECURITY/","title":"Security Policy","text":""},{"location":"SECURITY/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>DO NOT publicly disclose security vulnerabilities.</p> <p>If you discover a security issue in AeroDB, please report it privately:</p>"},{"location":"SECURITY/#how-to-report","title":"How to Report","text":"<ol> <li>Email: Send details to the maintainers</li> <li>Include:</li> <li>Description of the vulnerability</li> <li>Steps to reproduce</li> <li>Potential impact</li> <li>Suggested fix (if any)</li> </ol>"},{"location":"SECURITY/#what-to-expect","title":"What to Expect","text":"<ul> <li>Acknowledgment: Within 48 hours</li> <li>Investigation: We'll investigate and confirm the issue</li> <li>Fix Timeline: Critical issues fixed within 7 days</li> <li>Public Disclosure: After fix is released</li> </ul>"},{"location":"SECURITY/#vulnerability-types-we-care-about","title":"Vulnerability Types We Care About","text":"<p>Critical: - Data loss or corruption - Authentication bypass - Unauthorized data access - Denial of service (crash-inducing) - Code execution vulnerabilities</p> <p>Medium: - Information disclosure - Session hijacking - CSRF attacks</p> <p>Low: - Minor information leakage - Best practice deviations</p>"},{"location":"SECURITY/#supported-versions","title":"Supported Versions","text":"Version Supported 0.1.x \u2705 Yes"},{"location":"SECURITY/#security-features","title":"Security Features","text":""},{"location":"SECURITY/#authentication","title":"Authentication","text":"<ul> <li>Argon2 password hashing</li> <li>JWT-based session management</li> <li>Configurable token expiration</li> <li>Password complexity requirements</li> </ul>"},{"location":"SECURITY/#data-protection","title":"Data Protection","text":"<ul> <li>WAL-backed durability</li> <li>Authenticated write confirmation</li> <li>Crash-safe recovery</li> <li>Schema validation</li> </ul>"},{"location":"SECURITY/#network-security","title":"Network Security","text":"<ul> <li>CORS protection</li> <li>HTTPS recommended for production</li> <li>Signed URLs for storage access</li> </ul>"},{"location":"SECURITY/#best-practices","title":"Best Practices","text":""},{"location":"SECURITY/#deployment","title":"Deployment","text":"<ol> <li>Use HTTPS: Always run behind TLS in production</li> <li>Strong Passwords: Enforce minimum 12-character passwords</li> <li>Regular Backups: Automated snapshots</li> <li>Update Promptly: Apply security patches immediately</li> <li>Least Privilege: Grant minimal necessary permissions</li> </ol>"},{"location":"SECURITY/#configuration","title":"Configuration","text":"<pre><code># Strong JWT settings\nJWT_EXPIRY=24h  # Or less\nREFRESH_EXPIRY=7d\n\n# Password requirements\nPASSWORD_MIN_LENGTH=12\nREQUIRE_UPPERCASE=true\nREQUIRE_NUMBER=true\nREQUIRE_SPECIAL=true\n</code></pre>"},{"location":"SECURITY/#monitoring","title":"Monitoring","text":"<ul> <li>Enable audit logging</li> <li>Monitor failed authentication attempts</li> <li>Track unusual query patterns</li> <li>Alert on permission escalation attempts</li> </ul>"},{"location":"SECURITY/#known-limitations","title":"Known Limitations","text":"<ul> <li>No Built-in Encryption at Rest: Use filesystem-level encryption (LUKS/dm-crypt)</li> <li>Basic RBAC: Row-level security in development</li> <li>Rate Limiting: Implement at reverse proxy level</li> </ul>"},{"location":"SECURITY/#security-updates","title":"Security Updates","text":"<p>Security patches are released as soon as fixes are validated. Subscribe to: - GitHub Security Advisories - Release notifications</p>"},{"location":"SECURITY/#responsible-disclosure","title":"Responsible Disclosure","text":"<p>We follow responsible disclosure practices: 1. Private report received 2. Fix developed and tested 3. Patch released 4. Public disclosure with credit</p>"},{"location":"SECURITY/#credits","title":"Credits","text":"<p>We appreciate security researchers who help make AeroDB safer. Responsible disclosures will be credited in: - CHANGELOG.md - Security advisory - Hall of fame (coming soon)</p> <p>Last Updated: 2026-02-07</p>"},{"location":"SPEC_INDEX/","title":"AeroDB \u2014 Specification Index (Authoritative)","text":""},{"location":"SPEC_INDEX/#status","title":"Status","text":"<ul> <li>Scope: Entire AeroDB specification</li> <li>Authority: Index-only, non-semantic</li> <li>Purpose: Canonical reading order and authority map</li> </ul> <p>This document defines: - Which documents exist - What they govern - In which order they MUST be read</p> <p>This document does NOT define behavior. It defines how to understand behavior correctly.</p>"},{"location":"SPEC_INDEX/#1-how-to-use-this-index","title":"1. How to Use This Index","text":""},{"location":"SPEC_INDEX/#mandatory-rule","title":"Mandatory Rule","text":"<p>You MUST read documents in the order specified here.</p> <p>Skipping ahead, cherry-picking, or reading by filename order WILL produce an incorrect understanding of AeroDB.</p>"},{"location":"SPEC_INDEX/#authority-rule","title":"Authority Rule","text":"<p>If two documents appear to conflict: - The document that appears earlier in this index wins - Later documents MUST defer</p>"},{"location":"SPEC_INDEX/#2-tier-0-project-constitution-absolute-authority","title":"2. Tier 0 \u2014 Project Constitution (Absolute Authority)","text":"<p>These documents define AeroDB\u2019s identity and non-negotiable rules.</p> <p>Read first. Never reinterpret.</p> <ol> <li> <p><code>CORE_VISION.md</code> Governs: What AeroDB is and why it exists</p> </li> <li> <p><code>CORE_SCOPE.md</code> Governs: What AeroDB explicitly does and does not do</p> </li> <li> <p><code>CORE_INVARIANTS.md</code> Governs: Global correctness, durability, determinism rules</p> </li> <li> <p><code>CORE_RELIABILITY.md</code> Governs: Failure philosophy and correctness under fault</p> </li> </ol>"},{"location":"SPEC_INDEX/#3-tier-1-core-system-phase-1-frozen","title":"3. Tier 1 \u2014 Core System (Phase 1, Frozen)","text":"<p>These documents define the foundational database mechanics. They are fully implemented and frozen.</p> <ol> <li> <p><code>CORE_BOOT.md</code> Governs: Startup and initialization sequence</p> </li> <li> <p><code>CORE_LIFECYCLE.md</code> Governs: Runtime lifecycle and state transitions</p> </li> <li> <p><code>CORE_WAL.md</code> Governs: Write-ahead log semantics and durability</p> </li> <li> <p><code>CORE_STORAGE.md</code> Governs: Append-only storage model</p> </li> <li> <p><code>CORE_SNAPSHOT.md</code> Governs: Snapshot creation and immutability</p> </li> <li> <p><code>CORE_CHECKPOINT.md</code> Governs: Checkpoint creation and WAL truncation</p> </li> <li> <p><code>CORE_BACKUP.md</code> Governs: Backup semantics</p> </li> <li> <p><code>CORE_RESTORE.md</code> Governs: Restore semantics</p> </li> <li> <p><code>CORE_SCHEMA.md</code> Governs: Schema definition and validation</p> </li> <li> <p><code>CORE_QUERY.md</code> Governs: Query parsing, planning, execution, bounds</p> </li> <li> <p><code>CORE_API_SPEC.md</code> Governs: External client-facing API (non-admin)</p> </li> <li> <p><code>CORE_ERRORS.md</code> Governs: Error taxonomy and guarantees</p> </li> </ol>"},{"location":"SPEC_INDEX/#4-tier-2-mvcc-phase-2a-frozen","title":"4. Tier 2 \u2014 MVCC (Phase 2A, Frozen)","text":"<p>These documents define visibility, isolation, and versioning. Semantics are frozen and authoritative.</p> <ol> <li> <p><code>MVCC_MODEL.md</code> Governs: MVCC conceptual model</p> </li> <li> <p><code>MVCC_VISIBILITY_RULES.md</code> Governs: Snapshot isolation and version visibility</p> </li> <li> <p><code>MVCC_WAL_INTEGRATION.md</code> Governs: WAL \u2194 MVCC interaction</p> </li> <li> <p><code>MVCC_SNAPSHOT_MODEL.md</code> Governs: MVCC-aware snapshots</p> </li> <li> <p><code>MVCC_GC_MODEL.md</code> Governs: Garbage collection rules</p> </li> <li> <p><code>MVCC_FAILURE_MATRIX.md</code> Governs: Crash behavior under MVCC</p> </li> <li> <p><code>MVCC_COMPATIBILITY.md</code> Governs: Compatibility with other phases</p> </li> <li> <p><code>MVCC_TESTING.md</code> Governs: MVCC testing strategy</p> </li> </ol>"},{"location":"SPEC_INDEX/#5-tier-3-replication-phase-2b-semantics-frozen","title":"5. Tier 3 \u2014 Replication (Phase 2B, Semantics Frozen)","text":"<p>These documents define multi-node correctness. Implementation may follow, semantics must not change.</p> <ol> <li> <p><code>REPL_VISION.md</code> Governs: Replication goals and model</p> </li> <li> <p><code>REPL_INVARIANTS.md</code> Governs: Replication correctness rules</p> </li> <li> <p><code>REPL_PROOFS.md</code> Governs: Correctness proofs</p> </li> <li> <p><code>REPL_MODEL.md</code> Governs: Primary/replica architecture</p> </li> <li> <p><code>REPL_WAL_FLOW.md</code> Governs: WAL shipping and prefix rules</p> </li> <li> <p><code>REPL_READ_RULES.md</code> Governs: Replica read safety</p> </li> <li> <p><code>REPL_RECOVERY_MODEL.md</code> Governs: Replica recovery semantics</p> </li> <li> <p><code>REPL_SNAPSHOT_TRANSFER.md</code> Governs: Snapshot bootstrap</p> </li> <li> <p><code>REPL_FAILURE_MATRIX.md</code> Governs: Replication failure handling</p> </li> <li> <p><code>REPL_COMPATIBILITY.md</code> Governs: Interaction with MVCC and Phase 1</p> </li> </ol>"},{"location":"SPEC_INDEX/#6-tier-4-performance-phase-3-frozen-semantics","title":"6. Tier 4 \u2014 Performance (Phase 3, Frozen Semantics)","text":"<p>These documents define correctness-preserving optimizations.</p> <ol> <li> <p><code>PERF_VISION.md</code> Governs: Phase 3 intent and limits</p> </li> <li> <p><code>PERF_INVARIANTS.md</code> Governs: Performance safety rules</p> </li> <li> <p><code>PERF_PROOF_RULES.md</code> Governs: How optimizations are proven</p> </li> <li> <p><code>PERF_BASELINE.md</code> Governs: Baseline performance reference</p> </li> <li> <p><code>CRITICAL_PATHS.md</code> Governs: Optimization-eligible execution paths</p> </li> <li> <p><code>PERF_SEMANTIC_EQUIVALENCE.md</code> Governs: What \u201cequivalent behavior\u201d means</p> </li> <li> <p><code>PERF_FAILURE_MODEL.md</code> Governs: Failure assumptions for optimizations</p> </li> <li> <p><code>PERF_DISABLEMENT.md</code> Governs: Rollback and disablement rules</p> </li> <li> <p><code>PERF_OBSERVABILITY.md</code> Governs: Performance metrics without behavior impact</p> </li> </ol>"},{"location":"SPEC_INDEX/#phase-3-optimization-specs-read-after-above","title":"Phase 3 Optimization Specs (Read After Above)","text":"<ol> <li><code>PERF_GROUP_COMMIT.md</code> </li> <li><code>PERF_WAL_BATCHING.md</code> </li> <li><code>PERF_READ_PATH.md</code> </li> <li><code>PERF_INDEX_ACCELERATION.md</code> </li> <li><code>PERF_CHECKPOINT_PIPELINING.md</code> </li> <li><code>PERF_REPLICA_READ_FAST_PATH.md</code> </li> <li><code>PERF_MEMORY_LAYOUT.md</code> </li> </ol>"},{"location":"SPEC_INDEX/#7-tier-5-developer-experience-phase-4","title":"7. Tier 5 \u2014 Developer Experience (Phase 4)","text":"<p>These documents make AeroDB visible and explainable. They add no semantics.</p> <ol> <li> <p><code>DX_VISION.md</code> Governs: Phase 4 goals</p> </li> <li> <p><code>DX_INVARIANTS.md</code> Governs: UI and observability safety</p> </li> <li> <p><code>DX_OBSERVABILITY_PRINCIPLES.md</code> Governs: Passive observability philosophy</p> </li> <li> <p><code>DX_OBSERVABILITY_API.md</code> Governs: Read-only admin APIs</p> </li> <li> <p><code>DX_EXPLANATION_MODEL.md</code> Governs: Explanation structure and rules</p> </li> <li> <p><code>DX_ADMIN_UI_ARCH.md</code> Governs: Admin UI architecture</p> </li> </ol>"},{"location":"SPEC_INDEX/#8-tier-6-meta-tooling-and-process","title":"8. Tier 6 \u2014 Meta, Tooling, and Process","text":"<p>These documents guide usage and contribution. They have no semantic authority.</p> <ol> <li><code>PROJECT_PLAN.md</code> </li> <li><code>INIT_READINESS.md</code> </li> <li><code>REPLICATION_VISION.md</code> </li> <li><code>REPLICATION_ROADMAP.md</code> </li> <li><code>REPLICATION_READINESS.md</code> </li> <li><code>INSTALL.md</code> </li> <li><code>CONFIG.md</code> </li> <li><code>CRASH_TESTING.md</code> </li> <li><code>CLAUDE.md</code> </li> <li><code>tree.md</code></li> </ol>"},{"location":"SPEC_INDEX/#9-final-authority-rule-repeat","title":"9. Final Authority Rule (Repeat)","text":"<p>If you are unsure which document governs a behavior, the one that appears earlier in this index is authoritative.</p> <p>This index is the map. The documents are the law.</p> <p>END OF DOCUMENT</p>"},{"location":"tree/","title":"Tree","text":"<p>. \u251c\u2500\u2500 ADMIN_UI_ARCHITECTURE.md \u251c\u2500\u2500 API_SPEC.md \u251c\u2500\u2500 BACKUP.md \u251c\u2500\u2500 BOOT.md \u251c\u2500\u2500 CHECKPOINT.md \u251c\u2500\u2500 CHECKPOINT_PIPELINING.md \u251c\u2500\u2500 CLAUDE.md \u251c\u2500\u2500 CONFIG.md \u251c\u2500\u2500 CRASH_TESTING.md \u251c\u2500\u2500 CRITICAL_PATHS.md \u251c\u2500\u2500 ERRORS.md \u251c\u2500\u2500 EXPLANATION_MODEL.md \u251c\u2500\u2500 FAILURE_MODEL_PHASE3.md \u251c\u2500\u2500 GROUP_COMMIT.md \u251c\u2500\u2500 INDEX_ACCELERATION.md \u251c\u2500\u2500 INSTALL.md \u251c\u2500\u2500 INVARIANTS.md \u251c\u2500\u2500 LIFECYCLE.md \u251c\u2500\u2500 MEMORY_LAYOUT_OPTIMIZATION.md \u251c\u2500\u2500 MVCC_COMPATIBILITY.md \u251c\u2500\u2500 MVCC_FAILURE_MATRIX.md \u251c\u2500\u2500 MVCC_GC.md \u251c\u2500\u2500 MVCC.md \u251c\u2500\u2500 MVCC_SNAPSHOT_INTEGRATION.md \u251c\u2500\u2500 MVCC_TESTING_STRATEGY.md \u251c\u2500\u2500 MVCC_VISIBILITY.md \u251c\u2500\u2500 MVCC_WAL_INTERACTION.md \u251c\u2500\u2500 OBSERVABILITY_API.md \u251c\u2500\u2500 OBSERVABILITY.md \u251c\u2500\u2500 PERFORMANCE_BASELINE.md \u251c\u2500\u2500 PERFORMANCE_OBSERVABILITY.md \u251c\u2500\u2500 INIT_READINESS.md \u251c\u2500\u2500 REPLICATION_INVARIANTS.md \u251c\u2500\u2500 REPLICATION_PROOFS.md \u251c\u2500\u2500 REPLICATION_INVARIANTS.md \u251c\u2500\u2500 REPLICATION_PROOFS.md \u251c\u2500\u2500 REPLICATION_READINESS.md \u251c\u2500\u2500 REPLICATION_ROADMAP.md \u251c\u2500\u2500 REPLICATION_VISION.md \u251c\u2500\u2500 REPLICATION_ROADMAP.md \u251c\u2500\u2500 REPLICATION_VISION.md \u251c\u2500\u2500 PERF_INVARIANTS.md \u251c\u2500\u2500 PERF_PROOF_RULES.md \u251c\u2500\u2500 PERF_VISION.md \u251c\u2500\u2500 PHASE4_INVARIANTS.md \u251c\u2500\u2500 PHASE4_VISION.md \u251c\u2500\u2500 PLAN.md \u251c\u2500\u2500 QUERY.md \u251c\u2500\u2500 READ_PATH_OPTIMIZATION.md \u251c\u2500\u2500 RELIABILITY.md \u251c\u2500\u2500 REPLICA_READ_FAST_PATH.md \u251c\u2500\u2500 REPLICATION_COMPATIBILITY.md \u251c\u2500\u2500 REPLICATION_FAILURE_MATRIX.md \u251c\u2500\u2500 REPLICATION_LOG_FLOW.md \u251c\u2500\u2500 REPLICATION_MODEL.md \u251c\u2500\u2500 REPLICATION_READ_SEMANTICS.md \u251c\u2500\u2500 REPLICATION_RECOVERY.md \u251c\u2500\u2500 REPLICATION_SNAPSHOT_TRANSFER.md \u251c\u2500\u2500 RESTORE.md \u251c\u2500\u2500 ROLLBACK_AND_DISABLEMENT.md \u251c\u2500\u2500 SCHEMA.md \u251c\u2500\u2500 SCOPE.md \u251c\u2500\u2500 SEMANTIC_EQUIVALENCE.md \u251c\u2500\u2500 SNAPSHOT.md \u251c\u2500\u2500 STORAGE.md \u251c\u2500\u2500 tree.md \u251c\u2500\u2500 VISION.md \u251c\u2500\u2500 WAL_BATCHING.md \u2514\u2500\u2500 WAL.md</p> <p>1 directory, 69 files</p>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get AeroDB up and running on your local machine in minutes.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Rust (1.70 or later): <code>rustc --version</code></li> <li>Node.js (18 or later): <code>node --version</code></li> <li>Git: <code>git --version</code></li> </ul>"},{"location":"getting-started/quickstart/#step-1-clone-the-repository","title":"Step 1: Clone the Repository","text":"<pre><code>git clone https://github.com/eshanized/AeroDB.git\ncd AeroDB\n</code></pre>"},{"location":"getting-started/quickstart/#step-2-build-the-backend","title":"Step 2: Build the Backend","text":"<p>Compile the Rust backend in release mode for optimal performance:</p> <pre><code>cargo build --release\n</code></pre> <p>Compilation Time</p> <p>The first build might take a few minutes as it compiles all dependencies. Subsequent builds will be much faster.</p>"},{"location":"getting-started/quickstart/#step-3-install-frontend-dependencies","title":"Step 3: Install Frontend Dependencies","text":"<p>Navigate to the dashboard directory and install the necessary packages:</p> <pre><code>cd dashboard\nnpm install\ncd ..\n</code></pre>"},{"location":"getting-started/quickstart/#step-4-run-the-server","title":"Step 4: Run the Server","text":"<p>Start the AeroDB backend server:</p> <pre><code># Run from the root directory\ncargo run --release -- serve\n</code></pre> <p>You should see output indicating the server is running on <code>http://localhost:54321</code>.</p>"},{"location":"getting-started/quickstart/#step-5-start-the-dashboard","title":"Step 5: Start the Dashboard","text":"<p>In a new terminal window, start the frontend development server:</p> <pre><code>cd dashboard\nnpm run dev\n</code></pre> <p>Open your browser and navigate to <code>http://localhost:5173</code>.</p>"},{"location":"getting-started/quickstart/#step-6-first-run-setup","title":"Step 6: First-Run Setup","text":"<p>Since this is a fresh installation, you will be redirected to the Setup Wizard.</p> <ol> <li>Welcome: Click \"Start Setup\".</li> <li>Storage: Choose where AeroDB should store its data. The defaults (<code>./data</code>, <code>./wal</code>, etc.) are fine for development.</li> <li>Authentication: Set your JWT expiration preferences (e.g., 24 hours).</li> <li>Admin User: Create your super-admin account. Remember these credentials!</li> <li>Review: Confirm your settings.</li> <li>Complete: Click \"Go to Dashboard\".</li> </ol>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Congratulations! You now have a running instance of AeroDB.</p> <ul> <li>Explore the Core Principles</li> <li>Learn about the Architecture</li> <li>Read the API Specification</li> </ul> <p>Production Deployment</p> <p>For production environments, ensure you configure HTTPS and use a process manager like <code>systemd</code> or <code>supervisord</code>.</p>"}]}